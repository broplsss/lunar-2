! function(t) { var e; "object" == typeof exports ? module.exports = t() : ("undefined" != typeof window ? e = window : "undefined" != typeof global ? e = global : "undefined" != typeof self && (e = self), e.p2 = t()) }(function() {
    return function o(n, a, r) {
        function h(i, t) {
            if (!a[i]) {
                if (!n[i]) { var e = "function" == typeof require && require; if (!t && e) return e(i, !0); if (l) return l(i, !0); throw new Error("Cannot find module '" + i + "'") }
                var s = a[i] = { exports: {} };
                n[i][0].call(s.exports, function(t) { var e = n[i][1][t]; return h(e || t) }, s, s.exports, o, n, a, r)
            }
            return a[i].exports
        }
        for (var l = "function" == typeof require && require, t = 0; t < r.length; t++) h(r[t]);
        return h
    }({
        1: [function(t, e, i) {
            var p = t("./Scalar");

            function s() {}(e.exports = s).lineInt = function(t, e, i) { i = i || 0; var s, o, n, a, r, h, l, c = [0, 0]; return s = t[1][1] - t[0][1], o = t[0][0] - t[1][0], n = s * t[0][0] + o * t[0][1], a = e[1][1] - e[0][1], r = e[0][0] - e[1][0], h = a * e[0][0] + r * e[0][1], l = s * r - a * o, p.eq(l, 0, i) || (c[0] = (r * n - o * h) / l, c[1] = (s * h - a * n) / l), c }, s.segmentsIntersect = function(t, e, i, s) {
                var o = e[0] - t[0],
                    n = e[1] - t[1],
                    a = s[0] - i[0],
                    r = s[1] - i[1];
                if (a * n - r * o == 0) return !1;
                var h = (o * (i[1] - t[1]) + n * (t[0] - i[0])) / (a * n - r * o),
                    l = (a * (t[1] - i[1]) + r * (i[0] - t[0])) / (r * o - a * n);
                return 0 <= h && h <= 1 && 0 <= l && l <= 1
            }
        }, { "./Scalar": 4 }],
        2: [function(t, e, i) {
            function l() {}(e.exports = l).area = function(t, e, i) { return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]) }, l.left = function(t, e, i) { return 0 < l.area(t, e, i) }, l.leftOn = function(t, e, i) { return 0 <= l.area(t, e, i) }, l.right = function(t, e, i) { return l.area(t, e, i) < 0 }, l.rightOn = function(t, e, i) { return l.area(t, e, i) <= 0 };
            var c = [],
                p = [];
            l.collinear = function(t, e, i, s) {
                if (s) {
                    var o = c,
                        n = p;
                    o[0] = e[0] - t[0], o[1] = e[1] - t[1], n[0] = i[0] - e[0], n[1] = i[1] - e[1];
                    var a = o[0] * n[0] + o[1] * n[1],
                        r = Math.sqrt(o[0] * o[0] + o[1] * o[1]),
                        h = Math.sqrt(n[0] * n[0] + n[1] * n[1]);
                    return Math.acos(a / (r * h)) < s
                }
                return 0 == l.area(t, e, i)
            }, l.sqdist = function(t, e) {
                var i = e[0] - t[0],
                    s = e[1] - t[1];
                return i * i + s * s
            }
        }, {}],
        3: [function(t, e, i) {
            var r = t("./Line"),
                P = t("./Point"),
                u = t("./Scalar");

            function _() { this.vertices = [] }(e.exports = _).prototype.at = function(t) {
                var e = this.vertices,
                    i = e.length;
                return e[t < 0 ? t % i + i : t % i]
            }, _.prototype.first = function() { return this.vertices[0] }, _.prototype.last = function() { return this.vertices[this.vertices.length - 1] }, _.prototype.clear = function() { this.vertices.length = 0 }, _.prototype.append = function(t, e, i) { if (void 0 === e) throw new Error("From is not given!"); if (void 0 === i) throw new Error("To is not given!"); if (i - 1 < e) throw new Error("lol1"); if (i > t.vertices.length) throw new Error("lol2"); if (e < 0) throw new Error("lol3"); for (var s = e; s < i; s++) this.vertices.push(t.vertices[s]) }, _.prototype.makeCCW = function() {
                for (var t = 0, e = this.vertices, i = 1; i < this.vertices.length; ++i)(e[i][1] < e[t][1] || e[i][1] == e[t][1] && e[i][0] > e[t][0]) && (t = i);
                P.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse()
            }, _.prototype.reverse = function() {
                for (var t = [], e = 0, i = this.vertices.length; e !== i; e++) t.push(this.vertices.pop());
                this.vertices = t
            }, _.prototype.isReflex = function(t) { return P.right(this.at(t - 1), this.at(t), this.at(t + 1)) };
            var h = [],
                l = [];

            function T(t, e, i, s, o) {
                o = o || 0;
                var n = e[1] - t[1],
                    a = t[0] - e[0],
                    r = n * t[0] + a * t[1],
                    h = s[1] - i[1],
                    l = i[0] - s[0],
                    c = h * i[0] + l * i[1],
                    p = n * l - h * a;
                return u.eq(p, 0, o) ? [0, 0] : [(l * r - a * c) / p, (n * c - h * r) / p]
            }
            _.prototype.canSee = function(t, e) {
                var i, s, o = h,
                    n = l;
                if (P.leftOn(this.at(t + 1), this.at(t), this.at(e)) && P.rightOn(this.at(t - 1), this.at(t), this.at(e))) return !1;
                s = P.sqdist(this.at(t), this.at(e));
                for (var a = 0; a !== this.vertices.length; ++a)
                    if ((a + 1) % this.vertices.length !== t && a !== t && P.leftOn(this.at(t), this.at(e), this.at(a + 1)) && P.rightOn(this.at(t), this.at(e), this.at(a)) && (o[0] = this.at(t), o[1] = this.at(e), n[0] = this.at(a), n[1] = this.at(a + 1), i = r.lineInt(o, n), P.sqdist(this.at(t), i) < s)) return !1;
                return !0
            }, _.prototype.copy = function(t, e, i) {
                var s = i || new _;
                if (s.clear(), t < e)
                    for (var o = t; o <= e; o++) s.vertices.push(this.vertices[o]);
                else { for (o = 0; o <= e; o++) s.vertices.push(this.vertices[o]); for (o = t; o < this.vertices.length; o++) s.vertices.push(this.vertices[o]) }
                return s
            }, _.prototype.getCutEdges = function() {
                for (var t = [], e = [], i = [], s = new _, o = Number.MAX_VALUE, n = 0; n < this.vertices.length; ++n)
                    if (this.isReflex(n))
                        for (var a = 0; a < this.vertices.length; ++a)
                            if (this.canSee(n, a)) {
                                e = this.copy(n, a, s).getCutEdges(), i = this.copy(a, n, s).getCutEdges();
                                for (var r = 0; r < i.length; r++) e.push(i[r]);
                                e.length < o && (o = (t = e).length, t.push([this.at(n), this.at(a)]))
                            }
                return t
            }, _.prototype.decomp = function() { var t = this.getCutEdges(); return 0 < t.length ? this.slice(t) : [this] }, _.prototype.slice = function(t) {
                if (0 == t.length) return [this];
                if (t instanceof Array && t.length && t[0] instanceof Array && 2 == t[0].length && t[0][0] instanceof Array) {
                    for (var e = [this], i = 0; i < t.length; i++)
                        for (var s = t[i], o = 0; o < e.length; o++) { var n = e[o].slice(s); if (n) { e.splice(o, 1), e.push(n[0], n[1]); break } }
                    return e
                }
                s = t, i = this.vertices.indexOf(s[0]), o = this.vertices.indexOf(s[1]);
                return -1 != i && -1 != o && [this.copy(i, o), this.copy(o, i)]
            }, _.prototype.isSimple = function() {
                for (var t = this.vertices, e = 0; e < t.length - 1; e++)
                    for (var i = 0; i < e - 1; i++)
                        if (r.segmentsIntersect(t[e], t[e + 1], t[i], t[i + 1])) return !1;
                for (e = 1; e < t.length - 2; e++)
                    if (r.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1])) return !1;
                return !0
            }, _.prototype.quickDecomp = function(t, e, i, s, o, n) {
                o = o || 100, n = n || 0, s = s || 25, t = void 0 !== t ? t : [], e = e || [], i = i || [];
                var a = [0, 0],
                    r = [0, 0],
                    h = [0, 0],
                    l = 0,
                    c = 0,
                    p = 0,
                    u = 0,
                    d = 0,
                    y = 0,
                    g = 0,
                    f = new _,
                    m = new _,
                    v = this,
                    x = this.vertices;
                if (x.length < 3) return t;
                if (o < ++n) return t;
                for (var b = 0; b < this.vertices.length; ++b)
                    if (v.isReflex(b)) {
                        e.push(v.vertices[b]), l = c = Number.MAX_VALUE;
                        for (var w = 0; w < this.vertices.length; ++w) P.left(v.at(b - 1), v.at(b), v.at(w)) && P.rightOn(v.at(b - 1), v.at(b), v.at(w - 1)) && (h = T(v.at(b - 1), v.at(b), v.at(w), v.at(w - 1)), P.right(v.at(b + 1), v.at(b), h) && (p = P.sqdist(v.vertices[b], h)) < c && (c = p, r = h, y = w)), P.left(v.at(b + 1), v.at(b), v.at(w + 1)) && P.rightOn(v.at(b + 1), v.at(b), v.at(w)) && (h = T(v.at(b + 1), v.at(b), v.at(w), v.at(w + 1)), P.left(v.at(b - 1), v.at(b), h) && (p = P.sqdist(v.vertices[b], h)) < l && (l = p, a = h, d = w));
                        if (y == (d + 1) % this.vertices.length) h[0] = (r[0] + a[0]) / 2, h[1] = (r[1] + a[1]) / 2, i.push(h), b < d ? (f.append(v, b, d + 1), f.vertices.push(h), m.vertices.push(h), 0 != y && m.append(v, y, v.vertices.length), m.append(v, 0, b + 1)) : (0 != b && f.append(v, b, v.vertices.length), f.append(v, 0, d + 1), f.vertices.push(h), m.vertices.push(h), m.append(v, y, b + 1));
                        else {
                            if (d < y && (d += this.vertices.length), u = Number.MAX_VALUE, d < y) return t;
                            for (w = y; w <= d; ++w) P.leftOn(v.at(b - 1), v.at(b), v.at(w)) && P.rightOn(v.at(b + 1), v.at(b), v.at(w)) && (p = P.sqdist(v.at(b), v.at(w))) < u && (u = p, g = w % this.vertices.length);
                            b < g ? (f.append(v, b, g + 1), 0 != g && m.append(v, g, x.length), m.append(v, 0, b + 1)) : (0 != b && f.append(v, b, x.length), f.append(v, 0, g + 1), m.append(v, g, b + 1))
                        }
                        return f.vertices.length < m.vertices.length ? (f.quickDecomp(t, e, i, s, o, n), m.quickDecomp(t, e, i, s, o, n)) : (m.quickDecomp(t, e, i, s, o, n), f.quickDecomp(t, e, i, s, o, n)), t
                    }
                return t.push(this), t
            }, _.prototype.removeCollinearPoints = function(t) { for (var e = 0, i = this.vertices.length - 1; 3 < this.vertices.length && 0 <= i; --i) P.collinear(this.at(i - 1), this.at(i), this.at(i + 1), t) && (this.vertices.splice(i % this.vertices.length, 1), i--, e++); return e }
        }, { "./Line": 1, "./Point": 2, "./Scalar": 4 }],
        4: [function(t, e, i) {
            function s() {}(e.exports = s).eq = function(t, e, i) { return i = i || 0, Math.abs(t - e) < i }
        }, {}],
        5: [function(t, e, i) { e.exports = { Polygon: t("./Polygon"), Point: t("./Point") } }, { "./Point": 2, "./Polygon": 3 }],
        6: [function(t, e, i) { e.exports = { name: "p2", version: "0.7.0", description: "A JavaScript 2D physics engine.", author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)", keywords: ["p2.js", "p2", "physics", "engine", "2d"], main: "./src/p2.js", engines: { node: "*" }, repository: { type: "git", url: "https://github.com/schteppe/p2.js.git" }, bugs: { url: "https://github.com/schteppe/p2.js/issues" }, licenses: [{ type: "MIT" }], devDependencies: { grunt: "^0.4.5", "grunt-contrib-jshint": "^0.11.2", "grunt-contrib-nodeunit": "^0.4.1", "grunt-contrib-uglify": "~0.4.0", "grunt-contrib-watch": "~0.5.0", "grunt-browserify": "~2.0.1", "grunt-contrib-concat": "^0.4.0" }, dependencies: { "poly-decomp": "0.1.0" } } }, {}],
        7: [function(t, e, i) {
            var d = t("../math/vec2");
            t("../utils/Utils");

            function s(t) { this.lowerBound = d.create(), t && t.lowerBound && d.copy(this.lowerBound, t.lowerBound), this.upperBound = d.create(), t && t.upperBound && d.copy(this.upperBound, t.upperBound) } e.exports = s;
            var y = d.create();
            s.prototype.setFromPoints = function(t, e, i, s) {
                var o = this.lowerBound,
                    n = this.upperBound;
                "number" != typeof i && (i = 0), 0 !== i ? d.rotate(o, t[0], i) : d.copy(o, t[0]), d.copy(n, o);
                for (var a = Math.cos(i), r = Math.sin(i), h = 1; h < t.length; h++) {
                    var l = t[h];
                    if (0 !== i) {
                        var c = l[0],
                            p = l[1];
                        y[0] = a * c - r * p, y[1] = r * c + a * p, l = y
                    }
                    for (var u = 0; u < 2; u++) l[u] > n[u] && (n[u] = l[u]), l[u] < o[u] && (o[u] = l[u])
                }
                e && (d.add(this.lowerBound, this.lowerBound, e), d.add(this.upperBound, this.upperBound, e)), s && (this.lowerBound[0] -= s, this.lowerBound[1] -= s, this.upperBound[0] += s, this.upperBound[1] += s)
            }, s.prototype.copy = function(t) { d.copy(this.lowerBound, t.lowerBound), d.copy(this.upperBound, t.upperBound) }, s.prototype.extend = function(t) {
                for (var e = 2; e--;) {
                    var i = t.lowerBound[e];
                    this.lowerBound[e] > i && (this.lowerBound[e] = i);
                    var s = t.upperBound[e];
                    this.upperBound[e] < s && (this.upperBound[e] = s)
                }
            }, s.prototype.overlaps = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound,
                    s = t.lowerBound,
                    o = t.upperBound;
                return (s[0] <= i[0] && i[0] <= o[0] || e[0] <= o[0] && o[0] <= i[0]) && (s[1] <= i[1] && i[1] <= o[1] || e[1] <= o[1] && o[1] <= i[1])
            }, s.prototype.containsPoint = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound;
                return e[0] <= t[0] && t[0] <= i[0] && e[1] <= t[1] && t[1] <= i[1]
            }, s.prototype.overlapsRay = function(t) {
                var e = 1 / t.direction[0],
                    i = 1 / t.direction[1],
                    s = (this.lowerBound[0] - t.from[0]) * e,
                    o = (this.upperBound[0] - t.from[0]) * e,
                    n = (this.lowerBound[1] - t.from[1]) * i,
                    a = (this.upperBound[1] - t.from[1]) * i,
                    r = Math.max(Math.max(Math.min(s, o), Math.min(n, a))),
                    h = Math.min(Math.min(Math.max(s, o), Math.max(n, a)));
                return h < 0 ? -1 : h < r ? -1 : r
            }
        }, { "../math/vec2": 30, "../utils/Utils": 57 }],
        8: [function(t, e, i) {
            var o = t("../math/vec2"),
                n = t("../objects/Body");

            function s(t) { this.type = t, this.result = [], this.world = null, this.boundingVolumeType = s.AABB }(e.exports = s).AABB = 1, s.BOUNDING_CIRCLE = 2, s.prototype.setWorld = function(t) { this.world = t }, s.prototype.getCollisionPairs = function(t) {};
            var a = o.create();
            s.boundingRadiusCheck = function(t, e) {
                o.sub(a, t.position, e.position);
                var i = o.squaredLength(a),
                    s = t.boundingRadius + e.boundingRadius;
                return i <= s * s
            }, s.aabbCheck = function(t, e) { return t.getAABB().overlaps(e.getAABB()) }, s.prototype.boundingVolumeCheck = function(t, e) {
                var i;
                switch (this.boundingVolumeType) {
                    case s.BOUNDING_CIRCLE:
                        i = s.boundingRadiusCheck(t, e);
                        break;
                    case s.AABB:
                        i = s.aabbCheck(t, e);
                        break;
                    default:
                        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                }
                return i
            }, s.canCollide = function(t, e) {
                var i = n.KINEMATIC,
                    s = n.STATIC;
                return (t.type !== s || e.type !== s) && (!(t.type === i && e.type === s || t.type === s && e.type === i) && ((t.type !== i || e.type !== i) && ((t.sleepState !== n.SLEEPING || e.sleepState !== n.SLEEPING) && !(t.sleepState === n.SLEEPING && e.type === s || e.sleepState === n.SLEEPING && t.type === s))))
            }, s.NAIVE = 1, s.SAP = 2
        }, { "../math/vec2": 30, "../objects/Body": 31 }],
        9: [function(t, e, i) {
            t("../shapes/Circle"), t("../shapes/Plane"), t("../shapes/Shape"), t("../shapes/Particle");
            var h = t("../collision/Broadphase");
            t("../math/vec2");

            function s() { h.call(this, h.NAIVE) }(((e.exports = s).prototype = new h).constructor = s).prototype.getCollisionPairs = function(t) {
                for (var e = t.bodies, i = this.result, s = i.length = 0, o = e.length; s !== o; s++)
                    for (var n = e[s], a = 0; a < s; a++) {
                        var r = e[a];
                        h.canCollide(n, r) && this.boundingVolumeCheck(n, r) && i.push(n, r)
                    }
                return i
            }, s.prototype.aabbQuery = function(t, e, i) {
                i = i || [];
                for (var s = t.bodies, o = 0; o < s.length; o++) {
                    var n = s[o];
                    n.aabbNeedsUpdate && n.updateAABB(), n.aabb.overlaps(e) && i.push(n)
                }
                return i
            }
        }, { "../collision/Broadphase": 8, "../math/vec2": 30, "../shapes/Circle": 39, "../shapes/Particle": 43, "../shapes/Plane": 44, "../shapes/Shape": 45 }],
        10: [function(t, e, i) {
            var V = t("../math/vec2"),
                H = V.sub,
                z = V.add,
                X = V.dot,
                s = (t("../utils/Utils"), t("../utils/ContactEquationPool")),
                o = t("../utils/FrictionEquationPool"),
                n = t("../utils/TupleDictionary"),
                a = t("../equations/Equation"),
                r = (t("../equations/ContactEquation"), t("../equations/FrictionEquation"), t("../shapes/Circle")),
                h = t("../shapes/Convex"),
                l = t("../shapes/Shape"),
                _ = (t("../objects/Body"), t("../shapes/Box"));
            e.exports = $;
            var T = V.fromValues(0, 1),
                j = V.fromValues(0, 0),
                W = V.fromValues(0, 0),
                q = V.fromValues(0, 0),
                Y = V.fromValues(0, 0),
                K = V.fromValues(0, 0),
                L = V.fromValues(0, 0),
                Q = V.fromValues(0, 0),
                J = V.fromValues(0, 0),
                Z = V.fromValues(0, 0),
                R = V.fromValues(0, 0),
                D = V.fromValues(0, 0),
                F = V.fromValues(0, 0),
                U = V.fromValues(0, 0),
                G = V.fromValues(0, 0),
                I = V.fromValues(0, 0),
                E = V.fromValues(0, 0),
                A = V.fromValues(0, 0),
                C = V.fromValues(0, 0),
                N = [];

            function $() { this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = .3, this.surfaceVelocity = 0, this.contactEquationPool = new s({ size: 32 }), this.frictionEquationPool = new o({ size: 64 }), this.restitution = 0, this.stiffness = a.DEFAULT_STIFFNESS, this.relaxation = a.DEFAULT_RELAXATION, this.frictionStiffness = a.DEFAULT_STIFFNESS, this.frictionRelaxation = a.DEFAULT_RELAXATION, this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new n, this.contactSkinSize = .01 }
            var c = V.create(),
                p = V.create();

            function x(t, e) { V.set(t.vertices[0], .5 * -e.length, -e.radius), V.set(t.vertices[1], .5 * e.length, -e.radius), V.set(t.vertices[2], .5 * e.length, e.radius), V.set(t.vertices[3], .5 * -e.length, e.radius) } $.prototype.bodiesOverlap = function(t, e) {
                for (var i = c, s = p, o = 0, n = t.shapes.length; o !== n; o++) {
                    var a = t.shapes[o];
                    t.toWorldFrame(i, a.position);
                    for (var r = 0, h = e.shapes.length; r !== h; r++) { var l = e.shapes[r]; if (e.toWorldFrame(s, l.position), this[a.type | l.type](t, a, i, a.angle + t.angle, e, l, s, l.angle + e.angle, !0)) return !0 }
                }
                return !1
            }, $.prototype.collidedLastStep = function(t, e) {
                var i = 0 | t.id,
                    s = 0 | e.id;
                return !!this.collidingBodiesLastStep.get(i, s)
            }, $.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                for (var t = this.contactEquations, e = t.length; e--;) {
                    var i = t[e],
                        s = i.bodyA.id,
                        o = i.bodyB.id;
                    this.collidingBodiesLastStep.set(s, o, !0)
                }
                for (var n = this.contactEquations, a = this.frictionEquations, r = 0; r < n.length; r++) this.contactEquationPool.release(n[r]);
                for (r = 0; r < a.length; r++) this.frictionEquationPool.release(a[r]);
                this.contactEquations.length = this.frictionEquations.length = 0
            }, $.prototype.createContactEquation = function(t, e, i, s) { var o = this.contactEquationPool.get(); return o.bodyA = t, o.bodyB = e, o.shapeA = i, o.shapeB = s, o.restitution = this.restitution, o.firstImpact = !this.collidedLastStep(t, e), o.stiffness = this.stiffness, o.relaxation = this.relaxation, o.needsUpdate = !0, o.enabled = this.enabledEquations, o.offset = this.contactSkinSize, o }, $.prototype.createFrictionEquation = function(t, e, i, s) { var o = this.frictionEquationPool.get(); return o.bodyA = t, o.bodyB = e, o.shapeA = i, o.shapeB = s, o.setSlipForce(this.slipForce), o.frictionCoefficient = this.frictionCoefficient, o.relativeVelocity = this.surfaceVelocity, o.enabled = this.enabledEquations, o.needsUpdate = !0, o.stiffness = this.frictionStiffness, o.relaxation = this.frictionRelaxation, o.contactEquations.length = 0, o }, $.prototype.createFrictionFromContact = function(t) { var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB); return V.copy(e.contactPointA, t.contactPointA), V.copy(e.contactPointB, t.contactPointB), V.rotate90cw(e.t, t.normalA), e.contactEquations.push(t), e }, $.prototype.createFrictionFromAverage = function(t) {
                var e = this.contactEquations[this.contactEquations.length - 1],
                    i = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB),
                    s = e.bodyA;
                e.bodyB;
                V.set(i.contactPointA, 0, 0), V.set(i.contactPointB, 0, 0), V.set(i.t, 0, 0);
                for (var o = 0; o !== t; o++)(e = this.contactEquations[this.contactEquations.length - 1 - o]).bodyA === s ? (V.add(i.t, i.t, e.normalA), V.add(i.contactPointA, i.contactPointA, e.contactPointA), V.add(i.contactPointB, i.contactPointB, e.contactPointB)) : (V.sub(i.t, i.t, e.normalA), V.add(i.contactPointA, i.contactPointA, e.contactPointB), V.add(i.contactPointB, i.contactPointB, e.contactPointA)), i.contactEquations.push(e);
                var n = 1 / t;
                return V.scale(i.contactPointA, i.contactPointA, n), V.scale(i.contactPointB, i.contactPointB, n), V.normalize(i.t, i.t), V.rotate90cw(i.t, i.t), i
            }, $.prototype[l.LINE | l.CONVEX] = $.prototype.convexLine = function(t, e, i, s, o, n, a, r, h) { return !h && 0 }, $.prototype[l.LINE | l.BOX] = $.prototype.lineBox = function(t, e, i, s, o, n, a, r, h) { return !h && 0 };
            var d = new _({ width: 1, height: 1 }),
                y = V.create();
            $.prototype[l.CAPSULE | l.CONVEX] = $.prototype[l.CAPSULE | l.BOX] = $.prototype.convexCapsule = function(t, e, i, s, o, n, a, r, h) {
                var l = y;
                V.set(l, n.length / 2, 0), V.rotate(l, l, r), V.add(l, l, a);
                var c = this.circleConvex(o, n, l, r, t, e, i, s, h, n.radius);
                V.set(l, -n.length / 2, 0), V.rotate(l, l, r), V.add(l, l, a);
                var p = this.circleConvex(o, n, l, r, t, e, i, s, h, n.radius);
                if (h && (c || p)) return !0;
                var u = d;
                return x(u, n), this.convexConvex(t, e, i, s, o, u, a, r, h) + c + p
            }, $.prototype[l.CAPSULE | l.LINE] = $.prototype.lineCapsule = function(t, e, i, s, o, n, a, r, h) { return !h && 0 };
            var b = V.create(),
                w = V.create(),
                P = new _({ width: 1, height: 1 });
            $.prototype[l.CAPSULE | l.CAPSULE] = $.prototype.capsuleCapsule = function(t, e, i, s, o, n, a, r, h) {
                for (var l = b, c = w, p = 0, u = 0; u < 2; u++) {
                    V.set(l, (0 === u ? -1 : 1) * e.length / 2, 0), V.rotate(l, l, s), V.add(l, l, i);
                    for (var d = 0; d < 2; d++) {
                        V.set(c, (0 === d ? -1 : 1) * n.length / 2, 0), V.rotate(c, c, r), V.add(c, c, a), this.enableFrictionReduction && (m = this.enableFriction, this.enableFriction = !1);
                        var y = this.circleCircle(t, e, l, s, o, n, c, r, h, e.radius, n.radius);
                        if (this.enableFrictionReduction && (this.enableFriction = m), h && y) return !0;
                        p += y
                    }
                }
                this.enableFrictionReduction && (m = this.enableFriction, this.enableFriction = !1);
                var g = P;
                x(g, e);
                var f = this.convexCapsule(t, g, i, s, o, n, a, r, h);
                if (this.enableFrictionReduction && (this.enableFriction = m), h && f) return !0;
                if (p += f, this.enableFrictionReduction) {
                    var m = this.enableFriction;
                    this.enableFriction = !1
                }
                x(g, n);
                var v = this.convexCapsule(o, g, a, r, t, e, i, s, h);
                return this.enableFrictionReduction && (this.enableFriction = m), !(!h || !v) || (p += v, this.enableFrictionReduction && p && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(p)), p)
            }, $.prototype[l.LINE | l.LINE] = $.prototype.lineLine = function(t, e, i, s, o, n, a, r, h) { return !h && 0 }, $.prototype[l.PLANE | l.LINE] = $.prototype.planeLine = function(t, e, i, s, o, n, a, r, h) {
                var l = j,
                    c = W,
                    p = q,
                    u = Y,
                    d = K,
                    y = L,
                    g = Q,
                    f = J,
                    m = Z,
                    v = N,
                    x = 0;
                V.set(l, -n.length / 2, 0), V.set(c, n.length / 2, 0), V.rotate(p, l, r), V.rotate(u, c, r), z(p, p, a), z(u, u, a), V.copy(l, p), V.copy(c, u), H(d, c, l), V.normalize(y, d), V.rotate90cw(m, y), V.rotate(f, T, s), v[0] = l, v[1] = c;
                for (var b = 0; b < v.length; b++) {
                    var w = v[b];
                    H(g, w, i);
                    var P = X(g, f);
                    if (P < 0) {
                        if (h) return !0;
                        var _ = this.createContactEquation(t, o, e, n);
                        x++, V.copy(_.normalA, f), V.normalize(_.normalA, _.normalA), V.scale(g, f, P), H(_.contactPointA, w, g), H(_.contactPointA, _.contactPointA, t.position), H(_.contactPointB, w, a), z(_.contactPointB, _.contactPointB, a), H(_.contactPointB, _.contactPointB, o.position), this.contactEquations.push(_), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(_))
                    }
                }
                return !h && (this.enableFrictionReduction || x && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(x)), x)
            }, $.prototype[l.PARTICLE | l.CAPSULE] = $.prototype.particleCapsule = function(t, e, i, s, o, n, a, r, h) { return this.circleLine(t, e, i, s, o, n, a, r, h, n.radius, 0) }, $.prototype[l.CIRCLE | l.LINE] = $.prototype.circleLine = function(t, e, i, s, o, n, a, r, h, l, c) {
                l = l || 0, c = void 0 !== c ? c : e.radius;
                var p = j,
                    u = W,
                    d = q,
                    y = Y,
                    g = K,
                    f = L,
                    m = Q,
                    v = J,
                    x = Z,
                    b = R,
                    w = D,
                    P = F,
                    _ = U,
                    T = G,
                    S = N;
                V.set(v, -n.length / 2, 0), V.set(x, n.length / 2, 0), V.rotate(b, v, r), V.rotate(w, x, r), z(b, b, a), z(w, w, a), V.copy(v, b), V.copy(x, w), H(f, x, v), V.normalize(m, f), V.rotate90cw(g, m), H(P, i, v);
                var k = X(P, g);
                H(y, v, a), H(_, i, a);
                var B = c + l;
                if (Math.abs(k) < B) {
                    V.scale(p, g, k), H(d, i, p), V.scale(u, g, X(g, _)), V.normalize(u, u), V.scale(u, u, l), z(d, d, u);
                    var A = X(m, d),
                        C = X(m, v),
                        I = X(m, x);
                    if (C < A && A < I) { if (h) return !0; var E = this.createContactEquation(t, o, e, n); return V.scale(E.normalA, p, -1), V.normalize(E.normalA, E.normalA), V.scale(E.contactPointA, E.normalA, c), z(E.contactPointA, E.contactPointA, i), H(E.contactPointA, E.contactPointA, t.position), H(E.contactPointB, d, a), z(E.contactPointB, E.contactPointB, a), H(E.contactPointB, E.contactPointB, o.position), this.contactEquations.push(E), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(E)), 1 }
                }
                S[0] = v, S[1] = x;
                for (var O = 0; O < S.length; O++) {
                    var M = S[O];
                    if (H(P, M, i), V.squaredLength(P) < Math.pow(B, 2)) {
                        if (h) return !0;
                        E = this.createContactEquation(t, o, e, n);
                        return V.copy(E.normalA, P), V.normalize(E.normalA, E.normalA), V.scale(E.contactPointA, E.normalA, c), z(E.contactPointA, E.contactPointA, i), H(E.contactPointA, E.contactPointA, t.position), H(E.contactPointB, M, a), V.scale(T, E.normalA, -l), z(E.contactPointB, E.contactPointB, T), z(E.contactPointB, E.contactPointB, a), H(E.contactPointB, E.contactPointB, o.position), this.contactEquations.push(E), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(E)), 1
                    }
                }
                return 0
            }, $.prototype[l.CIRCLE | l.CAPSULE] = $.prototype.circleCapsule = function(t, e, i, s, o, n, a, r, h) { return this.circleLine(t, e, i, s, o, n, a, r, h, n.radius) }, $.prototype[l.CIRCLE | l.CONVEX] = $.prototype[l.CIRCLE | l.BOX] = $.prototype.circleConvex = function(t, e, i, s, o, n, a, r, h, l) {
                l = "number" == typeof l ? l : e.radius;
                for (var c = j, p = W, u = q, d = Y, y = K, g = R, f = D, m = U, v = G, x = I, b = E, w = !1, P = Number.MAX_VALUE, _ = n.vertices, T = 0; T !== _.length + 1; T++) {
                    var S = _[T % _.length],
                        k = _[(T + 1) % _.length];
                    if (V.rotate(c, S, r), V.rotate(p, k, r), z(c, c, a), z(p, p, a), H(u, p, c), V.normalize(d, u), V.rotate90cw(y, d), V.scale(v, y, -e.radius), z(v, v, i), O(v, n, a, r)) {
                        V.sub(x, c, v);
                        var B = Math.abs(V.dot(x, y));
                        B < P && (V.copy(b, v), P = B, V.scale(m, y, B), V.add(m, m, v), w = !0)
                    }
                }
                if (w) { if (h) return !0; var A = this.createContactEquation(t, o, e, n); return V.sub(A.normalA, b, i), V.normalize(A.normalA, A.normalA), V.scale(A.contactPointA, A.normalA, l), z(A.contactPointA, A.contactPointA, i), H(A.contactPointA, A.contactPointA, t.position), H(A.contactPointB, m, a), z(A.contactPointB, A.contactPointB, a), H(A.contactPointB, A.contactPointB, o.position), this.contactEquations.push(A), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)), 1 }
                if (0 < l)
                    for (T = 0; T < _.length; T++) {
                        var C = _[T];
                        if (V.rotate(f, C, r), z(f, f, a), H(g, f, i), V.squaredLength(g) < Math.pow(l, 2)) {
                            if (h) return !0;
                            A = this.createContactEquation(t, o, e, n);
                            return V.copy(A.normalA, g), V.normalize(A.normalA, A.normalA), V.scale(A.contactPointA, A.normalA, l), z(A.contactPointA, A.contactPointA, i), H(A.contactPointA, A.contactPointA, t.position), H(A.contactPointB, f, a), z(A.contactPointB, A.contactPointB, a), H(A.contactPointB, A.contactPointB, o.position), this.contactEquations.push(A), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)), 1
                        }
                    }
                return 0
            };
            var g = V.create(),
                f = V.create(),
                m = V.create(),
                v = V.create();

            function O(t, e, i, s) {
                for (var o = g, n = f, a = m, r = v, h = t, l = e.vertices, c = null, p = 0; p !== l.length + 1; p++) {
                    var u = l[p % l.length],
                        d = l[(p + 1) % l.length];
                    V.rotate(o, u, s), V.rotate(n, d, s), z(o, o, i), z(n, n, i), H(a, o, h), H(r, n, h);
                    var y = V.crossLength(a, r);
                    if (null === c && (c = y), y * c <= 0) return !1;
                    c = y
                }
                return !0
            }
            $.prototype[l.PARTICLE | l.CONVEX] = $.prototype[l.PARTICLE | l.BOX] = $.prototype.particleConvex = function(t, e, i, s, o, n, a, r, h) {
                var l = j,
                    c = W,
                    p = q,
                    u = Y,
                    d = K,
                    y = L,
                    g = Q,
                    f = R,
                    m = U,
                    v = A,
                    x = C,
                    b = Number.MAX_VALUE,
                    w = !1,
                    P = n.vertices;
                if (!O(i, n, a, r)) return 0;
                if (h) return !0;
                for (var _ = 0; _ !== P.length + 1; _++) {
                    var T = P[_ % P.length],
                        S = P[(_ + 1) % P.length];
                    V.rotate(l, T, r), V.rotate(c, S, r), z(l, l, a), z(c, c, a), H(p, c, l), V.normalize(u, p), V.rotate90cw(d, u), H(f, i, l);
                    X(f, d);
                    H(y, l, a), H(g, i, a), V.sub(v, l, i);
                    var k = Math.abs(V.dot(v, d));
                    k < b && (b = k, V.scale(m, d, k), V.add(m, m, i), V.copy(x, d), w = !0)
                }
                if (w) { var B = this.createContactEquation(t, o, e, n); return V.scale(B.normalA, x, -1), V.normalize(B.normalA, B.normalA), V.set(B.contactPointA, 0, 0), z(B.contactPointA, B.contactPointA, i), H(B.contactPointA, B.contactPointA, t.position), H(B.contactPointB, m, a), z(B.contactPointB, B.contactPointB, a), H(B.contactPointB, B.contactPointB, o.position), this.contactEquations.push(B), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(B)), 1 }
                return 0
            }, $.prototype[l.CIRCLE] = $.prototype.circleCircle = function(t, e, i, s, o, n, a, r, h, l, c) {
                var p = j;
                l = l || e.radius, c = c || n.radius;
                H(p, i, a);
                var u = l + c;
                if (V.squaredLength(p) > Math.pow(u, 2)) return 0;
                if (h) return !0;
                var d = this.createContactEquation(t, o, e, n);
                return H(d.normalA, a, i), V.normalize(d.normalA, d.normalA), V.scale(d.contactPointA, d.normalA, l), V.scale(d.contactPointB, d.normalA, -c), z(d.contactPointA, d.contactPointA, i), H(d.contactPointA, d.contactPointA, t.position), z(d.contactPointB, d.contactPointB, a), H(d.contactPointB, d.contactPointB, o.position), this.contactEquations.push(d), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(d)), 1
            }, $.prototype[l.PLANE | l.CONVEX] = $.prototype[l.PLANE | l.BOX] = $.prototype.planeConvex = function(t, e, i, s, o, n, a, r, h) {
                var l = j,
                    c = W,
                    p = q,
                    u = 0;
                V.rotate(c, T, s);
                for (var d = 0; d !== n.vertices.length; d++) {
                    var y = n.vertices[d];
                    if (V.rotate(l, y, r), z(l, l, a), H(p, l, i), X(p, c) <= 0) {
                        if (h) return !0;
                        u++;
                        var g = this.createContactEquation(t, o, e, n);
                        H(p, l, i), V.copy(g.normalA, c);
                        var f = X(p, g.normalA);
                        V.scale(p, g.normalA, f), H(g.contactPointB, l, o.position), H(g.contactPointA, l, p), H(g.contactPointA, g.contactPointA, t.position), this.contactEquations.push(g), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(g))
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && u && this.frictionEquations.push(this.createFrictionFromAverage(u)), u
            }, $.prototype[l.PARTICLE | l.PLANE] = $.prototype.particlePlane = function(t, e, i, s, o, n, a, r, h) {
                var l = j,
                    c = W;
                r = r || 0, H(l, i, a), V.rotate(c, T, r);
                var p = X(l, c);
                if (0 < p) return 0;
                if (h) return !0;
                var u = this.createContactEquation(o, t, n, e);
                return V.copy(u.normalA, c), V.scale(l, u.normalA, p), H(u.contactPointA, i, l), H(u.contactPointA, u.contactPointA, o.position), H(u.contactPointB, i, t.position), this.contactEquations.push(u), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(u)), 1
            }, $.prototype[l.CIRCLE | l.PARTICLE] = $.prototype.circleParticle = function(t, e, i, s, o, n, a, r, h) { var l = j; if (H(l, a, i), V.squaredLength(l) > Math.pow(e.radius, 2)) return 0; if (h) return !0; var c = this.createContactEquation(t, o, e, n); return V.copy(c.normalA, l), V.normalize(c.normalA, c.normalA), V.scale(c.contactPointA, c.normalA, e.radius), z(c.contactPointA, c.contactPointA, i), H(c.contactPointA, c.contactPointA, t.position), H(c.contactPointB, a, o.position), this.contactEquations.push(c), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(c)), 1 };
            var S = new r({ radius: 1 }),
                k = V.create(),
                B = V.create();
            V.create();
            $.prototype[l.PLANE | l.CAPSULE] = $.prototype.planeCapsule = function(t, e, i, s, o, n, a, r, h) {
                var l, c = k,
                    p = B,
                    u = S;
                V.set(c, -n.length / 2, 0), V.rotate(c, c, r), z(c, c, a), V.set(p, n.length / 2, 0), V.rotate(p, p, r), z(p, p, a), u.radius = n.radius, this.enableFrictionReduction && (l = this.enableFriction, this.enableFriction = !1);
                var d = this.circlePlane(o, u, c, 0, t, e, i, s, h),
                    y = this.circlePlane(o, u, p, 0, t, e, i, s, h);
                if (this.enableFrictionReduction && (this.enableFriction = l), h) return d || y;
                var g = d + y;
                return this.enableFrictionReduction && g && this.frictionEquations.push(this.createFrictionFromAverage(g)), g
            }, $.prototype[l.CIRCLE | l.PLANE] = $.prototype.circlePlane = function(t, e, i, s, o, n, a, r, h) {
                var l = t,
                    c = e,
                    p = i,
                    u = o,
                    d = a,
                    y = r;
                y = y || 0;
                var g = j,
                    f = W,
                    m = q;
                H(g, p, d), V.rotate(f, T, y);
                var v = X(f, g);
                if (v > c.radius) return 0;
                if (h) return !0;
                var x = this.createContactEquation(u, l, n, e);
                return V.copy(x.normalA, f), V.scale(x.contactPointB, x.normalA, -c.radius), z(x.contactPointB, x.contactPointB, p), H(x.contactPointB, x.contactPointB, l.position), V.scale(m, x.normalA, v), H(x.contactPointA, g, m), z(x.contactPointA, x.contactPointA, d), H(x.contactPointA, x.contactPointA, u.position), this.contactEquations.push(x), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(x)), 1
            }, $.prototype[l.CONVEX] = $.prototype[l.CONVEX | l.BOX] = $.prototype[l.BOX] = $.prototype.convexConvex = function(t, e, i, s, o, n, a, r, h, l) {
                var c = j,
                    p = W,
                    u = q,
                    d = Y,
                    y = K,
                    g = Q,
                    f = J,
                    m = Z,
                    v = 0;
                l = "number" == typeof l ? l : 0;
                if (!$.findSeparatingAxis(e, i, s, n, a, r, c)) return 0;
                H(f, a, i), 0 < X(c, f) && V.scale(c, c, -1);
                var x = $.getClosestEdge(e, s, c, !0),
                    b = $.getClosestEdge(n, r, c);
                if (-1 === x || -1 === b) return 0;
                for (var w = 0; w < 2; w++) {
                    var P, _ = x,
                        T = b,
                        S = e,
                        k = n,
                        B = i,
                        A = a,
                        C = s,
                        I = r,
                        E = t,
                        O = o;
                    if (0 === w) P = _, _ = T, T = P, P = S, S = k, k = P, P = B, B = A, A = P, P = C, C = I, I = P, P = E, E = O, O = P;
                    for (var M = T; M < T + 2; M++) {
                        var L = k.vertices[(M + k.vertices.length) % k.vertices.length];
                        V.rotate(p, L, I), z(p, p, A);
                        for (var R = 0, D = _ - 1; D < _ + 2; D++) {
                            var F = S.vertices[(D + S.vertices.length) % S.vertices.length],
                                U = S.vertices[(D + 1 + S.vertices.length) % S.vertices.length];
                            V.rotate(u, F, C), V.rotate(d, U, C), z(u, u, B), z(d, d, B), H(y, d, u), V.rotate90cw(m, y), V.normalize(m, m), H(f, p, u);
                            var G = X(m, f);
                            (D === _ && G <= l || D !== _ && G <= 0) && R++
                        }
                        if (3 <= R) {
                            if (h) return !0;
                            var N = this.createContactEquation(E, O, S, k);
                            v++;
                            F = S.vertices[_ % S.vertices.length], U = S.vertices[(_ + 1) % S.vertices.length];
                            V.rotate(u, F, C), V.rotate(d, U, C), z(u, u, B), z(d, d, B), H(y, d, u), V.rotate90cw(N.normalA, y), V.normalize(N.normalA, N.normalA), H(f, p, u);
                            G = X(N.normalA, f);
                            V.scale(g, N.normalA, G), H(N.contactPointA, p, B), H(N.contactPointA, N.contactPointA, g), z(N.contactPointA, N.contactPointA, B), H(N.contactPointA, N.contactPointA, E.position), H(N.contactPointB, p, A), z(N.contactPointB, N.contactPointB, A), H(N.contactPointB, N.contactPointB, O.position), this.contactEquations.push(N), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(N))
                        }
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && v && this.frictionEquations.push(this.createFrictionFromAverage(v)), v
            };
            var M = V.fromValues(0, 0);
            $.projectConvexOntoAxis = function(t, e, i, s, o) {
                var n, a, r = null,
                    h = null,
                    l = M;
                V.rotate(l, s, -i);
                for (var c = 0; c < t.vertices.length; c++) n = t.vertices[c], a = X(n, l), (null === r || r < a) && (r = a), (null === h || a < h) && (h = a);
                if (r < h) {
                    var p = h;
                    h = r, r = p
                }
                var u = X(e, s);
                V.set(o, h + u, r + u)
            };
            var tt = V.fromValues(0, 0),
                et = V.fromValues(0, 0),
                it = V.fromValues(0, 0),
                st = V.fromValues(0, 0),
                ot = V.fromValues(0, 0),
                nt = V.fromValues(0, 0);
            $.findSeparatingAxis = function(t, e, i, s, o, n, a) {
                var r = null,
                    h = !1,
                    l = !1,
                    c = tt,
                    p = et,
                    u = it,
                    d = st,
                    y = ot,
                    g = nt;
                if (t instanceof _ && s instanceof _)
                    for (var f = 0; 2 !== f; f++) {
                        var m = t,
                            v = i;
                        1 === f && (m = s, v = n);
                        for (var x = 0; 2 !== x; x++) {
                            0 === x ? V.set(d, 0, 1) : 1 === x && V.set(d, 1, 0), 0 !== v && V.rotate(d, d, v), $.projectConvexOntoAxis(t, e, i, d, y), $.projectConvexOntoAxis(s, o, n, d, g);
                            var b = y,
                                w = g;
                            y[0] > g[0] && (w = y, b = g, !0), h = (P = w[0] - b[1]) <= 0, (null === r || r < P) && (V.copy(a, d), r = P, l = h)
                        }
                    }
                else
                    for (f = 0; 2 !== f; f++) {
                        m = t, v = i;
                        1 === f && (m = s, v = n);
                        for (x = 0; x !== m.vertices.length; x++) {
                            V.rotate(p, m.vertices[x], v), V.rotate(u, m.vertices[(x + 1) % m.vertices.length], v), H(c, u, p), V.rotate90cw(d, c), V.normalize(d, d), $.projectConvexOntoAxis(t, e, i, d, y), $.projectConvexOntoAxis(s, o, n, d, g);
                            var P;
                            b = y, w = g;
                            y[0] > g[0] && (w = y, b = g, !0), h = (P = w[0] - b[1]) <= 0, (null === r || r < P) && (V.copy(a, d), r = P, l = h)
                        }
                    }
                return l
            };
            var u = V.fromValues(0, 0),
                at = V.fromValues(0, 0),
                rt = V.fromValues(0, 0);
            $.getClosestEdge = function(t, e, i, s) {
                var o = u,
                    n = at,
                    a = rt;
                V.rotate(o, i, -e), s && V.scale(o, o, -1);
                for (var r = -1, h = t.vertices.length, l = -1, c = 0; c !== h; c++) {
                    H(n, t.vertices[(c + 1) % h], t.vertices[c % h]), V.rotate90cw(a, n), V.normalize(a, a);
                    var p = X(a, o);
                    (-1 === r || l < p) && (r = c % h, l = p)
                }
                return r
            };
            var ht = V.create(),
                lt = V.create(),
                ct = V.create(),
                pt = V.create(),
                ut = V.create(),
                dt = V.create(),
                yt = V.create();
            $.prototype[l.CIRCLE | l.HEIGHTFIELD] = $.prototype.circleHeightfield = function(t, e, i, s, o, n, a, r, h, l) {
                var c = n.heights,
                    p = (l = l || e.radius, n.elementWidth),
                    u = lt,
                    d = ht,
                    y = ut,
                    g = yt,
                    f = dt,
                    m = ct,
                    v = pt,
                    x = Math.floor((i[0] - l - a[0]) / p),
                    b = Math.ceil((i[0] + l - a[0]) / p);
                x < 0 && (x = 0), b >= c.length && (b = c.length - 1);
                for (var w = c[x], P = c[b], _ = x; _ < b; _++) c[_] < P && (P = c[_]), c[_] > w && (w = c[_]);
                if (i[1] - l > w) return !h && 0;
                var T = !1;
                for (_ = x; _ < b; _++) {
                    V.set(m, _ * p, c[_]), V.set(v, (_ + 1) * p, c[_ + 1]), V.add(m, m, a), V.add(v, v, a), V.sub(f, v, m), V.rotate(f, f, Math.PI / 2), V.normalize(f, f), V.scale(d, f, -l), V.add(d, d, i), V.sub(u, d, m);
                    var S = V.dot(u, f);
                    if (d[0] >= m[0] && d[0] < v[0] && S <= 0) {
                        if (h) return !0;
                        T = !0, V.scale(u, f, -S), V.add(y, d, u), V.copy(g, f);
                        var k = this.createContactEquation(o, t, n, e);
                        V.copy(k.normalA, g), V.scale(k.contactPointB, k.normalA, -l), z(k.contactPointB, k.contactPointB, i), H(k.contactPointB, k.contactPointB, t.position), V.copy(k.contactPointA, y), V.sub(k.contactPointA, k.contactPointA, o.position), this.contactEquations.push(k), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(k))
                    }
                }
                if (T = !1, 0 < l)
                    for (_ = x; _ <= b; _++)
                        if (V.set(m, _ * p, c[_]), V.add(m, m, a), V.sub(u, i, m), V.squaredLength(u) < Math.pow(l, 2)) {
                            if (h) return !0;
                            T = !0;
                            k = this.createContactEquation(o, t, n, e);
                            V.copy(k.normalA, u), V.normalize(k.normalA, k.normalA), V.scale(k.contactPointB, k.normalA, -l), z(k.contactPointB, k.contactPointB, i), H(k.contactPointB, k.contactPointB, t.position), H(k.contactPointA, m, a), z(k.contactPointA, k.contactPointA, a), H(k.contactPointA, k.contactPointA, o.position), this.contactEquations.push(k), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(k))
                        }
                return T ? 1 : 0
            };
            var gt = V.create(),
                ft = V.create(),
                mt = V.create(),
                vt = new h({ vertices: [V.create(), V.create(), V.create(), V.create()] });
            $.prototype[l.BOX | l.HEIGHTFIELD] = $.prototype[l.CONVEX | l.HEIGHTFIELD] = $.prototype.convexHeightfield = function(t, e, i, s, o, n, a, r, h) {
                var l = n.heights,
                    c = n.elementWidth,
                    p = gt,
                    u = ft,
                    d = mt,
                    y = vt,
                    g = Math.floor((t.aabb.lowerBound[0] - a[0]) / c),
                    f = Math.ceil((t.aabb.upperBound[0] - a[0]) / c);
                g < 0 && (g = 0), f >= l.length && (f = l.length - 1);
                for (var m = l[g], v = l[f], x = g; x < f; x++) l[x] < v && (v = l[x]), l[x] > m && (m = l[x]);
                if (t.aabb.lowerBound[1] > m) return !h && 0;
                var b = 0;
                for (x = g; x < f; x++) {
                    V.set(p, x * c, l[x]), V.set(u, (x + 1) * c, l[x + 1]), V.add(p, p, a), V.add(u, u, a);
                    V.set(d, .5 * (u[0] + p[0]), .5 * (u[1] + p[1] - 100)), V.sub(y.vertices[0], u, d), V.sub(y.vertices[1], p, d), V.copy(y.vertices[2], y.vertices[1]), V.copy(y.vertices[3], y.vertices[0]), y.vertices[2][1] -= 100, y.vertices[3][1] -= 100, b += this.convexConvex(t, e, i, s, o, y, d, 0, h)
                }
                return b
            }
        }, { "../equations/ContactEquation": 21, "../equations/Equation": 22, "../equations/FrictionEquation": 23, "../math/vec2": 30, "../objects/Body": 31, "../shapes/Box": 37, "../shapes/Circle": 39, "../shapes/Convex": 40, "../shapes/Shape": 45, "../utils/ContactEquationPool": 48, "../utils/FrictionEquationPool": 49, "../utils/TupleDictionary": 56, "../utils/Utils": 57 }],
        11: [function(t, e, i) {
            e.exports = a;
            var h = t("../math/vec2");
            t("../collision/RaycastResult"), t("../shapes/Shape"), t("../collision/AABB");

            function a(t) { t = t || {}, this.from = t.from ? h.fromValues(t.from[0], t.from[1]) : h.create(), this.to = t.to ? h.fromValues(t.to[0], t.to[1]) : h.create(), this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse, this.skipBackfaces = !!t.skipBackfaces, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : -1, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : -1, this.mode = void 0 !== t.mode ? t.mode : a.ANY, this.callback = t.callback || function(t) {}, this.direction = h.create(), this.length = 1, this.update() }(a.prototype.constructor = a).CLOSEST = 1, a.ANY = 2, a.ALL = 4, a.prototype.update = function() {
                var t = this.direction;
                h.sub(t, this.to, this.from), this.length = h.length(t), h.normalize(t, t)
            }, a.prototype.intersectBodies = function(t, e) {
                for (var i = 0, s = e.length; !t.shouldStop(this) && i < s; i++) {
                    var o = e[i],
                        n = o.getAABB();
                    (0 <= n.overlapsRay(this) || n.containsPoint(this.from)) && this.intersectBody(t, o)
                }
            };
            var l = h.create();
            a.prototype.intersectBody = function(t, e) {
                var i = this.checkCollisionResponse;
                if (!i || e.collisionResponse)
                    for (var s = l, o = 0, n = e.shapes.length; o < n; o++) { var a = e.shapes[o]; if ((!i || a.collisionResponse) && (0 != (this.collisionGroup & a.collisionMask) && 0 != (a.collisionGroup & this.collisionMask))) { h.rotate(s, a.position, e.angle), h.add(s, s, e.position); var r = a.angle + e.angle; if (this.intersectShape(t, a, r, s, e), t.shouldStop(this)) break } }
            }, a.prototype.intersectShape = function(t, e, i, s, o) {
                (function(t, e, i) { h.sub(n, i, t); var s = h.dot(n, e); return h.scale(r, e, s), h.add(r, r, t), h.squaredDistance(i, r) })(this.from, this.direction, s) > e.boundingRadius * e.boundingRadius || (this._currentBody = o, (this._currentShape = e).raycast(t, this, s, i), this._currentBody = this._currentShape = null)
            }, a.prototype.getAABB = function(t) {
                var e = this.to,
                    i = this.from;
                h.set(t.lowerBound, Math.min(e[0], i[0]), Math.min(e[1], i[1])), h.set(t.upperBound, Math.max(e[0], i[0]), Math.max(e[1], i[1]))
            };
            h.create();
            a.prototype.reportIntersection = function(t, e, i, s) {
                this.from, this.to;
                var o = this._currentShape,
                    n = this._currentBody;
                if (!(this.skipBackfaces && 0 < h.dot(i, this.direction))) switch (this.mode) {
                    case a.ALL:
                        t.set(i, o, n, e, s), this.callback(t);
                        break;
                    case a.CLOSEST:
                        (e < t.fraction || !t.hasHit()) && t.set(i, o, n, e, s);
                        break;
                    case a.ANY:
                        t.set(i, o, n, e, s)
                }
            };
            var n = h.create(),
                r = h.create()
        }, { "../collision/AABB": 7, "../collision/RaycastResult": 12, "../math/vec2": 30, "../shapes/Shape": 45 }],
        12: [function(t, e, i) {
            var n = t("../math/vec2"),
                s = t("../collision/Ray");

            function o() { this.normal = n.create(), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1 }(e.exports = o).prototype.reset = function() { n.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1 }, o.prototype.getHitDistance = function(t) { return n.distance(t.from, t.to) * this.fraction }, o.prototype.hasHit = function() { return -1 !== this.fraction }, o.prototype.getHitPoint = function(t, e) { n.lerp(t, e.from, e.to, this.fraction) }, o.prototype.stop = function() { this.isStopped = !0 }, o.prototype.shouldStop = function(t) { return this.isStopped || -1 !== this.fraction && t.mode === s.ANY }, o.prototype.set = function(t, e, i, s, o) { n.copy(this.normal, t), this.shape = e, this.body = i, this.fraction = s, this.faceIndex = o }
        }, { "../collision/Ray": 11, "../math/vec2": 30 }],
        13: [function(t, e, i) {
            var s = t("../utils/Utils"),
                p = t("../collision/Broadphase");

            function o() {
                p.call(this, p.SAP), this.axisList = [], this.axisIndex = 0;
                var i = this;
                this._addBodyHandler = function(t) { i.axisList.push(t.body) }, this._removeBodyHandler = function(t) { var e = i.axisList.indexOf(t.body); - 1 !== e && i.axisList.splice(e, 1) }
            }(((e.exports = o).prototype = new p).constructor = o).prototype.setWorld = function(t) { this.axisList.length = 0, s.appendArray(this.axisList, t.bodies), t.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), t.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), this.world = t }, o.sortAxisList = function(t, e) {
                e |= 0;
                for (var i = 1, s = t.length; i < s; i++) {
                    for (var o = t[i], n = i - 1; 0 <= n && !(t[n].aabb.lowerBound[e] <= o.aabb.lowerBound[e]); n--) t[n + 1] = t[n];
                    t[n + 1] = o
                }
                return t
            }, o.prototype.sortList = function() {
                var t = this.axisList,
                    e = this.axisIndex;
                o.sortAxisList(t, e)
            }, o.prototype.getCollisionPairs = function(t) {
                var e = this.axisList,
                    i = this.result,
                    s = this.axisIndex;
                i.length = 0;
                for (var o = e.length; o--;) {
                    var n = e[o];
                    n.aabbNeedsUpdate && n.updateAABB()
                }
                this.sortList();
                for (var a = 0, r = 0 | e.length; a !== r; a++)
                    for (var h = e[a], l = a + 1; l < r; l++) {
                        var c = e[l];
                        if (!(c.aabb.lowerBound[s] <= h.aabb.upperBound[s])) break;
                        p.canCollide(h, c) && this.boundingVolumeCheck(h, c) && i.push(h, c)
                    }
                return i
            }, o.prototype.aabbQuery = function(t, e, i) {
                i = i || [], this.sortList();
                var s = this.axisIndex,
                    o = "x";
                1 === s && (o = "y"), 2 === s && (o = "z");
                for (var n = this.axisList, a = (e.lowerBound[o], e.upperBound[o], 0); a < n.length; a++) {
                    var r = n[a];
                    r.aabbNeedsUpdate && r.updateAABB(), r.aabb.overlaps(e) && i.push(r)
                }
                return i
            }
        }, { "../collision/Broadphase": 8, "../utils/Utils": 57 }],
        14: [function(t, e, i) {
            e.exports = s;
            var o = t("../utils/Utils");

            function s(t, e, i, s) { this.type = i, s = o.defaults(s, { collideConnected: !0, wakeUpBodies: !0 }), this.equations = [], this.bodyA = t, this.bodyB = e, this.collideConnected = s.collideConnected, s.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp()) } s.prototype.update = function() { throw new Error("method update() not implmemented in this Constraint subclass!") }, s.DISTANCE = 1, s.GEAR = 2, s.LOCK = 3, s.PRISMATIC = 4, s.REVOLUTE = 5, s.prototype.setStiffness = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var s = e[i];
                    s.stiffness = t, s.needsUpdate = !0
                }
            }, s.prototype.setRelaxation = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var s = e[i];
                    s.relaxation = t, s.needsUpdate = !0
                }
            }
        }, { "../utils/Utils": 57 }],
        15: [function(t, e, i) {
            var d = t("./Constraint"),
                y = t("../equations/Equation"),
                g = t("../math/vec2"),
                f = t("../utils/Utils");

            function s(t, e, i) {
                i = f.defaults(i, { localAnchorA: [0, 0], localAnchorB: [0, 0] }), d.call(this, t, e, d.DISTANCE, i), this.localAnchorA = g.fromValues(i.localAnchorA[0], i.localAnchorA[1]), this.localAnchorB = g.fromValues(i.localAnchorB[0], i.localAnchorB[1]);
                var s, o = this.localAnchorA,
                    n = this.localAnchorB;
                if (this.distance = 0, "number" == typeof i.distance) this.distance = i.distance;
                else {
                    var a = g.create(),
                        r = g.create(),
                        h = g.create();
                    g.rotate(a, o, t.angle), g.rotate(r, n, e.angle), g.add(h, e.position, r), g.sub(h, h, a), g.sub(h, h, t.position), this.distance = g.length(h)
                }
                s = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce;
                var l = new y(t, e, -s, s);
                this.equations = [l], this.maxForce = s;
                h = g.create();
                var c = g.create(),
                    p = g.create(),
                    u = this;
                l.computeGq = function() {
                    var t = this.bodyA,
                        e = this.bodyB,
                        i = t.position,
                        s = e.position;
                    return g.rotate(c, o, t.angle), g.rotate(p, n, e.angle), g.add(h, s, p), g.sub(h, h, c), g.sub(h, h, i), g.length(h) - u.distance
                }, this.setMaxForce(s), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, this.lowerLimit = 0, this.position = 0
            }((e.exports = s).prototype = new d).constructor = s;
            var c = g.create(),
                p = g.create(),
                u = g.create();
            s.prototype.update = function() {
                var t = this.equations[0],
                    e = this.bodyA,
                    i = this.bodyB,
                    s = (this.distance, e.position),
                    o = i.position,
                    n = this.equations[0],
                    a = t.G;
                g.rotate(p, this.localAnchorA, e.angle), g.rotate(u, this.localAnchorB, i.angle), g.add(c, o, u), g.sub(c, c, p), g.sub(c, c, s), this.position = g.length(c);
                var r = !1;
                if (this.upperLimitEnabled && this.position > this.upperLimit && (n.maxForce = 0, n.minForce = -this.maxForce, this.distance = this.upperLimit, r = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (n.maxForce = this.maxForce, n.minForce = 0, this.distance = this.lowerLimit, r = !0), !this.lowerLimitEnabled && !this.upperLimitEnabled || r) {
                    n.enabled = !0, g.normalize(c, c);
                    var h = g.crossLength(p, c),
                        l = g.crossLength(u, c);
                    a[0] = -c[0], a[1] = -c[1], a[2] = -h, a[3] = c[0], a[4] = c[1], a[5] = l
                }
                else n.enabled = !1
            }, s.prototype.setMaxForce = function(t) {
                var e = this.equations[0];
                e.minForce = -t, e.maxForce = t
            }, s.prototype.getMaxForce = function() { return this.equations[0].maxForce }
        }, { "../equations/Equation": 22, "../math/vec2": 30, "../utils/Utils": 57, "./Constraint": 14 }],
        16: [function(t, e, i) {
            var s = t("./Constraint"),
                o = (t("../equations/Equation"), t("../equations/AngleLockEquation"));
            t("../math/vec2");

            function n(t, e, i) { i = i || {}, s.call(this, t, e, s.GEAR, i), this.ratio = void 0 !== i.ratio ? i.ratio : 1, this.angle = void 0 !== i.angle ? i.angle : e.angle - this.ratio * t.angle, i.angle = this.angle, i.ratio = this.ratio, this.equations = [new o(t, e, i)], void 0 !== i.maxTorque && this.setMaxTorque(i.maxTorque) }(((e.exports = n).prototype = new s).constructor = n).prototype.update = function() {
                var t = this.equations[0];
                t.ratio !== this.ratio && t.setRatio(this.ratio), t.angle = this.angle
            }, n.prototype.setMaxTorque = function(t) { this.equations[0].setMaxTorque(t) }, n.prototype.getMaxTorque = function(t) { return this.equations[0].maxForce }
        }, { "../equations/AngleLockEquation": 20, "../equations/Equation": 22, "../math/vec2": 30, "./Constraint": 14 }],
        17: [function(t, e, i) {
            var u = t("./Constraint"),
                d = t("../math/vec2"),
                y = t("../equations/Equation");

            function s(t, e, i) {
                i = i || {}, u.call(this, t, e, u.LOCK, i);
                var s = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce,
                    o = (i.localAngleB, new y(t, e, -s, s)),
                    n = new y(t, e, -s, s),
                    a = new y(t, e, -s, s),
                    r = d.create(),
                    h = d.create(),
                    l = this;
                o.computeGq = function() { return d.rotate(r, l.localOffsetB, t.angle), d.sub(h, e.position, t.position), d.sub(h, h, r), h[0] }, n.computeGq = function() { return d.rotate(r, l.localOffsetB, t.angle), d.sub(h, e.position, t.position), d.sub(h, h, r), h[1] };
                var c = d.create(),
                    p = d.create();
                a.computeGq = function() { return d.rotate(c, l.localOffsetB, e.angle - l.localAngleB), d.scale(c, c, -1), d.sub(h, t.position, e.position), d.add(h, h, c), d.rotate(p, c, -Math.PI / 2), d.normalize(p, p), d.dot(h, p) }, this.localOffsetB = d.create(), i.localOffsetB ? d.copy(this.localOffsetB, i.localOffsetB) : (d.sub(this.localOffsetB, e.position, t.position), d.rotate(this.localOffsetB, this.localOffsetB, -t.angle)), this.localAngleB = 0, "number" == typeof i.localAngleB ? this.localAngleB = i.localAngleB : this.localAngleB = e.angle - t.angle, this.equations.push(o, n, a), this.setMaxForce(s)
            }(((e.exports = s).prototype = new u).constructor = s).prototype.setMaxForce = function(t) { for (var e = this.equations, i = 0; i < this.equations.length; i++) e[i].maxForce = t, e[i].minForce = -t }, s.prototype.getMaxForce = function() { return this.equations[0].maxForce };
            var n = d.create(),
                a = d.create(),
                r = d.create(),
                h = d.fromValues(1, 0),
                l = d.fromValues(0, 1);
            s.prototype.update = function() {
                var t = this.equations[0],
                    e = this.equations[1],
                    i = this.equations[2],
                    s = this.bodyA,
                    o = this.bodyB;
                d.rotate(n, this.localOffsetB, s.angle), d.rotate(a, this.localOffsetB, o.angle - this.localAngleB), d.scale(a, a, -1), d.rotate(r, a, Math.PI / 2), d.normalize(r, r), t.G[0] = -1, t.G[1] = 0, t.G[2] = -d.crossLength(n, h), t.G[3] = 1, e.G[0] = 0, e.G[1] = -1, e.G[2] = -d.crossLength(n, l), e.G[4] = 1, i.G[0] = -r[0], i.G[1] = -r[1], i.G[3] = r[0], i.G[4] = r[1], i.G[5] = d.crossLength(a, r)
            }
        }, { "../equations/Equation": 22, "../math/vec2": 30, "./Constraint": 14 }],
        18: [function(t, e, i) {
            var g = t("./Constraint"),
                f = t("../equations/ContactEquation"),
                m = t("../equations/Equation"),
                v = t("../math/vec2"),
                x = t("../equations/RotationalLockEquation");

            function s(s, o, t) {
                t = t || {}, g.call(this, s, o, g.PRISMATIC, t);
                var n = v.fromValues(0, 0),
                    a = v.fromValues(1, 0),
                    r = v.fromValues(0, 0);
                t.localAnchorA && v.copy(n, t.localAnchorA), t.localAxisA && v.copy(a, t.localAxisA), t.localAnchorB && v.copy(r, t.localAnchorB), this.localAnchorA = n, this.localAnchorB = r, this.localAxisA = a;
                var e = this.maxForce = void 0 !== t.maxForce ? t.maxForce : Number.MAX_VALUE,
                    i = new m(s, o, -e, e),
                    h = new v.create,
                    l = new v.create,
                    c = new v.create,
                    p = new v.create;
                if (i.computeGq = function() { return v.dot(c, p) }, i.updateJacobian = function() {
                        var t = this.G,
                            e = s.position,
                            i = o.position;
                        v.rotate(h, n, s.angle), v.rotate(l, r, o.angle), v.add(c, i, l), v.sub(c, c, e), v.sub(c, c, h), v.rotate(p, a, s.angle + Math.PI / 2), t[0] = -p[0], t[1] = -p[1], t[2] = -v.crossLength(h, p) + v.crossLength(p, c), t[3] = p[0], t[4] = p[1], t[5] = v.crossLength(l, p)
                    }, this.equations.push(i), !t.disableRotationalLock) {
                    var u = new x(s, o, -e, e);
                    this.equations.push(u)
                }
                this.position = 0, this.velocity = 0, this.lowerLimitEnabled = void 0 !== t.lowerLimit, this.upperLimitEnabled = void 0 !== t.upperLimit, this.lowerLimit = void 0 !== t.lowerLimit ? t.lowerLimit : 0, this.upperLimit = void 0 !== t.upperLimit ? t.upperLimit : 1, this.upperLimitEquation = new f(s, o), this.lowerLimitEquation = new f(s, o), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = e, this.motorEquation = new m(s, o), this.motorEnabled = !1, this.motorSpeed = 0;
                var d = this,
                    y = this.motorEquation;
                y.computeGW;
                y.computeGq = function() { return 0 }, y.computeGW = function() {
                    var t = this.G,
                        e = this.bodyA,
                        i = this.bodyB,
                        s = e.velocity,
                        o = i.velocity,
                        n = e.angularVelocity,
                        a = i.angularVelocity;
                    return this.gmult(t, s, n, o, a) + d.motorSpeed
                }
            }((e.exports = s).prototype = new g).constructor = s;
            var y = v.create(),
                b = v.create(),
                w = v.create(),
                P = v.create(),
                _ = v.create(),
                T = v.create();
            s.prototype.update = function() {
                var t = this.equations,
                    e = t[0],
                    i = this.upperLimit,
                    s = this.lowerLimit,
                    o = this.upperLimitEquation,
                    n = this.lowerLimitEquation,
                    a = this.bodyA,
                    r = this.bodyB,
                    h = this.localAxisA,
                    l = this.localAnchorA,
                    c = this.localAnchorB;
                e.updateJacobian(), v.rotate(y, h, a.angle), v.rotate(P, l, a.angle), v.add(b, P, a.position), v.rotate(_, c, r.angle), v.add(w, _, r.position);
                var p, u = this.position = v.dot(w, y) - v.dot(b, y);
                if (this.motorEnabled) {
                    var d = this.motorEquation.G;
                    d[0] = y[0], d[1] = y[1], d[2] = v.crossLength(y, _), d[3] = -y[0], d[4] = -y[1], d[5] = -v.crossLength(y, P)
                }
                this.upperLimitEnabled && i < u ? (v.scale(o.normalA, y, -1), v.sub(o.contactPointA, b, a.position), v.sub(o.contactPointB, w, r.position), v.scale(T, y, i), v.add(o.contactPointA, o.contactPointA, T), -1 === t.indexOf(o) && t.push(o)) : -1 !== (p = t.indexOf(o)) && t.splice(p, 1);
                this.lowerLimitEnabled && u < s ? (v.scale(n.normalA, y, 1), v.sub(n.contactPointA, b, a.position), v.sub(n.contactPointB, w, r.position), v.scale(T, y, s), v.sub(n.contactPointB, n.contactPointB, T), -1 === t.indexOf(n) && t.push(n)) : -1 !== (p = t.indexOf(n)) && t.splice(p, 1)
            }, s.prototype.enableMotor = function() { this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0) }, s.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1
                }
            }, s.prototype.setLimits = function(t, e) { this.lowerLimitEnabled = "number" == typeof t ? (this.lowerLimit = t, !0) : (this.lowerLimit = t, !1), this.upperLimitEnabled = "number" == typeof e ? (this.upperLimit = e, !0) : (this.upperLimit = e, !1) }
        }, { "../equations/ContactEquation": 21, "../equations/Equation": 22, "../equations/RotationalLockEquation": 24, "../math/vec2": 30, "./Constraint": 14 }],
        19: [function(t, e, i) {
            var h = t("./Constraint"),
                l = t("../equations/Equation"),
                c = t("../equations/RotationalVelocityEquation"),
                p = t("../equations/RotationalLockEquation"),
                d = t("../math/vec2");
            e.exports = s;
            var y = d.create(),
                g = d.create(),
                f = d.fromValues(1, 0),
                m = d.fromValues(0, 1),
                u = d.create();

            function s(t, e, i) {
                i = i || {}, h.call(this, t, e, h.REVOLUTE, i);
                var s = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE;
                this.pivotA = d.create(), this.pivotB = d.create(), i.worldPivot ? (d.sub(this.pivotA, i.worldPivot, t.position), d.sub(this.pivotB, i.worldPivot, e.position), d.rotate(this.pivotA, this.pivotA, -t.angle), d.rotate(this.pivotB, this.pivotB, -e.angle)) : (d.copy(this.pivotA, i.localPivotA), d.copy(this.pivotB, i.localPivotB));
                var o = this.equations = [new l(t, e, -s, s), new l(t, e, -s, s)],
                    n = o[0],
                    a = o[1],
                    r = this;
                n.computeGq = function() { return d.rotate(y, r.pivotA, t.angle), d.rotate(g, r.pivotB, e.angle), d.add(u, e.position, g), d.sub(u, u, t.position), d.sub(u, u, y), d.dot(u, f) }, a.computeGq = function() { return d.rotate(y, r.pivotA, t.angle), d.rotate(g, r.pivotB, e.angle), d.add(u, e.position, g), d.sub(u, u, t.position), d.sub(u, u, y), d.dot(u, m) }, a.minForce = n.minForce = -s, a.maxForce = n.maxForce = s, this.motorEquation = new c(t, e), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new p(t, e), this.lowerLimitEquation = new p(t, e), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0
            }((s.prototype = new h).constructor = s).prototype.setLimits = function(t, e) { this.lowerLimitEnabled = "number" == typeof t ? (this.lowerLimit = t, !0) : (this.lowerLimit = t, !1), this.upperLimitEnabled = "number" == typeof e ? (this.upperLimit = e, !0) : (this.upperLimit = e, !1) }, s.prototype.update = function() {
                var t, e = this.bodyA,
                    i = this.bodyB,
                    s = this.pivotA,
                    o = this.pivotB,
                    n = this.equations,
                    a = (n[0], n[1], n[0]),
                    r = n[1],
                    h = this.upperLimit,
                    l = this.lowerLimit,
                    c = this.upperLimitEquation,
                    p = this.lowerLimitEquation,
                    u = this.angle = i.angle - e.angle;
                this.upperLimitEnabled && h < u ? (c.angle = h, -1 === n.indexOf(c) && n.push(c)) : -1 !== (t = n.indexOf(c)) && n.splice(t, 1);
                this.lowerLimitEnabled && u < l ? (p.angle = l, -1 === n.indexOf(p) && n.push(p)) : -1 !== (t = n.indexOf(p)) && n.splice(t, 1);
                d.rotate(y, s, e.angle), d.rotate(g, o, i.angle), a.G[0] = -1, a.G[1] = 0, a.G[2] = -d.crossLength(y, f), a.G[3] = 1, a.G[4] = 0, a.G[5] = d.crossLength(g, f), r.G[0] = 0, r.G[1] = -1, r.G[2] = -d.crossLength(y, m), r.G[3] = 0, r.G[4] = 1, r.G[5] = d.crossLength(g, m)
            }, s.prototype.enableMotor = function() { this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0) }, s.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1
                }
            }, s.prototype.motorIsEnabled = function() { return !!this.motorEnabled }, s.prototype.setMotorSpeed = function(t) {
                if (this.motorEnabled) {
                    var e = this.equations.indexOf(this.motorEquation);
                    this.equations[e].relativeVelocity = t
                }
            }, s.prototype.getMotorSpeed = function() { return !!this.motorEnabled && this.motorEquation.relativeVelocity }
        }, { "../equations/Equation": 22, "../equations/RotationalLockEquation": 24, "../equations/RotationalVelocityEquation": 25, "../math/vec2": 30, "./Constraint": 14 }],
        20: [function(t, e, i) {
            var s = t("./Equation");
            t("../math/vec2");

            function o(t, e, i) { i = i || {}, s.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0, this.ratio = "number" == typeof i.ratio ? i.ratio : 1, this.setRatio(this.ratio) }(((e.exports = o).prototype = new s).constructor = o).prototype.computeGq = function() { return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle }, o.prototype.setRatio = function(t) {
                var e = this.G;
                e[2] = t, e[5] = -1, this.ratio = t
            }, o.prototype.setMaxTorque = function(t) { this.maxForce = t, this.minForce = -t }
        }, { "../math/vec2": 30, "./Equation": 22 }],
        21: [function(t, e, i) {
            var s = t("./Equation"),
                f = t("../math/vec2");

            function o(t, e) { s.call(this, t, e, 0, Number.MAX_VALUE), this.contactPointA = f.create(), this.penetrationVec = f.create(), this.contactPointB = f.create(), this.normalA = f.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null }(((e.exports = o).prototype = new s).constructor = o).prototype.computeB = function(t, e, i) {
                var s, o, n = this.bodyA,
                    a = this.bodyB,
                    r = this.contactPointA,
                    h = this.contactPointB,
                    l = n.position,
                    c = a.position,
                    p = this.penetrationVec,
                    u = this.normalA,
                    d = this.G,
                    y = f.crossLength(r, u),
                    g = f.crossLength(h, u);
                return d[0] = -u[0], d[1] = -u[1], d[2] = -y, d[3] = u[0], d[4] = u[1], d[5] = g, f.add(p, c, h), f.sub(p, p, l), f.sub(p, p, r), s = this.firstImpact && 0 !== this.restitution ? (o = 0, 1 / e * (1 + this.restitution) * this.computeGW()) : (o = f.dot(u, p) + this.offset, this.computeGW()), -o * t - s * e - i * this.computeGiMf()
            }
        }, { "../math/vec2": 30, "./Equation": 22 }],
        22: [function(t, e, i) {
            e.exports = a;
            var p = t("../math/vec2"),
                n = t("../utils/Utils");
            t("../objects/Body");

            function a(t, e, i, s) {
                this.minForce = void 0 === i ? -Number.MAX_VALUE : i, this.maxForce = void 0 === s ? Number.MAX_VALUE : s, this.bodyA = t, this.bodyB = e, this.stiffness = a.DEFAULT_STIFFNESS, this.relaxation = a.DEFAULT_RELAXATION, this.G = new n.ARRAY_TYPE(6);
                for (var o = 0; o < 6; o++) this.G[o] = 0;
                this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0
            }(a.prototype.constructor = a).DEFAULT_STIFFNESS = 1e6, a.DEFAULT_RELAXATION = 4, a.prototype.update = function() {
                var t = this.stiffness,
                    e = this.relaxation,
                    i = this.timeStep;
                this.a = 4 / (i * (1 + 4 * e)), this.b = 4 * e / (1 + 4 * e), this.epsilon = 4 / (i * i * t * (1 + 4 * e)), this.needsUpdate = !1
            }, a.prototype.gmult = function(t, e, i, s, o) { return t[0] * e[0] + t[1] * e[1] + t[2] * i + t[3] * s[0] + t[4] * s[1] + t[5] * o }, a.prototype.computeB = function(t, e, i) { var s = this.computeGW(); return -this.computeGq() * t - s * e - this.computeGiMf() * i };
            var r = p.create(),
                h = p.create();
            a.prototype.computeGq = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = (e.position, i.position, e.angle),
                    o = i.angle;
                return this.gmult(t, r, s, h, o) + this.offset
            }, a.prototype.computeGW = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = e.velocity,
                    o = i.velocity,
                    n = e.angularVelocity,
                    a = i.angularVelocity;
                return this.gmult(t, s, n, o, a) + this.relativeVelocity
            }, a.prototype.computeGWlambda = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = e.vlambda,
                    o = i.vlambda,
                    n = e.wlambda,
                    a = i.wlambda;
                return this.gmult(t, s, n, o, a)
            };
            var u = p.create(),
                d = p.create();
            a.prototype.computeGiMf = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.force,
                    s = t.angularForce,
                    o = e.force,
                    n = e.angularForce,
                    a = t.invMassSolve,
                    r = e.invMassSolve,
                    h = t.invInertiaSolve,
                    l = e.invInertiaSolve,
                    c = this.G;
                return p.scale(u, i, a), p.multiply(u, t.massMultiplier, u), p.scale(d, o, r), p.multiply(d, e.massMultiplier, d), this.gmult(c, u, s * h, d, n * l)
            }, a.prototype.computeGiMGt = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.invMassSolve,
                    s = e.invMassSolve,
                    o = t.invInertiaSolve,
                    n = e.invInertiaSolve,
                    a = this.G;
                return a[0] * a[0] * i * t.massMultiplier[0] + a[1] * a[1] * i * t.massMultiplier[1] + a[2] * a[2] * o + a[3] * a[3] * s * e.massMultiplier[0] + a[4] * a[4] * s * e.massMultiplier[1] + a[5] * a[5] * n
            };
            var y = p.create(),
                g = p.create(),
                f = p.create();
            p.create(), p.create(), p.create();
            a.prototype.addToWlambda = function(t) {
                var e = this.bodyA,
                    i = this.bodyB,
                    s = y,
                    o = g,
                    n = f,
                    a = e.invMassSolve,
                    r = i.invMassSolve,
                    h = e.invInertiaSolve,
                    l = i.invInertiaSolve,
                    c = this.G;
                o[0] = c[0], o[1] = c[1], n[0] = c[3], n[1] = c[4], p.scale(s, o, a * t), p.multiply(s, s, e.massMultiplier), p.add(e.vlambda, e.vlambda, s), e.wlambda += h * c[2] * t, p.scale(s, n, r * t), p.multiply(s, s, i.massMultiplier), p.add(i.vlambda, i.vlambda, s), i.wlambda += l * c[5] * t
            }, a.prototype.computeInvC = function(t) { return 1 / (this.computeGiMGt() + t) }
        }, { "../math/vec2": 30, "../objects/Body": 31, "../utils/Utils": 57 }],
        23: [function(t, e, i) {
            var r = t("../math/vec2"),
                s = t("./Equation");
            t("../utils/Utils");

            function o(t, e, i) { s.call(this, t, e, -i, i), this.contactPointA = r.create(), this.contactPointB = r.create(), this.t = r.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, this.frictionCoefficient = .3 }(((e.exports = o).prototype = new s).constructor = o).prototype.setSlipForce = function(t) { this.maxForce = t, this.minForce = -t }, o.prototype.getSlipForce = function() { return this.maxForce }, o.prototype.computeB = function(t, e, i) {
                this.bodyA, this.bodyB;
                var s = this.contactPointA,
                    o = this.contactPointB,
                    n = this.t,
                    a = this.G;
                return a[0] = -n[0], a[1] = -n[1], a[2] = -r.crossLength(s, n), a[3] = n[0], a[4] = n[1], a[5] = r.crossLength(o, n), -this.computeGW() * e - i * this.computeGiMf()
            }
        }, { "../math/vec2": 30, "../utils/Utils": 57, "./Equation": 22 }],
        24: [function(t, e, i) {
            var o = t("./Equation"),
                s = t("../math/vec2");

            function n(t, e, i) {
                i = i || {}, o.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0;
                var s = this.G;
                s[2] = 1, s[5] = -1
            }((e.exports = n).prototype = new o).constructor = n;
            var a = s.create(),
                r = s.create(),
                h = s.fromValues(1, 0),
                l = s.fromValues(0, 1);
            n.prototype.computeGq = function() { return s.rotate(a, h, this.bodyA.angle + this.angle), s.rotate(r, l, this.bodyB.angle), s.dot(a, r) }
        }, { "../math/vec2": 30, "./Equation": 22 }],
        25: [function(t, e, i) {
            var s = t("./Equation");
            t("../math/vec2");

            function o(t, e) { s.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1 }(((e.exports = o).prototype = new s).constructor = o).prototype.computeB = function(t, e, i) {
                var s = this.G;
                s[2] = -1, s[5] = this.ratio;
                var o = this.computeGiMf();
                return -this.computeGW() * e - i * o
            }
        }, { "../math/vec2": 30, "./Equation": 22 }],
        26: [function(t, e, i) {
            var s = function() {};
            (e.exports = s).prototype = {
                constructor: s,
                on: function(t, e, i) { e.context = i || this, void 0 === this._listeners && (this._listeners = {}); var s = this._listeners; return void 0 === s[t] && (s[t] = []), -1 === s[t].indexOf(e) && s[t].push(e), this },
                has: function(t, e) { if (void 0 === this._listeners) return !1; var i = this._listeners; if (e) { if (void 0 !== i[t] && -1 !== i[t].indexOf(e)) return !0 } else if (void 0 !== i[t]) return !0; return !1 },
                off: function(t, e) {
                    if (void 0 === this._listeners) return this;
                    var i = this._listeners,
                        s = i[t].indexOf(e);
                    return -1 !== s && i[t].splice(s, 1), this
                },
                emit: function(t) {
                    if (void 0 === this._listeners) return this;
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = 0, s = e.length; i < s; i++) {
                            var o = e[i];
                            o.call(o.context, t)
                        }
                    }
                    return this
                }
            }
        }, {}],
        27: [function(t, e, i) {
            var s = t("./Material"),
                o = t("../equations/Equation");

            function n(t, e, i) {
                if (i = i || {}, !(t instanceof s && e instanceof s)) throw new Error("First two arguments must be Material instances.");
                this.id = n.idCounter++, this.materialA = t, this.materialB = e, this.friction = void 0 !== i.friction ? Number(i.friction) : .3, this.restitution = void 0 !== i.restitution ? Number(i.restitution) : 0, this.stiffness = void 0 !== i.stiffness ? Number(i.stiffness) : o.DEFAULT_STIFFNESS, this.relaxation = void 0 !== i.relaxation ? Number(i.relaxation) : o.DEFAULT_RELAXATION, this.frictionStiffness = void 0 !== i.frictionStiffness ? Number(i.frictionStiffness) : o.DEFAULT_STIFFNESS, this.frictionRelaxation = void 0 !== i.frictionRelaxation ? Number(i.frictionRelaxation) : o.DEFAULT_RELAXATION, this.surfaceVelocity = void 0 !== i.surfaceVelocity ? Number(i.surfaceVelocity) : 0, this.contactSkinSize = .005
            }(e.exports = n).idCounter = 0
        }, { "../equations/Equation": 22, "./Material": 28 }],
        28: [function(t, e, i) {
            function s(t) { this.id = t || s.idCounter++ }(e.exports = s).idCounter = 0
        }, {}],
        29: [function(t, e, i) {
            var v = {
                GetArea: function(t) { if (t.length < 6) return 0; for (var e = t.length - 2, i = 0, s = 0; s < e; s += 2) i += (t[s + 2] - t[s]) * (t[s + 1] + t[s + 3]); return .5 * -(i += (t[0] - t[e]) * (t[e + 1] + t[1])) },
                Triangulate: function(t) {
                    var e = t.length >> 1;
                    if (e < 3) return [];
                    for (var i = [], s = [], o = 0; o < e; o++) s.push(o);
                    o = 0;
                    for (var n = e; 3 < n;) {
                        var a = s[(o + 0) % n],
                            r = s[(o + 1) % n],
                            h = s[(o + 2) % n],
                            l = t[2 * a],
                            c = t[2 * a + 1],
                            p = t[2 * r],
                            u = t[2 * r + 1],
                            d = t[2 * h],
                            y = t[2 * h + 1],
                            g = !1;
                        if (v._convex(l, c, p, u, d, y)) { g = !0; for (var f = 0; f < n; f++) { var m = s[f]; if (m != a && m != r && m != h && v._PointInTriangle(t[2 * m], t[2 * m + 1], l, c, p, u, d, y)) { g = !1; break } } }
                        if (g) i.push(a, r, h), s.splice((o + 1) % n, 1), n--, o = 0;
                        else if (o++ > 3 * n) break
                    }
                    return i.push(s[0], s[1], s[2]), i
                },
                _PointInTriangle: function(t, e, i, s, o, n, a, r) {
                    var h = a - i,
                        l = r - s,
                        c = o - i,
                        p = n - s,
                        u = t - i,
                        d = e - s,
                        y = h * h + l * l,
                        g = h * c + l * p,
                        f = h * u + l * d,
                        m = c * c + p * p,
                        v = c * u + p * d,
                        x = 1 / (y * m - g * g),
                        b = (m * f - g * v) * x,
                        w = (y * v - g * f) * x;
                    return 0 <= b && 0 <= w && b + w < 1
                },
                _convex: function(t, e, i, s, o, n) { return 0 <= (e - s) * (o - i) + (i - t) * (n - s) }
            };
            e.exports = v
        }, {}],
        30: [function(t, e, i) {
            var a = e.exports = {},
                s = t("../utils/Utils");
            a.crossLength = function(t, e) { return t[0] * e[1] - t[1] * e[0] }, a.crossVZ = function(t, e, i) { return a.rotate(t, e, -Math.PI / 2), a.scale(t, t, i), t }, a.crossZV = function(t, e, i) { return a.rotate(t, i, Math.PI / 2), a.scale(t, t, e), t }, a.rotate = function(t, e, i) {
                if (0 !== i) {
                    var s = Math.cos(i),
                        o = Math.sin(i),
                        n = e[0],
                        a = e[1];
                    t[0] = s * n - o * a, t[1] = o * n + s * a
                }
                else t[0] = e[0], t[1] = e[1]
            }, a.rotate90cw = function(t, e) {
                var i = e[0],
                    s = e[1];
                t[0] = s, t[1] = -i
            }, a.toLocalFrame = function(t, e, i, s) { a.copy(t, e), a.sub(t, t, i), a.rotate(t, t, -s) }, a.toGlobalFrame = function(t, e, i, s) { a.copy(t, e), a.rotate(t, t, s), a.add(t, t, i) }, a.vectorToLocalFrame = function(t, e, i) { a.rotate(t, e, -i) }, a.vectorToGlobalFrame = function(t, e, i) { a.rotate(t, e, i) }, a.centroid = function(t, e, i, s) { return a.add(t, e, i), a.add(t, t, s), a.scale(t, t, 1 / 3), t }, a.create = function() { var t = new s.ARRAY_TYPE(2); return t[0] = 0, t[1] = 0, t }, a.clone = function(t) { var e = new s.ARRAY_TYPE(2); return e[0] = t[0], e[1] = t[1], e }, a.fromValues = function(t, e) { var i = new s.ARRAY_TYPE(2); return i[0] = t, i[1] = e, i }, a.copy = function(t, e) { return t[0] = e[0], t[1] = e[1], t }, a.set = function(t, e, i) { return t[0] = e, t[1] = i, t }, a.add = function(t, e, i) { return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t }, a.subtract = function(t, e, i) { return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t }, a.sub = a.subtract, a.multiply = function(t, e, i) { return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t }, a.mul = a.multiply, a.divide = function(t, e, i) { return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t }, a.div = a.divide, a.scale = function(t, e, i) { return t[0] = e[0] * i, t[1] = e[1] * i, t }, a.distance = function(t, e) {
                var i = e[0] - t[0],
                    s = e[1] - t[1];
                return Math.sqrt(i * i + s * s)
            }, a.dist = a.distance, a.squaredDistance = function(t, e) {
                var i = e[0] - t[0],
                    s = e[1] - t[1];
                return i * i + s * s
            }, a.sqrDist = a.squaredDistance, a.length = function(t) {
                var e = t[0],
                    i = t[1];
                return Math.sqrt(e * e + i * i)
            }, a.len = a.length, a.squaredLength = function(t) {
                var e = t[0],
                    i = t[1];
                return e * e + i * i
            }, a.sqrLen = a.squaredLength, a.negate = function(t, e) { return t[0] = -e[0], t[1] = -e[1], t }, a.normalize = function(t, e) {
                var i = e[0],
                    s = e[1],
                    o = i * i + s * s;
                return 0 < o && (o = 1 / Math.sqrt(o), t[0] = e[0] * o, t[1] = e[1] * o), t
            }, a.dot = function(t, e) { return t[0] * e[0] + t[1] * e[1] }, a.str = function(t) { return "vec2(" + t[0] + ", " + t[1] + ")" }, a.lerp = function(t, e, i, s) {
                var o = e[0],
                    n = e[1];
                return t[0] = o + s * (i[0] - o), t[1] = n + s * (i[1] - n), t
            }, a.reflect = function(t, e, i) {
                var s = e[0] * i[0] + e[1] * i[1];
                t[0] = e[0] - 2 * i[0] * s, t[1] = e[1] - 2 * i[1] * s
            }, a.getLineSegmentsIntersection = function(t, e, i, s, o) { var n = a.getLineSegmentsIntersectionFraction(e, i, s, o); return !(n < 0) && (t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), !0) }, a.getLineSegmentsIntersectionFraction = function(t, e, i, s) {
                var o, n, a = e[0] - t[0],
                    r = e[1] - t[1],
                    h = s[0] - i[0],
                    l = s[1] - i[1];
                return o = (-r * (t[0] - i[0]) + a * (t[1] - i[1])) / (-h * r + a * l), n = (h * (t[1] - i[1]) - l * (t[0] - i[0])) / (-h * r + a * l), 0 <= o && o <= 1 && 0 <= n && n <= 1 ? n : -1
            }
        }, { "../utils/Utils": 57 }],
        31: [function(t, e, i) {
            var p = t("../math/vec2"),
                l = t("poly-decomp"),
                c = t("../shapes/Convex"),
                s = t("../collision/RaycastResult"),
                o = t("../collision/Ray"),
                n = t("../collision/AABB"),
                a = t("../events/EventEmitter");

            function r(t) { t = t || {}, a.call(this), this.id = t.id || ++r._idCounter, this.world = null, this.shapes = [], this.mass = t.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!t.fixedRotation, this.fixedX = !!t.fixedX, this.fixedY = !!t.fixedY, this.massMultiplier = p.create(), this.position = p.fromValues(0, 0), t.position && p.copy(this.position, t.position), this.interpolatedPosition = p.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = p.fromValues(0, 0), this.previousAngle = 0, this.velocity = p.fromValues(0, 0), t.velocity && p.copy(this.velocity, t.velocity), this.vlambda = p.fromValues(0, 0), this.wlambda = 0, this.angle = t.angle || 0, this.angularVelocity = t.angularVelocity || 0, this.force = p.create(), t.force && p.copy(this.force, t.force), this.angularForce = t.angularForce || 0, this.damping = "number" == typeof t.damping ? t.damping : .1, this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping : .1, this.type = r.STATIC, void 0 !== t.type ? this.type = t.type : t.mass ? this.type = r.DYNAMIC : this.type = r.STATIC, this.boundingRadius = 0, this.aabb = new n, this.aabbNeedsUpdate = !0, this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.wantsToSleep = !1, this.sleepState = r.AWAKE, this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .2, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, this.gravityScale = void 0 !== t.gravityScale ? t.gravityScale : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== t.ccdSpeedThreshold ? t.ccdSpeedThreshold : -1, this.ccdIterations = void 0 !== t.ccdIterations ? t.ccdIterations : 10, this.concavePath = null, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties() }(((e.exports = r).prototype = new a).constructor = r)._idCounter = 0, r.prototype.updateSolveMassProperties = function() { this.sleepState === r.SLEEPING || this.type === r.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia) }, r.prototype.setDensity = function(t) {
                var e = this.getArea();
                this.mass = e * t, this.updateMassProperties()
            }, r.prototype.getArea = function() { for (var t = 0, e = 0; e < this.shapes.length; e++) t += this.shapes[e].area; return t }, r.prototype.getAABB = function() { return this.aabbNeedsUpdate && this.updateAABB(), this.aabb };
            var h = new n,
                u = p.create();
            r.prototype.updateAABB = function() {
                for (var t = this.shapes, e = t.length, i = u, s = this.angle, o = 0; o !== e; o++) {
                    var n = t[o],
                        a = n.angle + s;
                    p.rotate(i, n.position, s), p.add(i, i, this.position), n.computeAABB(h, i, a), 0 === o ? this.aabb.copy(h) : this.aabb.extend(h)
                }
                this.aabbNeedsUpdate = !1
            }, r.prototype.updateBoundingRadius = function() {
                for (var t = this.shapes, e = t.length, i = 0, s = 0; s !== e; s++) {
                    var o = t[s],
                        n = p.length(o.position),
                        a = o.boundingRadius;
                    i < n + a && (i = n + a)
                }
                this.boundingRadius = i
            }, r.prototype.addShape = function(t, e, i) {
                if (t.body) throw new Error("A shape can only be added to one body.");
                t.body = this, e ? p.copy(t.position, e) : p.set(t.position, 0, 0), t.angle = i || 0, this.shapes.push(t), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0
            }, r.prototype.removeShape = function(t) { var e = this.shapes.indexOf(t); return -1 !== e && (this.shapes.splice(e, 1), this.aabbNeedsUpdate = !0, !(t.body = null)) }, r.prototype.updateMassProperties = function() {
                if (this.type === r.STATIC || this.type === r.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                else {
                    var t = this.shapes,
                        e = t.length,
                        i = this.mass / e,
                        s = 0;
                    if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                    else {
                        for (var o = 0; o < e; o++) {
                            var n = t[o],
                                a = p.squaredLength(n.position);
                            s += n.computeMomentOfInertia(i) + i * a
                        }
                        this.inertia = s, this.invInertia = 0 < s ? 1 / s : 0
                    }
                    this.invMass = 1 / this.mass, p.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                }
            };
            p.create();
            r.prototype.applyForce = function(t, e) {
                if (p.add(this.force, this.force, t), e) {
                    var i = p.crossLength(e, t);
                    this.angularForce += i
                }
            };
            var d = p.create(),
                y = p.create(),
                g = p.create();
            r.prototype.applyForceLocal = function(t, e) {
                e = e || g;
                var i = d,
                    s = y;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(s, e), this.applyForce(i, s)
            };
            var f = p.create();
            r.prototype.applyImpulse = function(t, e) {
                if (this.type === r.DYNAMIC) {
                    var i = f;
                    if (p.scale(i, t, this.invMass), p.multiply(i, this.massMultiplier, i), p.add(this.velocity, i, this.velocity), e) {
                        var s = p.crossLength(e, t);
                        s *= this.invInertia, this.angularVelocity += s
                    }
                }
            };
            var m = p.create(),
                v = p.create(),
                x = p.create();
            r.prototype.applyImpulseLocal = function(t, e) {
                e = e || x;
                var i = m,
                    s = v;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(s, e), this.applyImpulse(i, s)
            }, r.prototype.toLocalFrame = function(t, e) { p.toLocalFrame(t, e, this.position, this.angle) }, r.prototype.toWorldFrame = function(t, e) { p.toGlobalFrame(t, e, this.position, this.angle) }, r.prototype.vectorToLocalFrame = function(t, e) { p.vectorToLocalFrame(t, e, this.angle) }, r.prototype.vectorToWorldFrame = function(t, e) { p.vectorToGlobalFrame(t, e, this.angle) }, r.prototype.fromPolygon = function(t, e) {
                e = e || {};
                for (var i = this.shapes.length; 0 <= i; --i) this.removeShape(this.shapes[i]);
                var s, o = new l.Polygon;
                if (o.vertices = t, o.makeCCW(), "number" == typeof e.removeCollinearPoints && o.removeCollinearPoints(e.removeCollinearPoints), void 0 === e.skipSimpleCheck && !o.isSimple()) return !1;
                this.concavePath = o.vertices.slice(0);
                for (i = 0; i < this.concavePath.length; i++) {
                    var n = [0, 0];
                    p.copy(n, this.concavePath[i]), this.concavePath[i] = n
                }
                s = e.optimalDecomp ? o.decomp() : o.quickDecomp();
                var a = p.create();
                for (i = 0; i !== s.length; i++) {
                    for (var r = new c({ vertices: s[i].vertices }), h = 0; h !== r.vertices.length; h++) {
                        n = r.vertices[h];
                        p.sub(n, n, r.centerOfMass)
                    }
                    p.scale(a, r.centerOfMass, 1), r.updateTriangles(), r.updateCenterOfMass(), r.updateBoundingRadius(), this.addShape(r, a)
                }
                return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0
            };
            p.fromValues(0, 0);
            var b = p.fromValues(0, 0),
                w = p.fromValues(0, 0),
                P = p.fromValues(0, 0);
            r.prototype.adjustCenterOfMass = function() {
                var t = b,
                    e = w,
                    i = P,
                    s = 0;
                p.set(e, 0, 0);
                for (var o = 0; o !== this.shapes.length; o++) {
                    var n = this.shapes[o];
                    p.scale(t, n.position, n.area), p.add(e, e, t), s += n.area
                }
                p.scale(i, e, 1 / s);
                for (o = 0; o !== this.shapes.length; o++) {
                    n = this.shapes[o];
                    p.sub(n.position, n.position, i)
                }
                p.add(this.position, this.position, i);
                for (o = 0; this.concavePath && o < this.concavePath.length; o++) p.sub(this.concavePath[o], this.concavePath[o], i);
                this.updateMassProperties(), this.updateBoundingRadius()
            }, r.prototype.setZeroForce = function() { p.set(this.force, 0, 0), this.angularForce = 0 }, r.prototype.resetConstraintVelocity = function() {
                var t = this.vlambda;
                p.set(t, 0, 0), this.wlambda = 0
            }, r.prototype.addConstraintVelocity = function() {
                var t = this.velocity;
                p.add(t, t, this.vlambda), this.angularVelocity += this.wlambda
            }, r.prototype.applyDamping = function(t) {
                if (this.type === r.DYNAMIC) {
                    var e = this.velocity;
                    p.scale(e, e, Math.pow(1 - this.damping, t)), this.angularVelocity *= Math.pow(1 - this.angularDamping, t)
                }
            }, r.prototype.wakeUp = function() {
                var t = this.sleepState;
                this.sleepState = r.AWAKE, this.idleTime = 0, t !== r.AWAKE && this.emit(r.wakeUpEvent)
            }, r.prototype.sleep = function() { this.sleepState = r.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, p.set(this.velocity, 0, 0), p.set(this.force, 0, 0), this.emit(r.sleepEvent) }, r.prototype.sleepTick = function(t, e, i) {
                if (this.allowSleep && this.type !== r.SLEEPING) {
                    this.wantsToSleep = !1;
                    this.sleepState;
                    var s = p.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2),
                        o = Math.pow(this.sleepSpeedLimit, 2);
                    this.sleepState = o <= s ? (this.idleTime = 0, r.AWAKE) : (this.idleTime += i, r.SLEEPY), this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep())
                }
            }, r.prototype.overlaps = function(t) { return this.world.overlapKeeper.bodiesAreOverlapping(this, t) };
            var _ = p.create(),
                T = p.create();
            r.prototype.integrate = function(t) {
                var e = this.invMass,
                    i = this.force,
                    s = this.position,
                    o = this.velocity;
                p.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * t), p.scale(_, i, t * e), p.multiply(_, this.massMultiplier, _), p.add(o, _, o), this.integrateToTimeOfImpact(t) || (p.scale(T, o, t), p.add(s, s, T), this.fixedRotation || (this.angle += this.angularVelocity * t)), this.aabbNeedsUpdate = !0
            };
            var S = new s,
                k = new o({ mode: o.ALL }),
                B = p.create(),
                A = p.create(),
                C = p.create(),
                I = p.create();
            r.prototype.integrateToTimeOfImpact = function(t) {
                if (this.ccdSpeedThreshold < 0 || p.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                p.normalize(B, this.velocity), p.scale(A, this.velocity, t), p.add(A, A, this.position), p.sub(C, A, this.position);
                var e, i = this.angularVelocity * t,
                    s = p.length(C),
                    o = 1,
                    n = this;
                if (S.reset(), k.callback = function(t) { t.body !== n && (e = t.body, t.getHitPoint(A, k), p.sub(C, A, n.position), o = p.length(C) / s, t.stop()) }, p.copy(k.from, this.position), p.copy(k.to, A), k.update(), this.world.raycast(S, k), !e) return !1;
                var a = this.angle;
                p.copy(I, this.position);
                for (var r = 0, h = 0, l = 0, c = o; h <= c && r < this.ccdIterations;) { r++, l = (c - h) / 2, p.scale(T, C, o), p.add(this.position, I, T), this.angle = a + i * o, this.updateAABB(), this.aabb.overlaps(e.aabb) && this.world.narrowphase.bodiesOverlap(this, e) ? h = l : c = l }
                return o = l, p.copy(this.position, I), this.angle = a, p.scale(T, C, o), p.add(this.position, this.position, T), this.fixedRotation || (this.angle += i * o), !0
            }, r.prototype.getVelocityAtPoint = function(t, e) { return p.crossVZ(t, e, this.angularVelocity), p.subtract(t, this.velocity, t), t }, r.sleepyEvent = { type: "sleepy" }, r.sleepEvent = { type: "sleep" }, r.wakeUpEvent = { type: "wakeup" }, r.DYNAMIC = 1, r.STATIC = 2, r.KINEMATIC = 4, r.AWAKE = 0, r.SLEEPY = 1, r.SLEEPING = 2
        }, { "../collision/AABB": 7, "../collision/Ray": 11, "../collision/RaycastResult": 12, "../events/EventEmitter": 26, "../math/vec2": 30, "../shapes/Convex": 40, "poly-decomp": 5 }],
        32: [function(t, e, i) {
            var m = t("../math/vec2"),
                a = t("./Spring");
            t("../utils/Utils");

            function s(t, e, i) {
                i = i || {}, a.call(this, t, e, i), this.localAnchorA = m.fromValues(0, 0), this.localAnchorB = m.fromValues(0, 0), i.localAnchorA && m.copy(this.localAnchorA, i.localAnchorA), i.localAnchorB && m.copy(this.localAnchorB, i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
                var s = m.create(),
                    o = m.create();
                this.getWorldAnchorA(s), this.getWorldAnchorB(o);
                var n = m.distance(s, o);
                this.restLength = "number" == typeof i.restLength ? i.restLength : n
            }(((e.exports = s).prototype = new a).constructor = s).prototype.setWorldAnchorA = function(t) { this.bodyA.toLocalFrame(this.localAnchorA, t) }, s.prototype.setWorldAnchorB = function(t) { this.bodyB.toLocalFrame(this.localAnchorB, t) }, s.prototype.getWorldAnchorA = function(t) { this.bodyA.toWorldFrame(t, this.localAnchorA) }, s.prototype.getWorldAnchorB = function(t) { this.bodyB.toWorldFrame(t, this.localAnchorB) };
            var v = m.create(),
                x = m.create(),
                b = m.create(),
                w = m.create(),
                P = m.create(),
                _ = m.create(),
                T = m.create(),
                S = m.create(),
                k = m.create();
            s.prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restLength,
                    s = this.bodyA,
                    o = this.bodyB,
                    n = v,
                    a = x,
                    r = b,
                    h = w,
                    l = k,
                    c = P,
                    p = _,
                    u = T,
                    d = S;
                this.getWorldAnchorA(c), this.getWorldAnchorB(p), m.sub(u, c, s.position), m.sub(d, p, o.position), m.sub(n, p, c);
                var y = m.len(n);
                m.normalize(a, n), m.sub(r, o.velocity, s.velocity), m.crossZV(l, o.angularVelocity, d), m.add(r, r, l), m.crossZV(l, s.angularVelocity, u), m.sub(r, r, l), m.scale(h, a, -t * (y - i) - e * m.dot(r, a)), m.sub(s.force, s.force, h), m.add(o.force, o.force, h);
                var g = m.crossLength(u, h),
                    f = m.crossLength(d, h);
                s.angularForce -= g, o.angularForce += f
            }
        }, { "../math/vec2": 30, "../utils/Utils": 57, "./Spring": 34 }],
        33: [function(t, e, i) {
            t("../math/vec2");
            var s = t("./Spring");

            function o(t, e, i) { i = i || {}, s.call(this, t, e, i), this.restAngle = "number" == typeof i.restAngle ? i.restAngle : e.angle - t.angle }(((e.exports = o).prototype = new s).constructor = o).prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restAngle,
                    s = this.bodyA,
                    o = this.bodyB,
                    n = -t * (o.angle - s.angle - i) - e * (o.angularVelocity - s.angularVelocity) * 0;
                s.angularForce -= n, o.angularForce += n
            }
        }, { "../math/vec2": 30, "./Spring": 34 }],
        34: [function(t, e, i) {
            t("../math/vec2");
            var s = t("../utils/Utils");

            function o(t, e, i) { i = s.defaults(i, { stiffness: 100, damping: 1 }), this.stiffness = i.stiffness, this.damping = i.damping, this.bodyA = t, this.bodyB = e }(e.exports = o).prototype.applyForce = function() {}
        }, { "../math/vec2": 30, "../utils/Utils": 57 }],
        35: [function(t, e, i) {
            var s = t("../math/vec2"),
                o = (t("../utils/Utils"), t("../constraints/Constraint")),
                n = t("../equations/FrictionEquation"),
                a = t("../objects/Body");

            function r(t, e) {
                e = e || {}, this.chassisBody = t, this.wheels = [], this.groundBody = new a({ mass: 0 }), this.world = null;
                var i = this;
                this.preStepCallback = function() { i.update() }
            }

            function h(t, e) { e = e || {}, this.vehicle = t, this.forwardEquation = new n(t.chassisBody, t.groundBody), this.sideEquation = new n(t.chassisBody, t.groundBody), this.steerValue = 0, this.engineForce = 0, this.setSideFriction(void 0 !== e.sideFriction ? e.sideFriction : 5), this.localForwardVector = s.fromValues(0, 1), e.localForwardVector && s.copy(this.localForwardVector, e.localForwardVector), this.localPosition = s.fromValues(0, 0), e.localPosition && s.copy(this.localPosition, e.localPosition), o.apply(this, t.chassisBody, t.groundBody), this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0) }(e.exports = r).prototype.addToWorld = function(t) {
                (this.world = t).addBody(this.groundBody), t.on("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.addConstraint(i)
                }
            }, r.prototype.removeFromWorld = function() {
                var t = this.world;
                t.removeBody(this.groundBody), t.off("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.removeConstraint(i)
                }
                this.world = null
            }, r.prototype.addWheel = function(t) { var e = new h(this, t); return this.wheels.push(e), e }, r.prototype.update = function() { for (var t = 0; t < this.wheels.length; t++) this.wheels[t].update() }, (h.prototype = new o).setBrakeForce = function(t) { this.forwardEquation.setSlipForce(t) }, h.prototype.setSideFriction = function(t) { this.sideEquation.setSlipForce(t) };
            var l = s.create(),
                c = s.create();
            h.prototype.getSpeed = function() { return this.vehicle.chassisBody.vectorToWorldFrame(c, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(l, c), s.dot(l, c) };
            var p = s.create();
            h.prototype.update = function() { this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), s.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), s.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), s.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), s.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), s.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), s.normalize(p, this.forwardEquation.t), s.scale(p, p, this.engineForce), this.vehicle.chassisBody.applyForce(p, this.forwardEquation.contactPointA) }
        }, { "../constraints/Constraint": 14, "../equations/FrictionEquation": 23, "../math/vec2": 30, "../objects/Body": 31, "../utils/Utils": 57 }],
        36: [function(t, e, i) {
            var s = e.exports = { AABB: t("./collision/AABB"), AngleLockEquation: t("./equations/AngleLockEquation"), Body: t("./objects/Body"), Broadphase: t("./collision/Broadphase"), Capsule: t("./shapes/Capsule"), Circle: t("./shapes/Circle"), Constraint: t("./constraints/Constraint"), ContactEquation: t("./equations/ContactEquation"), ContactEquationPool: t("./utils/ContactEquationPool"), ContactMaterial: t("./material/ContactMaterial"), Convex: t("./shapes/Convex"), DistanceConstraint: t("./constraints/DistanceConstraint"), Equation: t("./equations/Equation"), EventEmitter: t("./events/EventEmitter"), FrictionEquation: t("./equations/FrictionEquation"), FrictionEquationPool: t("./utils/FrictionEquationPool"), GearConstraint: t("./constraints/GearConstraint"), GSSolver: t("./solver/GSSolver"), Heightfield: t("./shapes/Heightfield"), Line: t("./shapes/Line"), LockConstraint: t("./constraints/LockConstraint"), Material: t("./material/Material"), Narrowphase: t("./collision/Narrowphase"), NaiveBroadphase: t("./collision/NaiveBroadphase"), Particle: t("./shapes/Particle"), Plane: t("./shapes/Plane"), Pool: t("./utils/Pool"), RevoluteConstraint: t("./constraints/RevoluteConstraint"), PrismaticConstraint: t("./constraints/PrismaticConstraint"), Ray: t("./collision/Ray"), RaycastResult: t("./collision/RaycastResult"), Box: t("./shapes/Box"), RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"), SAPBroadphase: t("./collision/SAPBroadphase"), Shape: t("./shapes/Shape"), Solver: t("./solver/Solver"), Spring: t("./objects/Spring"), TopDownVehicle: t("./objects/TopDownVehicle"), LinearSpring: t("./objects/LinearSpring"), RotationalSpring: t("./objects/RotationalSpring"), Utils: t("./utils/Utils"), World: t("./world/World"), vec2: t("./math/vec2"), version: t("../package.json").version };
            Object.defineProperty(s, "Rectangle", { get: function() { return this.Box } })
        }, { "../package.json": 6, "./collision/AABB": 7, "./collision/Broadphase": 8, "./collision/NaiveBroadphase": 9, "./collision/Narrowphase": 10, "./collision/Ray": 11, "./collision/RaycastResult": 12, "./collision/SAPBroadphase": 13, "./constraints/Constraint": 14, "./constraints/DistanceConstraint": 15, "./constraints/GearConstraint": 16, "./constraints/LockConstraint": 17, "./constraints/PrismaticConstraint": 18, "./constraints/RevoluteConstraint": 19, "./equations/AngleLockEquation": 20, "./equations/ContactEquation": 21, "./equations/Equation": 22, "./equations/FrictionEquation": 23, "./equations/RotationalVelocityEquation": 25, "./events/EventEmitter": 26, "./material/ContactMaterial": 27, "./material/Material": 28, "./math/vec2": 30, "./objects/Body": 31, "./objects/LinearSpring": 32, "./objects/RotationalSpring": 33, "./objects/Spring": 34, "./objects/TopDownVehicle": 35, "./shapes/Box": 37, "./shapes/Capsule": 38, "./shapes/Circle": 39, "./shapes/Convex": 40, "./shapes/Heightfield": 41, "./shapes/Line": 42, "./shapes/Particle": 43, "./shapes/Plane": 44, "./shapes/Shape": 45, "./solver/GSSolver": 46, "./solver/Solver": 47, "./utils/ContactEquationPool": 48, "./utils/FrictionEquationPool": 49, "./utils/Pool": 55, "./utils/Utils": 57, "./world/World": 61 }],
        37: [function(t, e, i) {
            var n = t("../math/vec2"),
                a = t("./Shape"),
                r = t("./Convex");

            function s(t) {
                "number" == typeof t && "number" == typeof arguments[1] && (t = { width: t, height: arguments[1] }), t = t || {};
                var e = this.width = t.width || 1,
                    i = this.height = t.height || 1,
                    s = [n.fromValues(-e / 2, -i / 2), n.fromValues(e / 2, -i / 2), n.fromValues(e / 2, i / 2), n.fromValues(-e / 2, i / 2)],
                    o = [n.fromValues(1, 0), n.fromValues(0, 1)];
                t.vertices = s, t.axes = o, t.type = a.BOX, r.call(this, t)
            }(((e.exports = s).prototype = new r).constructor = s).prototype.computeMomentOfInertia = function(t) {
                var e = this.width,
                    i = this.height;
                return t * (i * i + e * e) / 12
            }, s.prototype.updateBoundingRadius = function() {
                var t = this.width,
                    e = this.height;
                this.boundingRadius = Math.sqrt(t * t + e * e) / 2
            };
            n.create(), n.create(), n.create(), n.create();
            s.prototype.computeAABB = function(t, e, i) { t.setFromPoints(this.vertices, e, i, 0) }, s.prototype.updateArea = function() { this.area = this.width * this.height }
        }, { "../math/vec2": 30, "./Convex": 40, "./Shape": 45 }],
        38: [function(t, e, i) {
            var s = t("./Shape"),
                P = t("../math/vec2");

            function o(t) { "number" == typeof t && "number" == typeof arguments[1] && (t = { length: t, radius: arguments[1] }), t = t || {}, this.length = t.length || 1, this.radius = t.radius || 1, t.type = s.CAPSULE, s.call(this, t) }(((e.exports = o).prototype = new s).constructor = o).prototype.computeMomentOfInertia = function(t) {
                var e = this.radius,
                    i = this.length + e,
                    s = 2 * e;
                return t * (s * s + i * i) / 12
            }, o.prototype.updateBoundingRadius = function() { this.boundingRadius = this.radius + this.length / 2 }, o.prototype.updateArea = function() { this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length };
            var n = P.create();
            o.prototype.computeAABB = function(t, e, i) {
                var s = this.radius;
                P.set(n, this.length / 2, 0), 0 !== i && P.rotate(n, n, i), P.set(t.upperBound, Math.max(n[0] + s, -n[0] + s), Math.max(n[1] + s, -n[1] + s)), P.set(t.lowerBound, Math.min(n[0] - s, -n[0] - s), Math.min(n[1] - s, -n[1] - s)), P.add(t.lowerBound, t.lowerBound, e), P.add(t.upperBound, t.upperBound, e)
            };
            var _ = P.create(),
                T = P.create(),
                S = P.create(),
                k = P.create(),
                B = P.fromValues(0, 1);
            o.prototype.raycast = function(t, e, i, s) {
                for (var o = e.from, n = e.to, a = (e.direction, _), r = T, h = S, l = k, c = this.length / 2, p = 0; p < 2; p++) { var u = this.radius * (2 * p - 1); if (P.set(h, -c, u), P.set(l, c, u), P.toGlobalFrame(h, h, i, s), P.toGlobalFrame(l, l, i, s), 0 <= (y = P.getLineSegmentsIntersectionFraction(o, n, h, l)) && (P.rotate(r, B, s), P.scale(r, r, 2 * p - 1), e.reportIntersection(t, y, r, -1), t.shouldStop(e))) return }
                var d = Math.pow(this.radius, 2) + Math.pow(c, 2);
                for (p = 0; p < 2; p++) {
                    P.set(h, c * (2 * p - 1), 0), P.toGlobalFrame(h, h, i, s);
                    var y, g = Math.pow(n[0] - o[0], 2) + Math.pow(n[1] - o[1], 2),
                        f = 2 * ((n[0] - o[0]) * (o[0] - h[0]) + (n[1] - o[1]) * (o[1] - h[1])),
                        m = Math.pow(o[0] - h[0], 2) + Math.pow(o[1] - h[1], 2) - Math.pow(this.radius, 2);
                    if (!((y = Math.pow(f, 2) - 4 * g * m) < 0))
                        if (0 === y) { if (P.lerp(a, o, n, y), P.squaredDistance(a, i) > d && (P.sub(r, a, h), P.normalize(r, r), e.reportIntersection(t, y, r, -1), t.shouldStop(e))) return }
                    else {
                        var v = Math.sqrt(y),
                            x = 1 / (2 * g),
                            b = (-f - v) * x,
                            w = (-f + v) * x;
                        if (0 <= b && b <= 1 && (P.lerp(a, o, n, b), P.squaredDistance(a, i) > d && (P.sub(r, a, h), P.normalize(r, r), e.reportIntersection(t, b, r, -1), t.shouldStop(e)))) return;
                        if (0 <= w && w <= 1 && (P.lerp(a, o, n, w), P.squaredDistance(a, i) > d && (P.sub(r, a, h), P.normalize(r, r), e.reportIntersection(t, w, r, -1), t.shouldStop(e)))) return
                    }
                }
            }
        }, { "../math/vec2": 30, "./Shape": 45 }],
        39: [function(t, e, i) {
            var s = t("./Shape"),
                m = t("../math/vec2");

            function o(t) { "number" == typeof t && (t = { radius: t }), t = t || {}, this.radius = t.radius || 1, t.type = s.CIRCLE, s.call(this, t) }(((e.exports = o).prototype = new s).constructor = o).prototype.computeMomentOfInertia = function(t) { var e = this.radius; return t * e * e / 2 }, o.prototype.updateBoundingRadius = function() { this.boundingRadius = this.radius }, o.prototype.updateArea = function() { this.area = Math.PI * this.radius * this.radius }, o.prototype.computeAABB = function(t, e, i) {
                var s = this.radius;
                m.set(t.upperBound, s, s), m.set(t.lowerBound, -s, -s), e && (m.add(t.lowerBound, t.lowerBound, e), m.add(t.upperBound, t.upperBound, e))
            };
            var v = m.create(),
                x = m.create();
            o.prototype.raycast = function(t, e, i, s) {
                var o = e.from,
                    n = e.to,
                    a = this.radius,
                    r = Math.pow(n[0] - o[0], 2) + Math.pow(n[1] - o[1], 2),
                    h = 2 * ((n[0] - o[0]) * (o[0] - i[0]) + (n[1] - o[1]) * (o[1] - i[1])),
                    l = Math.pow(o[0] - i[0], 2) + Math.pow(o[1] - i[1], 2) - Math.pow(a, 2),
                    c = Math.pow(h, 2) - 4 * r * l,
                    p = v,
                    u = x;
                if (!(c < 0))
                    if (0 === c) m.lerp(p, o, n, c), m.sub(u, p, i), m.normalize(u, u), e.reportIntersection(t, c, u, -1);
                    else {
                        var d = Math.sqrt(c),
                            y = 1 / (2 * r),
                            g = (-h - d) * y,
                            f = (-h + d) * y;
                        if (0 <= g && g <= 1 && (m.lerp(p, o, n, g), m.sub(u, p, i), m.normalize(u, u), e.reportIntersection(t, g, u, -1), t.shouldStop(e))) return;
                        0 <= f && f <= 1 && (m.lerp(p, o, n, f), m.sub(u, p, i), m.normalize(u, u), e.reportIntersection(t, f, u, -1))
                    }
            }
        }, { "../math/vec2": 30, "./Shape": 45 }],
        40: [function(t, e, i) {
            var h = t("./Shape"),
                d = t("../math/vec2"),
                r = t("../math/polyk");
            t("poly-decomp");

            function u(t) {
                Array.isArray(t) && (t = { vertices: t, axes: arguments[1] }), t = t || {}, this.vertices = [];
                for (var e = void 0 !== t.vertices ? t.vertices : [], i = 0; i < e.length; i++) {
                    var s = d.create();
                    d.copy(s, e[i]), this.vertices.push(s)
                }
                if (this.axes = [], t.axes)
                    for (i = 0; i < t.axes.length; i++) {
                        var o = d.create();
                        d.copy(o, t.axes[i]), this.axes.push(o)
                    }
                else
                    for (i = 0; i < this.vertices.length; i++) {
                        var n = this.vertices[i],
                            a = this.vertices[(i + 1) % this.vertices.length],
                            r = d.create();
                        d.sub(r, a, n), d.rotate90cw(r, r), d.normalize(r, r), this.axes.push(r)
                    }
                if (this.centerOfMass = d.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, t.type = h.CONVEX, h.call(this, t), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
            }((e.exports = u).prototype = new h).constructor = u;
            var l = d.create(),
                a = d.create();
            u.prototype.projectOntoLocalAxis = function(t, e) {
                for (var i, s, o = null, n = null, a = (t = l, 0); a < this.vertices.length; a++) i = this.vertices[a], s = d.dot(i, t), (null === o || o < s) && (o = s), (null === n || s < n) && (n = s);
                if (o < n) {
                    var r = n;
                    n = o, o = r
                }
                d.set(e, n, o)
            }, u.prototype.projectOntoWorldAxis = function(t, e, i, s) {
                var o = a;
                this.projectOntoLocalAxis(t, s), 0 !== i ? d.rotate(o, t, i) : o = t;
                var n = d.dot(e, o);
                d.set(s, s[0] + n, s[1] + n)
            }, u.prototype.updateTriangles = function() {
                for (var t = [], e = this.triangles.length = 0; e < this.vertices.length; e++) {
                    var i = this.vertices[e];
                    t.push(i[0], i[1])
                }
                var s = r.Triangulate(t);
                for (e = 0; e < s.length; e += 3) {
                    var o = s[e],
                        n = s[e + 1],
                        a = s[e + 2];
                    this.triangles.push([o, n, a])
                }
            };
            var y = d.create(),
                g = d.create(),
                f = d.create(),
                m = d.create(),
                v = d.create();
            d.create(), d.create(), d.create(), d.create();
            u.prototype.updateCenterOfMass = function() {
                var t = this.triangles,
                    e = this.vertices,
                    i = this.centerOfMass,
                    s = y,
                    o = f,
                    n = m,
                    a = v,
                    r = g;
                d.set(i, 0, 0);
                for (var h = 0, l = 0; l !== t.length; l++) {
                    var c = t[l];
                    o = e[c[0]], n = e[c[1]], a = e[c[2]];
                    d.centroid(s, o, n, a);
                    var p = u.triangleArea(o, n, a);
                    h += p, d.scale(r, s, p), d.add(i, i, r)
                }
                d.scale(i, i, 1 / h)
            }, u.prototype.computeMomentOfInertia = function(t) {
                for (var e = 0, i = 0, s = this.vertices.length, o = s - 1, n = 0; n < s; o = n, n++) {
                    var a = this.vertices[o],
                        r = this.vertices[n],
                        h = Math.abs(d.crossLength(a, r));
                    e += h * (d.dot(r, r) + d.dot(r, a) + d.dot(a, a)), i += h
                }
                return t / 6 * (e / i)
            }, u.prototype.updateBoundingRadius = function() {
                for (var t = this.vertices, e = 0, i = 0; i !== t.length; i++) {
                    var s = d.squaredLength(t[i]);
                    e < s && (e = s)
                }
                this.boundingRadius = Math.sqrt(e)
            }, u.triangleArea = function(t, e, i) { return .5 * ((e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1])) }, u.prototype.updateArea = function() {
                this.updateTriangles(), this.area = 0;
                for (var t = this.triangles, e = this.vertices, i = 0; i !== t.length; i++) {
                    var s = t[i],
                        o = e[s[0]],
                        n = e[s[1]],
                        a = e[s[2]],
                        r = u.triangleArea(o, n, a);
                    this.area += r
                }
            }, u.prototype.computeAABB = function(t, e, i) { t.setFromPoints(this.vertices, e, i, 0) };
            var x = d.create(),
                b = d.create(),
                w = d.create();
            u.prototype.raycast = function(t, e, i, s) {
                var o = x,
                    n = b,
                    a = w,
                    r = this.vertices;
                d.toLocalFrame(o, e.from, i, s), d.toLocalFrame(n, e.to, i, s);
                for (var h = r.length, l = 0; l < h && !t.shouldStop(e); l++) {
                    var c = r[l],
                        p = r[(l + 1) % h],
                        u = d.getLineSegmentsIntersectionFraction(o, n, c, p);
                    0 <= u && (d.sub(a, p, c), d.rotate(a, a, -Math.PI / 2 + s), d.normalize(a, a), e.reportIntersection(t, u, a, l))
                }
            }
        }, { "../math/polyk": 29, "../math/vec2": 30, "./Shape": 45, "poly-decomp": 5 }],
        41: [function(t, e, i) {
            var s = t("./Shape"),
                f = t("../math/vec2");
            t("../utils/Utils");

            function o(t) {
                if (Array.isArray(t) && (t = { heights: t }, "object" == typeof arguments[1]))
                    for (var e in arguments[1]) t[e] = arguments[1][e];
                t = t || {}, this.heights = t.heights ? t.heights.slice(0) : [], this.maxValue = t.maxValue || null, this.minValue = t.minValue || null, this.elementWidth = t.elementWidth || .1, void 0 !== t.maxValue && void 0 !== t.minValue || this.updateMaxMinValues(), t.type = s.HEIGHTFIELD, s.call(this, t)
            }(((e.exports = o).prototype = new s).constructor = o).prototype.updateMaxMinValues = function() {
                for (var t = this.heights, e = t[0], i = t[0], s = 0; s !== t.length; s++) {
                    var o = t[s];
                    e < o && (e = o), o < i && (i = o)
                }
                this.maxValue = e, this.minValue = i
            }, o.prototype.computeMomentOfInertia = function(t) { return Number.MAX_VALUE }, o.prototype.updateBoundingRadius = function() { this.boundingRadius = Number.MAX_VALUE }, o.prototype.updateArea = function() {
                for (var t = this.heights, e = 0, i = 0; i < t.length - 1; i++) e += (t[i] + t[i + 1]) / 2 * this.elementWidth;
                this.area = e
            };
            var n = [f.create(), f.create(), f.create(), f.create()];
            o.prototype.computeAABB = function(t, e, i) { f.set(n[0], 0, this.maxValue), f.set(n[1], this.elementWidth * this.heights.length, this.maxValue), f.set(n[2], this.elementWidth * this.heights.length, this.minValue), f.set(n[3], 0, this.minValue), t.setFromPoints(n, e, i) }, o.prototype.getLineSegment = function(t, e, i) {
                var s = this.heights,
                    o = this.elementWidth;
                f.set(t, i * o, s[i]), f.set(e, (i + 1) * o, s[i + 1])
            }, o.prototype.getSegmentIndex = function(t) { return Math.floor(t[0] / this.elementWidth) }, o.prototype.getClampedSegmentIndex = function(t) { var e = this.getSegmentIndex(t); return e = Math.min(this.heights.length, Math.max(e, 0)) };
            f.create();
            var m = f.create(),
                v = f.create(),
                x = f.create(),
                b = f.create(),
                w = f.create();
            f.fromValues(0, 1);
            o.prototype.raycast = function(t, e, i, s) {
                var o = e.from,
                    n = e.to,
                    a = (e.direction, m),
                    r = v,
                    h = x,
                    l = b,
                    c = w;
                f.toLocalFrame(l, o, i, s), f.toLocalFrame(c, n, i, s);
                var p = this.getClampedSegmentIndex(l),
                    u = this.getClampedSegmentIndex(c);
                if (u < p) {
                    var d = p;
                    p = u, u = d
                }
                for (var y = 0; y < this.heights.length - 1; y++) { this.getLineSegment(r, h, y); var g = f.getLineSegmentsIntersectionFraction(l, c, r, h); if (0 <= g && (f.sub(a, h, r), f.rotate(a, a, s + Math.PI / 2), f.normalize(a, a), e.reportIntersection(t, g, a, -1), t.shouldStop(e))) return }
            }
        }, { "../math/vec2": 30, "../utils/Utils": 57, "./Shape": 45 }],
        42: [function(t, e, i) {
            var s = t("./Shape"),
                p = t("../math/vec2");

            function o(t) { "number" == typeof t && (t = { length: t }), t = t || {}, this.length = t.length || 1, t.type = s.LINE, s.call(this, t) }(((e.exports = o).prototype = new s).constructor = o).prototype.computeMomentOfInertia = function(t) { return t * Math.pow(this.length, 2) / 12 }, o.prototype.updateBoundingRadius = function() { this.boundingRadius = this.length / 2 };
            var n = [p.create(), p.create()];
            o.prototype.computeAABB = function(t, e, i) {
                var s = this.length / 2;
                p.set(n[0], -s, 0), p.set(n[1], s, 0), t.setFromPoints(n, e, i, 0)
            };
            p.create();
            var u = p.create(),
                d = p.create(),
                y = p.create(),
                g = p.fromValues(0, 1);
            o.prototype.raycast = function(t, e, i, s) {
                var o = e.from,
                    n = e.to,
                    a = d,
                    r = y,
                    h = this.length / 2;
                p.set(a, -h, 0), p.set(r, h, 0), p.toGlobalFrame(a, a, i, s), p.toGlobalFrame(r, r, i, s);
                var l = p.getLineSegmentsIntersectionFraction(a, r, o, n);
                if (0 <= l) {
                    var c = u;
                    p.rotate(c, g, s), e.reportIntersection(t, l, c, -1)
                }
            }
        }, { "../math/vec2": 30, "./Shape": 45 }],
        43: [function(t, e, i) {
            var s = t("./Shape"),
                o = t("../math/vec2");

            function n(t) {
                (t = t || {}).type = s.PARTICLE, s.call(this, t)
            }(((e.exports = n).prototype = new s).constructor = n).prototype.computeMomentOfInertia = function(t) { return 0 }, n.prototype.updateBoundingRadius = function() { this.boundingRadius = 0 }, n.prototype.computeAABB = function(t, e, i) { o.copy(t.lowerBound, e), o.copy(t.upperBound, e) }
        }, { "../math/vec2": 30, "./Shape": 45 }],
        44: [function(t, e, i) {
            var s = t("./Shape"),
                d = t("../math/vec2");
            t("../utils/Utils");

            function o(t) {
                (t = t || {}).type = s.PLANE, s.call(this, t)
            }(((e.exports = o).prototype = new s).constructor = o).prototype.computeMomentOfInertia = function(t) { return 0 }, o.prototype.updateBoundingRadius = function() { this.boundingRadius = Number.MAX_VALUE }, o.prototype.computeAABB = function(t, e, i) {
                var s = i % (2 * Math.PI),
                    o = d.set,
                    n = Number.MAX_VALUE,
                    a = t.lowerBound,
                    r = t.upperBound;
                0 === s ? (o(a, -n, -n), o(r, n, 0)) : s === Math.PI / 2 ? (o(a, 0, -n), o(r, n, n)) : s === Math.PI ? (o(a, -n, 0), o(r, n, n)) : s === 3 * Math.PI / 2 ? (o(a, -n, -n), o(r, 0, n)) : (o(a, -n, -n), o(r, n, n)), d.add(a, a, e), d.add(r, r, e)
            }, o.prototype.updateArea = function() { this.area = Number.MAX_VALUE };
            var y = d.create(),
                g = (d.create(), d.create(), d.create()),
                f = d.create();
            o.prototype.raycast = function(t, e, i, s) {
                var o = e.from,
                    n = e.to,
                    a = e.direction,
                    r = y,
                    h = g,
                    l = f;
                d.set(h, 0, 1), d.rotate(h, h, s), d.sub(l, o, i);
                var c = d.dot(l, h);
                if (d.sub(l, n, i), !(0 < c * d.dot(l, h) || d.squaredDistance(o, n) < c * c)) {
                    var p = d.dot(h, a);
                    d.sub(r, o, i);
                    var u = -d.dot(h, r) / p / e.length;
                    e.reportIntersection(t, u, h, -1)
                }
            }
        }, { "../math/vec2": 30, "../utils/Utils": 57, "./Shape": 45 }],
        45: [function(t, e, i) {
            e.exports = o;
            var s = t("../math/vec2");

            function o(t) { t = t || {}, this.body = null, this.position = s.fromValues(0, 0), t.position && s.copy(this.position, t.position), this.angle = t.angle || 0, this.type = t.type || 0, this.id = o.idCounter++, this.boundingRadius = 0, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : 1, this.material = t.material || null, this.area = 0, this.sensor = void 0 !== t.sensor && t.sensor, this.type && this.updateBoundingRadius(), this.updateArea() } o.idCounter = 0, o.CIRCLE = 1, o.PARTICLE = 2, o.PLANE = 4, o.CONVEX = 8, o.LINE = 16, o.BOX = 32, Object.defineProperty(o, "RECTANGLE", { get: function() { return o.BOX } }), o.CAPSULE = 64, o.HEIGHTFIELD = 128, o.prototype.computeMomentOfInertia = function(t) {}, o.prototype.updateBoundingRadius = function() {}, o.prototype.updateArea = function() {}, o.prototype.computeAABB = function(t, e, i) {}, o.prototype.raycast = function(t, e, i, s) {}
        }, { "../math/vec2": 30 }],
        46: [function(t, e, i) {
            var P = t("../math/vec2"),
                s = t("./Solver"),
                _ = t("../utils/Utils"),
                T = t("../equations/FrictionEquation");

            function S(t) { s.call(this, t, s.GS), t = t || {}, this.iterations = t.iterations || 10, this.tolerance = t.tolerance || 1e-7, this.arrayStep = 30, this.lambda = new _.ARRAY_TYPE(this.arrayStep), this.Bs = new _.ARRAY_TYPE(this.arrayStep), this.invCs = new _.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = 0, this.usedIterations = 0 }(((e.exports = S).prototype = new s).constructor = S).prototype.solve = function(t, e) {
                this.sortEquations();
                var i = 0,
                    s = this.iterations,
                    o = this.frictionIterations,
                    n = this.equations,
                    a = n.length,
                    r = Math.pow(this.tolerance * a, 2),
                    h = e.bodies,
                    l = e.bodies.length,
                    c = (P.add, P.set, this.useZeroRHS),
                    p = this.lambda;
                if (this.usedIterations = 0, a)
                    for (var u = 0; u !== l; u++) { h[u].updateSolveMassProperties() } p.length < a && (p = this.lambda = new _.ARRAY_TYPE(a + this.arrayStep), this.Bs = new _.ARRAY_TYPE(a + this.arrayStep), this.invCs = new _.ARRAY_TYPE(a + this.arrayStep)),
                    function(t) { for (var e = t.length; e--;) t[e] = 0 }(p);
                var d, y, g = this.invCs,
                    f = this.Bs;
                for (p = this.lambda, u = 0; u !== n.length; u++) {
                    var m;
                    ((m = n[u]).timeStep !== t || m.needsUpdate) && (m.timeStep = t, m.update()), f[u] = m.computeB(m.a, m.b, t), g[u] = m.computeInvC(m.epsilon)
                }
                if (0 !== a) {
                    for (u = 0; u !== l; u++) { h[u].resetConstraintVelocity() }
                    if (o) {
                        for (i = 0; i !== o; i++) {
                            for (y = d = 0; y !== a; y++) {
                                m = n[y];
                                var v = S.iterateEquation(y, m, m.epsilon, f, g, p, c, t, i);
                                d += Math.abs(v)
                            }
                            if (this.usedIterations++, d * d <= r) break
                        }
                        for (S.updateMultipliers(n, p, 1 / t), y = 0; y !== a; y++) {
                            var x = n[y];
                            if (x instanceof T) {
                                for (var b = 0, w = 0; w !== x.contactEquations.length; w++) b += x.contactEquations[w].multiplier;
                                b *= x.frictionCoefficient / x.contactEquations.length, x.maxForce = b, x.minForce = -b
                            }
                        }
                    }
                    for (i = 0; i !== s; i++) {
                        for (y = d = 0; y !== a; y++) {
                            m = n[y];
                            v = S.iterateEquation(y, m, m.epsilon, f, g, p, c, t, i);
                            d += Math.abs(v)
                        }
                        if (this.usedIterations++, d * d <= r) break
                    }
                    for (u = 0; u !== l; u++) h[u].addConstraintVelocity();
                    S.updateMultipliers(n, p, 1 / t)
                }
            }, S.updateMultipliers = function(t, e, i) { for (var s = t.length; s--;) t[s].multiplier = e[s] * i }, S.iterateEquation = function(t, e, i, s, o, n, a, r, h) {
                var l = s[t],
                    c = o[t],
                    p = n[t],
                    u = e.computeGWlambda(),
                    d = e.maxForce,
                    y = e.minForce;
                a && (l = 0);
                var g = c * (l - u - i * p),
                    f = p + g;
                return f < y * r ? g = y * r - p : d * r < f && (g = d * r - p), n[t] += g, e.addToWlambda(g), g
            }
        }, { "../equations/FrictionEquation": 23, "../math/vec2": 30, "../utils/Utils": 57, "./Solver": 47 }],
        47: [function(t, e, i) {
            t("../utils/Utils");
            var s = t("../events/EventEmitter");

            function o(t, e) { t = t || {}, s.call(this), this.type = e, this.equations = [], this.equationSortFunction = t.equationSortFunction || !1 }(((e.exports = o).prototype = new s).constructor = o).prototype.solve = function(t, e) { throw new Error("Solver.solve should be implemented by subclasses!") };
            var n = { bodies: [] };
            o.prototype.solveIsland = function(t, e) { this.removeAllEquations(), e.equations.length && (this.addEquations(e.equations), n.bodies.length = 0, e.getBodies(n.bodies), n.bodies.length && this.solve(t, n)) }, o.prototype.sortEquations = function() { this.equationSortFunction && this.equations.sort(this.equationSortFunction) }, o.prototype.addEquation = function(t) { t.enabled && this.equations.push(t) }, o.prototype.addEquations = function(t) {
                for (var e = 0, i = t.length; e !== i; e++) {
                    var s = t[e];
                    s.enabled && this.equations.push(s)
                }
            }, o.prototype.removeEquation = function(t) { var e = this.equations.indexOf(t); - 1 !== e && this.equations.splice(e, 1) }, o.prototype.removeAllEquations = function() { this.equations.length = 0 }, o.GS = 1, o.ISLAND = 2
        }, { "../events/EventEmitter": 26, "../utils/Utils": 57 }],
        48: [function(t, e, i) {
            var s = t("../equations/ContactEquation"),
                o = t("./Pool");

            function n() { o.apply(this, arguments) }(((e.exports = n).prototype = new o).constructor = n).prototype.create = function() { return new s }, n.prototype.destroy = function(t) { return t.bodyA = t.bodyB = null, this }
        }, { "../equations/ContactEquation": 21, "./Pool": 55 }],
        49: [function(t, e, i) {
            var s = t("../equations/FrictionEquation"),
                o = t("./Pool");

            function n() { o.apply(this, arguments) }(((e.exports = n).prototype = new o).constructor = n).prototype.create = function() { return new s }, n.prototype.destroy = function(t) { return t.bodyA = t.bodyB = null, this }
        }, { "../equations/FrictionEquation": 23, "./Pool": 55 }],
        50: [function(t, e, i) {
            var s = t("../world/IslandNode"),
                o = t("./Pool");

            function n() { o.apply(this, arguments) }(((e.exports = n).prototype = new o).constructor = n).prototype.create = function() { return new s }, n.prototype.destroy = function(t) { return t.reset(), this }
        }, { "../world/IslandNode": 60, "./Pool": 55 }],
        51: [function(t, e, i) {
            var s = t("../world/Island"),
                o = t("./Pool");

            function n() { o.apply(this, arguments) }(((e.exports = n).prototype = new o).constructor = n).prototype.create = function() { return new s }, n.prototype.destroy = function(t) { return t.reset(), this }
        }, { "../world/Island": 58, "./Pool": 55 }],
        52: [function(t, e, i) {
            var s = t("./TupleDictionary"),
                o = (t("./OverlapKeeperRecord"), t("./OverlapKeeperRecordPool"));
            t("./Utils");

            function n() { this.overlappingShapesLastState = new s, this.overlappingShapesCurrentState = new s, this.recordPool = new o({ size: 16 }), this.tmpDict = new s, this.tmpArray1 = [] }(e.exports = n).prototype.tick = function() {
                for (var t = this.overlappingShapesLastState, e = this.overlappingShapesCurrentState, i = t.keys.length; i--;) {
                    var s = t.keys[i],
                        o = t.getByKey(s);
                    e.getByKey(s);
                    o && this.recordPool.release(o)
                }
                t.reset(), t.copy(e), e.reset()
            }, n.prototype.setOverlapping = function(t, e, i, s) {
                this.overlappingShapesLastState;
                var o = this.overlappingShapesCurrentState;
                if (!o.get(e.id, s.id)) {
                    var n = this.recordPool.get();
                    n.set(t, e, i, s), o.set(e.id, s.id, n)
                }
            }, n.prototype.getNewOverlaps = function(t) { return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, t) }, n.prototype.getEndOverlaps = function(t) { return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, t) }, n.prototype.bodiesAreOverlapping = function(t, e) {
                for (var i = this.overlappingShapesCurrentState, s = i.keys.length; s--;) {
                    var o = i.keys[s],
                        n = i.data[o];
                    if (n.bodyA === t && n.bodyB === e || n.bodyA === e && n.bodyB === t) return !0
                }
                return !1
            }, n.prototype.getDiff = function(t, e, i) {
                var s = t,
                    o = e;
                (i = i || []).length = 0;
                for (var n = o.keys.length; n--;) {
                    var a = o.keys[n],
                        r = o.data[a];
                    if (!r) throw new Error("Key " + a + " had no data!");
                    s.data[a] || i.push(r)
                }
                return i
            }, n.prototype.isNewOverlap = function(t, e) {
                var i = 0 | t.id,
                    s = 0 | e.id,
                    o = this.overlappingShapesLastState,
                    n = this.overlappingShapesCurrentState;
                return !o.get(i, s) && !!n.get(i, s)
            }, n.prototype.getNewBodyOverlaps = function(t) { this.tmpArray1.length = 0; var e = this.getNewOverlaps(this.tmpArray1); return this.getBodyDiff(e, t) }, n.prototype.getEndBodyOverlaps = function(t) { this.tmpArray1.length = 0; var e = this.getEndOverlaps(this.tmpArray1); return this.getBodyDiff(e, t) }, n.prototype.getBodyDiff = function(t, e) {
                e = e || [];
                for (var i = this.tmpDict, s = t.length; s--;) {
                    var o = t[s];
                    i.set(0 | o.bodyA.id, 0 | o.bodyB.id, o)
                }
                for (s = i.keys.length; s--;) {
                    (o = i.getByKey(i.keys[s])) && e.push(o.bodyA, o.bodyB)
                }
                return i.reset(), e
            }
        }, { "./OverlapKeeperRecord": 53, "./OverlapKeeperRecordPool": 54, "./TupleDictionary": 56, "./Utils": 57 }],
        53: [function(t, e, i) {
            function o(t, e, i, s) { this.shapeA = e, this.shapeB = s, this.bodyA = t, this.bodyB = i }(e.exports = o).prototype.set = function(t, e, i, s) { o.call(this, t, e, i, s) }
        }, {}],
        54: [function(t, e, i) {
            var s = t("./OverlapKeeperRecord"),
                o = t("./Pool");

            function n() { o.apply(this, arguments) }(((e.exports = n).prototype = new o).constructor = n).prototype.create = function() { return new s }, n.prototype.destroy = function(t) { return t.bodyA = t.bodyB = t.shapeA = t.shapeB = null, this }
        }, { "./OverlapKeeperRecord": 53, "./Pool": 55 }],
        55: [function(t, e, i) {
            function s(t) { t = t || {}, this.objects = [], void 0 !== t.size && this.resize(t.size) }(e.exports = s).prototype.resize = function(t) { for (var e = this.objects; e.length > t;) e.pop(); for (; e.length < t;) e.push(this.create()); return this }, s.prototype.get = function() { var t = this.objects; return t.length ? t.pop() : this.create() }, s.prototype.release = function(t) { return this.destroy(t), this.objects.push(t), this }
        }, {}],
        56: [function(t, e, i) {
            var s = t("./Utils");

            function o() { this.data = {}, this.keys = [] }(e.exports = o).prototype.getKey = function(t, e) { return (0 | (t |= 0)) == (0 | (e |= 0)) ? -1 : 0 | ((0 | e) < (0 | t) ? t << 16 | 65535 & e : e << 16 | 65535 & t) }, o.prototype.getByKey = function(t) { return t |= 0, this.data[t] }, o.prototype.get = function(t, e) { return this.data[this.getKey(t, e)] }, o.prototype.set = function(t, e, i) { if (!i) throw new Error("No data!"); var s = this.getKey(t, e); return this.data[s] || this.keys.push(s), this.data[s] = i, s }, o.prototype.reset = function() {
                for (var t = this.data, e = this.keys, i = e.length; i--;) delete t[e[i]];
                e.length = 0
            }, o.prototype.copy = function(t) {
                this.reset(), s.appendArray(this.keys, t.keys);
                for (var e = t.keys.length; e--;) {
                    var i = t.keys[e];
                    this.data[i] = t.data[i]
                }
            }
        }, { "./Utils": 57 }],
        57: [function(t, e, i) {
            function s() {}(e.exports = s).appendArray = function(t, e) {
                if (e.length < 15e4) t.push.apply(t, e);
                else
                    for (var i = 0, s = e.length; i !== s; ++i) t.push(e[i])
            }, s.splice = function(t, e, i) {
                i = i || 1;
                for (var s = e, o = t.length - i; s < o; s++) t[s] = t[s + i];
                t.length = o
            }, s.ARRAY_TYPE = "undefined" != typeof P2_ARRAY_TYPE ? P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? Float32Array : Array, s.extend = function(t, e) { for (var i in e) t[i] = e[i] }, s.defaults = function(t, e) { for (var i in t = t || {}, e) i in t || (t[i] = e[i]); return t }
        }, {}],
        58: [function(t, e, i) {
            var s = t("../objects/Body");

            function o() { this.equations = [], this.bodies = [] }(e.exports = o).prototype.reset = function() { this.equations.length = this.bodies.length = 0 };
            var n = [];
            o.prototype.getBodies = function(t) { for (var e = t || [], i = this.equations, s = n.length = 0; s !== i.length; s++) { var o = i[s]; - 1 === n.indexOf(o.bodyA.id) && (e.push(o.bodyA), n.push(o.bodyA.id)), -1 === n.indexOf(o.bodyB.id) && (e.push(o.bodyB), n.push(o.bodyB.id)) } return e }, o.prototype.wantsToSleep = function() { for (var t = 0; t < this.bodies.length; t++) { var e = this.bodies[t]; if (e.type === s.DYNAMIC && !e.wantsToSleep) return !1 } return !0 }, o.prototype.sleep = function() { for (var t = 0; t < this.bodies.length; t++) { this.bodies[t].sleep() } return !0 }
        }, { "../objects/Body": 31 }],
        59: [function(t, e, i) {
            t("../math/vec2"), t("./Island"), t("./IslandNode");
            var s = t("./../utils/IslandNodePool"),
                o = t("./../utils/IslandPool"),
                a = t("../objects/Body");

            function y(t) { this.nodePool = new s({ size: 16 }), this.islandPool = new o({ size: 8 }), this.equations = [], this.islands = [], this.nodes = [], this.queue = [] }(e.exports = y).getUnvisitedNode = function(t) { for (var e = t.length, i = 0; i !== e; i++) { var s = t[i]; if (!s.visited && s.body.type === a.DYNAMIC) return s } return !1 }, y.prototype.visit = function(t, e, i) { e.push(t.body); for (var s = t.equations.length, o = 0; o !== s; o++) { var n = t.equations[o]; - 1 === i.indexOf(n) && i.push(n) } }, y.prototype.bfs = function(t, e, i) {
                var s = this.queue;
                for (s.length = 0, s.push(t), t.visited = !0, this.visit(t, e, i); s.length;)
                    for (var o, n = s.pop(); o = y.getUnvisitedNode(n.neighbors);) o.visited = !0, this.visit(o, e, i), o.body.type === a.DYNAMIC && s.push(o)
            }, y.prototype.split = function(t) {
                for (var e = t.bodies, i = this.nodes, s = this.equations; i.length;) this.nodePool.release(i.pop());
                for (var o = 0; o !== e.length; o++) {
                    var n = this.nodePool.get();
                    n.body = e[o], i.push(n)
                }
                for (var a = 0; a !== s.length; a++) {
                    var r = s[a],
                        h = (o = e.indexOf(r.bodyA), e.indexOf(r.bodyB)),
                        l = i[o],
                        c = i[h];
                    l.neighbors.push(c), c.neighbors.push(l), l.equations.push(r), c.equations.push(r)
                }
                var p, u = this.islands;
                for (o = 0; o < u.length; o++) this.islandPool.release(u[o]);
                for (u.length = 0; p = y.getUnvisitedNode(i);) {
                    var d = this.islandPool.get();
                    this.bfs(p, d.bodies, d.equations), u.push(d)
                }
                return u
            }
        }, { "../math/vec2": 30, "../objects/Body": 31, "./../utils/IslandNodePool": 50, "./../utils/IslandPool": 51, "./Island": 58, "./IslandNode": 60 }],
        60: [function(t, e, i) {
            function s(t) { this.body = t, this.neighbors = [], this.equations = [], this.visited = !1 }(e.exports = s).prototype.reset = function() { this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null }
        }, {}],
        61: [function(t, e, i) {
            var s = t("../solver/GSSolver"),
                j = (t("../solver/Solver"), t("../collision/Ray"), t("../math/vec2")),
                m = t("../shapes/Circle"),
                v = t("../shapes/Convex"),
                x = (t("../shapes/Line"), t("../shapes/Plane")),
                b = t("../shapes/Capsule"),
                w = t("../shapes/Particle"),
                o = t("../events/EventEmitter"),
                W = t("../objects/Body"),
                n = (t("../shapes/Shape"), t("../objects/LinearSpring"), t("../material/Material")),
                a = t("../material/ContactMaterial"),
                r = (t("../constraints/DistanceConstraint"), t("../constraints/Constraint"), t("../constraints/LockConstraint"), t("../constraints/RevoluteConstraint"), t("../constraints/PrismaticConstraint"), t("../constraints/GearConstraint"), t("../../package.json"), t("../collision/Broadphase"), t("../collision/AABB")),
                h = t("../collision/SAPBroadphase"),
                l = t("../collision/Narrowphase"),
                q = t("../utils/Utils"),
                c = t("../utils/OverlapKeeper"),
                p = t("./IslandManager");
            t("../objects/RotationalSpring");

            function Y(t) { o.apply(this), t = t || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = t.solver || new s, this.narrowphase = new l(this), this.islandManager = new p, this.gravity = j.fromValues(0, -9.78), t.gravity && j.copy(this.gravity, t.gravity), this.frictionGravity = j.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.broadphase = t.broadphase || new h, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new n, this.defaultContactMaterial = new a(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.islandSplit = void 0 === t.islandSplit || !!t.islandSplit, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = { type: "postStep" }, this.addBodyEvent = { type: "addBody", body: null }, this.removeBodyEvent = { type: "removeBody", body: null }, this.addSpringEvent = { type: "addSpring", spring: null }, this.impactEvent = { type: "impact", bodyA: null, bodyB: null, shapeA: null, shapeB: null, contactEquation: null }, this.postBroadphaseEvent = { type: "postBroadphase", pairs: null }, this.sleepMode = Y.NO_SLEEPING, this.beginContactEvent = { type: "beginContact", shapeA: null, shapeB: null, bodyA: null, bodyB: null, contactEquations: [] }, this.endContactEvent = { type: "endContact", shapeA: null, shapeB: null, bodyA: null, bodyB: null }, this.preSolveEvent = { type: "preSolve", contactEquations: null, frictionEquations: null }, this.overlappingShapesLastState = { keys: [] }, this.overlappingShapesCurrentState = { keys: [] }, this.overlapKeeper = new c }(((e.exports = Y).prototype = new Object(o.prototype)).constructor = Y).NO_SLEEPING = 1, Y.BODY_SLEEPING = 2, Y.ISLAND_SLEEPING = 4, Y.prototype.addConstraint = function(t) { this.constraints.push(t) }, Y.prototype.addContactMaterial = function(t) { this.contactMaterials.push(t) }, Y.prototype.removeContactMaterial = function(t) { var e = this.contactMaterials.indexOf(t); - 1 !== e && q.splice(this.contactMaterials, e, 1) }, Y.prototype.getContactMaterial = function(t, e) { for (var i = this.contactMaterials, s = 0, o = i.length; s !== o; s++) { var n = i[s]; if (n.materialA.id === t.id && n.materialB.id === e.id || n.materialA.id === e.id && n.materialB.id === t.id) return n } return !1 }, Y.prototype.removeConstraint = function(t) { var e = this.constraints.indexOf(t); - 1 !== e && q.splice(this.constraints, e, 1) };
            j.create(), j.create(), j.create(), j.create(), j.create(), j.create();
            var K = j.create(),
                T = j.fromValues(0, 0),
                S = j.fromValues(0, 0);
            j.fromValues(0, 0), j.fromValues(0, 0);
            Y.prototype.step = function(t, e, i) {
                if (i = i || 10, 0 === (e = e || 0)) this.internalStep(t), this.time += t;
                else {
                    this.accumulator += e;
                    for (var s = 0; this.accumulator >= t && s < i;) this.internalStep(t), this.time += t, this.accumulator -= t, s++;
                    for (var o = this.accumulator % t / t, n = 0; n !== this.bodies.length; n++) {
                        var a = this.bodies[n];
                        j.lerp(a.interpolatedPosition, a.previousPosition, a.position, o), a.interpolatedAngle = a.previousAngle + o * (a.angle - a.previousAngle)
                    }
                }
            };
            var Q = [];
            Y.prototype.internalStep = function(t) {
                this.stepping = !0;
                var e = this.springs.length,
                    i = this.springs,
                    s = this.bodies,
                    o = this.gravity,
                    n = this.solver,
                    a = this.bodies.length,
                    r = this.broadphase,
                    h = this.narrowphase,
                    l = this.constraints,
                    c = K,
                    p = (j.scale, j.add),
                    u = (j.rotate, this.islandManager);
                if (this.overlapKeeper.tick(), this.lastTimeStep = t, this.useWorldGravityAsFrictionGravity) {
                    var d = j.length(this.gravity);
                    0 === d && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = d)
                }
                if (this.applyGravity)
                    for (var y = 0; y !== a; y++) {
                        var g = (f = s[y]).force;
                        f.type === W.DYNAMIC && f.sleepState !== W.SLEEPING && (j.scale(c, o, f.mass * f.gravityScale), p(g, g, c))
                    }
                if (this.applySpringForces)
                    for (y = 0; y !== e; y++) { i[y].applyForce() }
                if (this.applyDamping)
                    for (y = 0; y !== a; y++) {
                        var f;
                        (f = s[y]).type === W.DYNAMIC && f.applyDamping(t)
                    }
                var m = r.getCollisionPairs(this),
                    v = this.disabledBodyCollisionPairs;
                for (y = v.length - 2; 0 <= y; y -= 2)
                    for (var x = m.length - 2; 0 <= x; x -= 2)(v[y] === m[x] && v[y + 1] === m[x + 1] || v[y + 1] === m[x] && v[y] === m[x + 1]) && m.splice(x, 2);
                var b = l.length;
                for (y = 0; y !== b; y++) {
                    var w = l[y];
                    if (!w.collideConnected)
                        for (x = m.length - 2; 0 <= x; x -= 2)(w.bodyA === m[x] && w.bodyB === m[x + 1] || w.bodyB === m[x] && w.bodyA === m[x + 1]) && m.splice(x, 2)
                }
                this.postBroadphaseEvent.pairs = m, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, h.reset(this);
                y = 0;
                for (var P = m.length; y !== P; y += 2)
                    for (var _ = m[y], T = m[y + 1], S = 0, k = _.shapes.length; S !== k; S++)
                        for (var B = _.shapes[S], A = B.position, C = B.angle, I = 0, E = T.shapes.length; I !== E; I++) {
                            var O = T.shapes[I],
                                M = O.position,
                                L = O.angle,
                                R = this.defaultContactMaterial;
                            if (B.material && O.material) {
                                var D = this.getContactMaterial(B.material, O.material);
                                D && (R = D)
                            }
                            this.runNarrowphase(h, _, B, A, C, T, O, M, L, R, this.frictionGravity)
                        }
                for (y = 0; y !== a; y++) {
                    (N = s[y])._wakeUpAfterNarrowphase && (N.wakeUp(), N._wakeUpAfterNarrowphase = !1)
                }
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(Q);
                    var F = this.endContactEvent;
                    for (I = Q.length; I--;) {
                        var U = Q[I];
                        F.shapeA = U.shapeA, F.shapeB = U.shapeB, F.bodyA = U.bodyA, F.bodyB = U.bodyB, this.emit(F)
                    }
                    Q.length = 0
                }
                var G = this.preSolveEvent;
                G.contactEquations = h.contactEquations, G.frictionEquations = h.frictionEquations, this.emit(G), G.contactEquations = G.frictionEquations = null;
                b = l.length;
                for (y = 0; y !== b; y++) l[y].update();
                if (h.contactEquations.length || h.frictionEquations.length || b)
                    if (this.islandSplit) {
                        for (u.equations.length = 0, q.appendArray(u.equations, h.contactEquations), q.appendArray(u.equations, h.frictionEquations), y = 0; y !== b; y++) q.appendArray(u.equations, l[y].equations);
                        u.split(this);
                        for (y = 0; y !== u.islands.length; y++) {
                            (z = u.islands[y]).equations.length && n.solveIsland(t, z)
                        }
                    }
                else {
                    for (n.addEquations(h.contactEquations), n.addEquations(h.frictionEquations), y = 0; y !== b; y++) n.addEquations(l[y].equations);
                    this.solveConstraints && n.solve(t, this), n.removeAllEquations()
                }
                for (y = 0; y !== a; y++) {
                    var N;
                    (N = s[y]).integrate(t)
                }
                for (y = 0; y !== a; y++) s[y].setZeroForce();
                if (this.emitImpactEvent && this.has("impact")) {
                    var V = this.impactEvent;
                    for (y = 0; y !== h.contactEquations.length; y++) {
                        var H = h.contactEquations[y];
                        H.firstImpact && (V.bodyA = H.bodyA, V.bodyB = H.bodyB, V.shapeA = H.shapeA, V.shapeB = H.shapeB, V.contactEquation = H, this.emit(V))
                    }
                }
                if (this.sleepMode === Y.BODY_SLEEPING)
                    for (y = 0; y !== a; y++) s[y].sleepTick(this.time, !1, t);
                else if (this.sleepMode === Y.ISLAND_SLEEPING && this.islandSplit) {
                    for (y = 0; y !== a; y++) s[y].sleepTick(this.time, !0, t);
                    for (y = 0; y < this.islandManager.islands.length; y++) {
                        var z;
                        (z = this.islandManager.islands[y]).wantsToSleep() && z.sleep()
                    }
                }
                this.stepping = !1;
                var X = this.bodiesToBeRemoved;
                for (y = 0; y !== X.length; y++) this.removeBody(X[y]);
                X.length = 0, this.emit(this.postStepEvent)
            }, Y.prototype.runNarrowphase = function(t, e, i, s, o, n, a, r, h, l, c) {
                if (0 != (i.collisionGroup & a.collisionMask) && 0 != (a.collisionGroup & i.collisionMask)) {
                    j.rotate(T, s, e.angle), j.rotate(S, r, n.angle), j.add(T, T, e.position), j.add(S, S, n.position);
                    var p, u = o + e.angle,
                        d = h + n.angle;
                    t.enableFriction = 0 < l.friction, t.frictionCoefficient = l.friction, p = e.type === W.STATIC || e.type === W.KINEMATIC ? n.mass : n.type === W.STATIC || n.type === W.KINEMATIC ? e.mass : e.mass * n.mass / (e.mass + n.mass), t.slipForce = l.friction * c * p, t.restitution = l.restitution, t.surfaceVelocity = l.surfaceVelocity, t.frictionStiffness = l.frictionStiffness, t.frictionRelaxation = l.frictionRelaxation, t.stiffness = l.stiffness, t.relaxation = l.relaxation, t.contactSkinSize = l.contactSkinSize, t.enabledEquations = e.collisionResponse && n.collisionResponse && i.collisionResponse && a.collisionResponse;
                    var y = t[i.type | a.type],
                        g = 0;
                    if (y) {
                        var f = i.sensor || a.sensor,
                            m = t.frictionEquations.length;
                        g = i.type < a.type ? y.call(t, e, i, T, u, n, a, S, d, f) : y.call(t, n, a, S, d, e, i, T, u, f);
                        var v = t.frictionEquations.length - m;
                        if (g) {
                            if (e.allowSleep && e.type === W.DYNAMIC && e.sleepState === W.SLEEPING && n.sleepState === W.AWAKE && n.type !== W.STATIC) {
                                var x = j.squaredLength(n.velocity) + Math.pow(n.angularVelocity, 2);
                                2 * Math.pow(n.sleepSpeedLimit, 2) <= x && (e._wakeUpAfterNarrowphase = !0)
                            }
                            if (n.allowSleep && n.type === W.DYNAMIC && n.sleepState === W.SLEEPING && e.sleepState === W.AWAKE && e.type !== W.STATIC) {
                                var b = j.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2);
                                2 * Math.pow(e.sleepSpeedLimit, 2) <= b && (n._wakeUpAfterNarrowphase = !0)
                            }
                            if (this.overlapKeeper.setOverlapping(e, i, n, a), this.has("beginContact") && this.overlapKeeper.isNewOverlap(i, a)) {
                                var w = this.beginContactEvent;
                                if (w.shapeA = i, w.shapeB = a, w.bodyA = e, w.bodyB = n, w.contactEquations.length = 0, "number" == typeof g)
                                    for (var P = t.contactEquations.length - g; P < t.contactEquations.length; P++) w.contactEquations.push(t.contactEquations[P]);
                                this.emit(w)
                            }
                            if ("number" == typeof g && 1 < v)
                                for (P = t.frictionEquations.length - v; P < t.frictionEquations.length; P++) {
                                    var _ = t.frictionEquations[P];
                                    _.setSlipForce(_.getSlipForce() / v)
                                }
                        }
                    }
                }
            }, Y.prototype.addSpring = function(t) {
                this.springs.push(t);
                var e = this.addSpringEvent;
                e.spring = t, this.emit(e), e.spring = null
            }, Y.prototype.removeSpring = function(t) { var e = this.springs.indexOf(t); - 1 !== e && q.splice(this.springs, e, 1) }, Y.prototype.addBody = function(t) {
                if (-1 === this.bodies.indexOf(t)) {
                    this.bodies.push(t);
                    var e = (t.world = this).addBodyEvent;
                    e.body = t, this.emit(e), e.body = null
                }
            }, Y.prototype.removeBody = function(t) {
                if (this.stepping) this.bodiesToBeRemoved.push(t);
                else { t.world = null; var e = this.bodies.indexOf(t); - 1 !== e && (q.splice(this.bodies, e, 1), (this.removeBodyEvent.body = t).resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null) }
            }, Y.prototype.getBodyById = function(t) { for (var e = this.bodies, i = 0; i < e.length; i++) { var s = e[i]; if (s.id === t) return s } return !1 }, Y.prototype.disableBodyCollision = function(t, e) { this.disabledBodyCollisionPairs.push(t, e) }, Y.prototype.enableBodyCollision = function(t, e) {
                for (var i = this.disabledBodyCollisionPairs, s = 0; s < i.length; s += 2)
                    if (i[s] === t && i[s + 1] === e || i[s + 1] === t && i[s] === e) return void i.splice(s, 2)
            }, Y.prototype.clear = function() {
                this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                for (var t = this.constraints, e = t.length - 1; 0 <= e; e--) this.removeConstraint(t[e]);
                var i = this.bodies;
                for (e = i.length - 1; 0 <= e; e--) this.removeBody(i[e]);
                var s = this.springs;
                for (e = s.length - 1; 0 <= e; e--) this.removeSpring(s[e]);
                var o = this.contactMaterials;
                for (e = o.length - 1; 0 <= e; e--) this.removeContactMaterial(o[e]);
                Y.apply(this)
            };
            var P = j.create(),
                _ = (j.fromValues(0, 0), j.fromValues(0, 0));
            Y.prototype.hitTest = function(t, e, i) {
                i = i || 0;
                var s = new W({ position: t }),
                    o = new w,
                    n = t,
                    a = P,
                    r = _;
                s.addShape(o);
                for (var h = this.narrowphase, l = [], c = 0, p = e.length; c !== p; c++)
                    for (var u = e[c], d = 0, y = u.shapes.length; d !== y; d++) {
                        var g = u.shapes[d];
                        j.rotate(a, g.position, u.angle), j.add(a, a, u.position);
                        var f = g.angle + u.angle;
                        (g instanceof m && h.circleParticle(u, g, a, f, s, o, n, 0, !0) || g instanceof v && h.particleConvex(s, o, n, 0, u, g, a, f, !0) || g instanceof x && h.particlePlane(s, o, n, 0, u, g, a, f, !0) || g instanceof b && h.particleCapsule(s, o, n, 0, u, g, a, f, !0) || g instanceof w && j.squaredLength(j.sub(r, a, t)) < i * i) && l.push(u)
                    }
                return l
            }, Y.prototype.setGlobalStiffness = function(t) {
                for (var e = this.constraints, i = 0; i !== e.length; i++)
                    for (var s = e[i], o = 0; o !== s.equations.length; o++) {
                        var n = s.equations[o];
                        n.stiffness = t, n.needsUpdate = !0
                    }
                var a = this.contactMaterials;
                for (i = 0; i !== a.length; i++) {
                    (s = a[i]).stiffness = s.frictionStiffness = t
                }(s = this.defaultContactMaterial).stiffness = s.frictionStiffness = t
            }, Y.prototype.setGlobalRelaxation = function(t) {
                for (var e = 0; e !== this.constraints.length; e++)
                    for (var i = this.constraints[e], s = 0; s !== i.equations.length; s++) {
                        var o = i.equations[s];
                        o.relaxation = t, o.needsUpdate = !0
                    }
                for (e = 0; e !== this.contactMaterials.length; e++) {
                    (i = this.contactMaterials[e]).relaxation = i.frictionRelaxation = t
                }(i = this.defaultContactMaterial).relaxation = i.frictionRelaxation = t
            };
            var u = new r,
                d = [];
            Y.prototype.raycast = function(t, e) { return e.getAABB(u), this.broadphase.aabbQuery(this, u, d), e.intersectBodies(t, d), d.length = 0, t.hasHit() }
        }, { "../../package.json": 6, "../collision/AABB": 7, "../collision/Broadphase": 8, "../collision/Narrowphase": 10, "../collision/Ray": 11, "../collision/SAPBroadphase": 13, "../constraints/Constraint": 14, "../constraints/DistanceConstraint": 15, "../constraints/GearConstraint": 16, "../constraints/LockConstraint": 17, "../constraints/PrismaticConstraint": 18, "../constraints/RevoluteConstraint": 19, "../events/EventEmitter": 26, "../material/ContactMaterial": 27, "../material/Material": 28, "../math/vec2": 30, "../objects/Body": 31, "../objects/LinearSpring": 32, "../objects/RotationalSpring": 33, "../shapes/Capsule": 38, "../shapes/Circle": 39, "../shapes/Convex": 40, "../shapes/Line": 42, "../shapes/Particle": 43, "../shapes/Plane": 44, "../shapes/Shape": 45, "../solver/GSSolver": 46, "../solver/Solver": 47, "../utils/OverlapKeeper": 52, "../utils/Utils": 57, "./IslandManager": 59 }]
    }, {}, [36])(36)
}),
function() {
    var t = this,
        L = L || {};
    return L.game = null, L.WEBGL_RENDERER = 0, L.CANVAS_RENDERER = 1, L.VERSION = "v2.2.9", L._UID = 0, "undefined" != typeof Float32Array ? (L.Float32Array = Float32Array, L.Uint16Array = Uint16Array, L.Uint32Array = Uint32Array, L.ArrayBuffer = ArrayBuffer) : (L.Float32Array = Array, L.Uint16Array = Array), L.PI_2 = 2 * Math.PI, L.RAD_TO_DEG = 180 / Math.PI, L.DEG_TO_RAD = Math.PI / 180, L.RETINA_PREFIX = "@2x", L.DisplayObject = function() { this.position = new L.Point(0, 0), this.scale = new L.Point(1, 1), this.pivot = new L.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new L.Matrix, this.worldPosition = new L.Point(0, 0), this.worldScale = new L.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new L.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1 }, L.DisplayObject.prototype.constructor = L.DisplayObject, L.DisplayObject.prototype = {
        destroy: function() {
            if (this.children) {
                for (var t = this.children.length; t--;) this.children[t].destroy();
                this.children = []
            }
            this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
        },
        updateTransform: function(t) {
            if (!t && !this.parent && !this.game) return this;
            var e = this.parent;
            t ? e = t : this.parent || (e = this.game.world);
            var i, s, o, n, a, r, h = e.worldTransform,
                l = this.worldTransform;
            return this.rotation % L.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), i = this._cr * this.scale.x, s = this._sr * this.scale.x, o = -this._sr * this.scale.y, n = this._cr * this.scale.y, a = this.position.x, r = this.position.y, (this.pivot.x || this.pivot.y) && (a -= this.pivot.x * i + this.pivot.y * o, r -= this.pivot.x * s + this.pivot.y * n), l.a = i * h.a + s * h.c, l.b = i * h.b + s * h.d, l.c = o * h.a + n * h.c, l.d = o * h.b + n * h.d) : (i = this.scale.x, n = this.scale.y, a = this.position.x - this.pivot.x * i, r = this.position.y - this.pivot.y * n, l.a = i * h.a, l.b = i * h.b, l.c = n * h.c, l.d = n * h.d), l.tx = a * h.a + r * h.c + h.tx, l.ty = a * h.b + r * h.d + h.ty, this.worldAlpha = this.alpha * e.worldAlpha, this.worldPosition.set(l.tx, l.ty), this.worldScale.set(this.scale.x * Math.sqrt(l.a * l.a + l.c * l.c), this.scale.y * Math.sqrt(l.b * l.b + l.d * l.d)), this.worldRotation = Math.atan2(-l.c, l.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, l, h), this
        },
        preUpdate: function() {},
        generateTexture: function(t, e, i) {
            var s = this.getLocalBounds(),
                o = new L.RenderTexture(0 | s.width, 0 | s.height, i, e, t);
            return L.DisplayObject._tempMatrix.tx = -s.x, L.DisplayObject._tempMatrix.ty = -s.y, o.render(this, L.DisplayObject._tempMatrix), o
        },
        updateCache: function() { return this._generateCachedSprite(), this },
        toGlobal: function(t) { return this.updateTransform(), this.worldTransform.apply(t) },
        toLocal: function(t, e) { return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t) },
        _renderCachedSprite: function(t) { this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? L.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : L.Sprite.prototype._renderCanvas.call(this._cachedSprite, t) },
        _generateCachedSprite: function() {
            this._cacheAsBitmap = !1;
            var t = this.getLocalBounds();
            if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
            else {
                var e = new L.RenderTexture(t.width, t.height);
                this._cachedSprite = new L.Sprite(e), this._cachedSprite.worldTransform = this.worldTransform
            }
            var i = this._filters;
            this._filters = null, this._cachedSprite.filters = i, L.DisplayObject._tempMatrix.tx = -t.x, L.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, L.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = i, this._cacheAsBitmap = !0
        },
        _destroyCachedSprite: function() { this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null) }
    }, L.DisplayObject.prototype.displayObjectUpdateTransform = L.DisplayObject.prototype.updateTransform, Object.defineProperties(L.DisplayObject.prototype, {
        x: { get: function() { return this.position.x }, set: function(t) { this.position.x = t } },
        y: { get: function() { return this.position.y }, set: function(t) { this.position.y = t } },
        worldVisible: {
            get: function() {
                if (this.visible) {
                    var t = this.parent;
                    if (!t) return this.visible;
                    do {
                        if (!t.visible) return !1;
                        t = t.parent
                    } while (t);
                    return !0
                }
                return !1
            }
        },
        mask: { get: function() { return this._mask }, set: function(t) { this._mask && (this._mask.isMask = !1), (this._mask = t) && (this._mask.isMask = !0) } },
        filters: {
            get: function() { return this._filters },
            set: function(t) {
                if (Array.isArray(t)) {
                    for (var e = [], i = 0; i < t.length; i++)
                        for (var s = t[i].passes, o = 0; o < s.length; o++) e.push(s[o]);
                    this._filterBlock = { target: this, filterPasses: e }
                }
                this._filters = t, this.blendMode && this.blendMode === L.blendModes.MULTIPLY && (this.blendMode = L.blendModes.NORMAL)
            }
        },
        cacheAsBitmap: { get: function() { return this._cacheAsBitmap }, set: function(t) { this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t) } }
    }), L.DisplayObjectContainer = function() { L.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1 }, L.DisplayObjectContainer.prototype = Object.create(L.DisplayObject.prototype), L.DisplayObjectContainer.prototype.constructor = L.DisplayObjectContainer, L.DisplayObjectContainer.prototype.addChild = function(t) { return this.addChildAt(t, this.children.length) }, L.DisplayObjectContainer.prototype.addChildAt = function(t, e) { if (0 <= e && e <= this.children.length) return t.parent && t.parent.removeChild(t), (t.parent = this).children.splice(e, 0, t), t; throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length) }, L.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
        if (t !== e) {
            var i = this.getChildIndex(t),
                s = this.getChildIndex(e);
            if (i < 0 || s < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[i] = e, this.children[s] = t
        }
    }, L.DisplayObjectContainer.prototype.getChildIndex = function(t) { var e = this.children.indexOf(t); if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller"); return e }, L.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
        if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
        var i = this.getChildIndex(t);
        this.children.splice(i, 1), this.children.splice(e, 0, t)
    }, L.DisplayObjectContainer.prototype.getChildAt = function(t) { if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller"); return this.children[t] }, L.DisplayObjectContainer.prototype.removeChild = function(t) { var e = this.children.indexOf(t); if (-1 !== e) return this.removeChildAt(e) }, L.DisplayObjectContainer.prototype.removeChildAt = function(t) { var e = this.getChildAt(t); return e && (e.parent = void 0, this.children.splice(t, 1)), e }, L.DisplayObjectContainer.prototype.removeChildren = function(t, e) { void 0 === t && (t = 0), void 0 === e && (e = this.children.length); var i = e - t; if (0 < i && i <= e) { for (var s = this.children.splice(begin, i), o = 0; o < s.length; o++) { s[o].parent = void 0 } return s } if (0 === i && 0 === this.children.length) return []; throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range") }, L.DisplayObjectContainer.prototype.updateTransform = function() {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
            for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
    }, L.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = L.DisplayObjectContainer.prototype.updateTransform, L.DisplayObjectContainer.prototype.getBounds = function(t) {
        var e, i = t && t instanceof L.DisplayObject,
            s = !0;
        if (i ? s = t instanceof L.DisplayObjectContainer && t.contains(this) : t = this, i) { var o = t.worldTransform; for (t.worldTransform = L.identityMatrix, e = 0; e < t.children.length; e++) t.children[e].updateTransform() }
        var n, a, r, h = 1 / 0,
            l = 1 / 0,
            c = -1 / 0,
            p = -1 / 0,
            u = !1;
        for (e = 0; e < this.children.length; e++) { this.children[e].visible && (u = !0, h = h < (n = this.children[e].getBounds()).x ? h : n.x, l = l < n.y ? l : n.y, c = (a = n.width + n.x) < c ? c : a, p = (r = n.height + n.y) < p ? p : r) }
        var d = this._bounds;
        if (!u) {
            var y = (d = new L.Rectangle).x,
                g = d.width + d.x,
                f = d.y,
                m = d.height + d.y,
                v = this.worldTransform,
                x = v.a,
                b = v.b,
                w = v.c,
                P = v.d,
                _ = v.tx,
                T = v.ty,
                S = x * g + w * m + _,
                k = P * m + b * g + T,
                B = x * y + w * m + _,
                A = P * m + b * y + T,
                C = x * y + w * f + _,
                I = P * f + b * y + T,
                E = x * g + w * f + _,
                O = P * f + b * g + T;
            h = E < (h = C < (h = B < (h = c = S) ? B : h) ? C : h) ? E : h, l = O < (l = I < (l = A < (l = p = k) ? A : l) ? I : l) ? O : l, c = (c = (c = c < B ? B : c) < C ? C : c) < E ? E : c, p = (p = (p = p < A ? A : p) < I ? I : p) < O ? O : p
        }
        if (d.x = h, d.y = l, d.width = c - h, d.height = p - l, i)
            for (t.worldTransform = o, e = 0; e < t.children.length; e++) t.children[e].updateTransform();
        if (!s) {
            var M = t.getBounds();
            d.x -= M.x, d.y -= M.y
        }
        return d
    }, L.DisplayObjectContainer.prototype.getLocalBounds = function() { return this.getBounds(this) }, L.DisplayObjectContainer.prototype.contains = function(t) { return !!t && (t === this || this.contains(t.parent)) }, L.DisplayObjectContainer.prototype._renderWebGL = function(t) {
        var e;
        if (this.visible && !(this.alpha <= 0))
            if (this._cacheAsBitmap) this._renderCachedSprite(t);
            else if (this._mask || this._filters) {
            for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
            t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
        }
        else
            for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
    }, L.DisplayObjectContainer.prototype._renderCanvas = function(t) {
        if (!1 !== this.visible && 0 !== this.alpha)
            if (this._cacheAsBitmap) this._renderCachedSprite(t);
            else {
                this._mask && t.maskManager.pushMask(this._mask, t);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
    }, Object.defineProperty(L.DisplayObjectContainer.prototype, "width", {
        get: function() { return this.getLocalBounds().width * this.scale.x },
        set: function(t) {
            var e = this.getLocalBounds().width;
            this.scale.x = 0 !== e ? t / e : 1, this._width = t
        }
    }), Object.defineProperty(L.DisplayObjectContainer.prototype, "height", {
        get: function() { return this.getLocalBounds().height * this.scale.y },
        set: function(t) {
            var e = this.getLocalBounds().height;
            this.scale.y = 0 !== e ? t / e : 1, this._height = t
        }
    }), L.Sprite = function(t) { L.DisplayObjectContainer.call(this), this.anchor = new L.Point, this.texture = t || L.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = L.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0 }, L.Sprite.prototype = Object.create(L.DisplayObjectContainer.prototype), L.Sprite.prototype.constructor = L.Sprite, Object.defineProperty(L.Sprite.prototype, "width", { get: function() { return this.scale.x * this.texture.frame.width }, set: function(t) { this.scale.x = t / this.texture.frame.width, this._width = t } }), Object.defineProperty(L.Sprite.prototype, "height", { get: function() { return this.scale.y * this.texture.frame.height }, set: function(t) { this.scale.y = t / this.texture.frame.height, this._height = t } }), L.Sprite.prototype.setTexture = function(t, e) { void 0 !== e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1 }, L.Sprite.prototype.onTextureUpdate = function() { this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height) }, L.Sprite.prototype.getBounds = function(t) {
        var e = this.texture.frame.width,
            i = this.texture.frame.height,
            s = e * (1 - this.anchor.x),
            o = e * -this.anchor.x,
            n = i * (1 - this.anchor.y),
            a = i * -this.anchor.y,
            r = t || this.worldTransform,
            h = r.a,
            l = r.b,
            c = r.c,
            p = r.d,
            u = r.tx,
            d = r.ty,
            y = -1 / 0,
            g = -1 / 0,
            f = 1 / 0,
            m = 1 / 0;
        if (0 === l && 0 === c) {
            if (h < 0) {
                h *= -1;
                var v = s;
                s = -o, o = -v
            }
            if (p < 0) {
                p *= -1;
                v = n;
                n = -a, a = -v
            }
            f = h * o + u, y = h * s + u, m = p * a + d, g = p * n + d
        }
        else {
            var x = h * o + c * a + u,
                b = p * a + l * o + d,
                w = h * s + c * a + u,
                P = p * a + l * s + d,
                _ = h * s + c * n + u,
                T = p * n + l * s + d,
                S = h * o + c * n + u,
                k = p * n + l * o + d;
            f = S < (f = _ < (f = w < (f = x < f ? x : f) ? w : f) ? _ : f) ? S : f, m = k < (m = T < (m = P < (m = b < m ? b : m) ? P : m) ? T : m) ? k : m, y = (y = (y = (y = y < x ? x : y) < w ? w : y) < _ ? _ : y) < S ? S : y, g = (g = (g = (g = g < b ? b : g) < P ? P : g) < T ? T : g) < k ? k : g
        }
        var B = this._bounds;
        return B.x = f, B.width = y - f, B.y = m, B.height = g - m, this._currentBounds = B
    }, L.Sprite.prototype.getLocalBounds = function() {
        var t = this.worldTransform;
        this.worldTransform = L.identityMatrix;
        for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        var i = this.getBounds();
        for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        return i
    }, L.Sprite.prototype._renderWebGL = function(t, e) {
        if (this.visible && !(this.alpha <= 0) && this.renderable) {
            var i = this.worldTransform;
            if (e && (i = e), this._mask || this._filters) {
                var s = t.spriteBatch;
                this._filters && (s.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (s.stop(), t.maskManager.pushMask(this.mask, t), s.start()), s.render(this);
                for (var o = 0; o < this.children.length; o++) this.children[o]._renderWebGL(t);
                s.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), s.start()
            }
            else { t.spriteBatch.render(this); for (o = 0; o < this.children.length; o++) this.children[o]._renderWebGL(t, i) }
        }
    }, L.Sprite.prototype._renderCanvas = function(t, e) {
        if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
            var i = this.worldTransform;
            if (e && (i = e), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = L.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                var s = this.texture.baseTexture.resolution / t.resolution;
                t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === L.scaleModes.LINEAR);
                var o = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                    n = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                    a = i.tx * t.resolution + t.shakeX,
                    r = i.ty * t.resolution + t.shakeY;
                t.roundPixels ? (t.context.setTransform(i.a, i.b, i.c, i.d, 0 | a, 0 | r), o |= 0, n |= 0) : t.context.setTransform(i.a, i.b, i.c, i.d, a, r);
                var h = this.texture.crop.width,
                    l = this.texture.crop.height;
                if (o /= s, n /= s, 16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = L.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, h, l, o, n, h / s, l / s);
                else {
                    var c = this.texture.crop.x,
                        p = this.texture.crop.y;
                    t.context.drawImage(this.texture.baseTexture.source, c, p, h, l, o, n, h / s, l / s)
                }
            }
            for (var u = 0; u < this.children.length; u++) this.children[u]._renderCanvas(t);
            this._mask && t.maskManager.popMask(t)
        }
    }, L.SpriteBatch = function(t) { L.DisplayObjectContainer.call(this), this.textureThing = t, this.ready = !1 }, L.SpriteBatch.prototype = Object.create(L.DisplayObjectContainer.prototype), L.SpriteBatch.prototype.constructor = L.SpriteBatch, L.SpriteBatch.prototype.initWebGL = function(t) { this.fastSpriteBatch = new L.WebGLFastSpriteBatch(t), this.ready = !0 }, L.SpriteBatch.prototype.updateTransform = function() { this.displayObjectUpdateTransform() }, L.SpriteBatch.prototype._renderWebGL = function(t) {!this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(t.gl), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start()) }, L.SpriteBatch.prototype._renderCanvas = function(t) {
        if (this.visible && !(this.alpha <= 0) && this.children.length) {
            var e = t.context;
            e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
            for (var i = this.worldTransform, s = !0, o = 0; o < this.children.length; o++) {
                var n = this.children[o];
                if (n.visible) {
                    var a = n.texture,
                        r = a.frame;
                    if (e.globalAlpha = this.worldAlpha * n.alpha, n.rotation % (2 * Math.PI) == 0) s && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), s = !1), e.drawImage(a.baseTexture.source, r.x, r.y, r.width, r.height, n.anchor.x * (-r.width * n.scale.x) + n.position.x + .5 + t.shakeX | 0, n.anchor.y * (-r.height * n.scale.y) + n.position.y + .5 + t.shakeY | 0, r.width * n.scale.x, r.height * n.scale.y);
                    else {
                        s || (s = !0), n.displayObjectUpdateTransform();
                        var h = n.worldTransform,
                            l = h.tx * t.resolution + t.shakeX,
                            c = h.ty * t.resolution + t.shakeY;
                        t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | c) : e.setTransform(h.a, h.b, h.c, h.d, l, c), e.drawImage(a.baseTexture.source, r.x, r.y, r.width, r.height, n.anchor.x * -r.width + .5 | 0, n.anchor.y * -r.height + .5 | 0, r.width, r.height)
                    }
                }
            }
        }
    }, L.hex2rgb = function(t) { return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255] }, L.rgb2hex = function(t) { return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2] }, L.canUseNewCanvasBlendModes = function() {
        if (void 0 === document) return !1;
        var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
            e = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
            i = new Image;
        i.src = t + "AP804Oa6" + e;
        var s = new Image;
        s.src = t + "/wCKxvRF" + e;
        var o = L.CanvasPool.create(this, 6, 1).getContext("2d");
        if (o.globalCompositeOperation = "multiply", o.drawImage(i, 0, 0), o.drawImage(s, 2, 0), !o.getImageData(2, 0, 1, 1)) return !1;
        var n = o.getImageData(2, 0, 1, 1).data;
        return L.CanvasPool.remove(this), 255 === n[0] && 0 === n[1] && 0 === n[2]
    }, L.getNextPowerOfTwo = function(t) { if (0 < t && 0 == (t & t - 1)) return t; for (var e = 1; e < t;) e <<= 1; return e }, L.isPowerOfTwo = function(t, e) { return 0 < t && 0 == (t & t - 1) && 0 < e && 0 == (e & e - 1) }, L.CanvasPool = {
        create: function(t, e, i) {
            var s, o = L.CanvasPool.getFirst();
            if (-1 === o) {
                var n = { parent: t, canvas: document.createElement("canvas") };
                L.CanvasPool.pool.push(n), s = n.canvas
            }
            else L.CanvasPool.pool[o].parent = t, s = L.CanvasPool.pool[o].canvas;
            return void 0 !== e && (s.width = e, s.height = i), s
        },
        getFirst: function() {
            for (var t = L.CanvasPool.pool, e = 0; e < t.length; e++)
                if (!t[e].parent) return e;
            return -1
        },
        remove: function(t) { for (var e = L.CanvasPool.pool, i = 0; i < e.length; i++) e[i].parent === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1) },
        removeByCanvas: function(t) { for (var e = L.CanvasPool.pool, i = 0; i < e.length; i++) e[i].canvas === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1) },
        getTotal: function() { for (var t = L.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent && e++; return e },
        getFree: function() { for (var t = L.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent || e++; return e }
    }, L.CanvasPool.pool = [], L.initDefaultShaders = function() {}, L.CompileVertexShader = function(t, e) { return L._CompileShader(t, e, t.VERTEX_SHADER) }, L.CompileFragmentShader = function(t, e) { return L._CompileShader(t, e, t.FRAGMENT_SHADER) }, L._CompileShader = function(t, e, i) {
        var s = e;
        Array.isArray(e) && (s = e.join("\n"));
        var o = t.createShader(i);
        return t.shaderSource(o, s), t.compileShader(o), t.getShaderParameter(o, t.COMPILE_STATUS) ? o : (window.console.log(t.getShaderInfoLog(o)), null)
    }, L.compileProgram = function(t, e, i) {
        var s = L.CompileFragmentShader(t, i),
            o = L.CompileVertexShader(t, e),
            n = t.createProgram();
        return t.attachShader(n, o), t.attachShader(n, s), t.linkProgram(n), t.getProgramParameter(n, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(n)), window.console.log("Could not initialise shaders")), n
    }, L.PixiShader = function(t) { this._UID = L._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init() }, L.PixiShader.prototype.constructor = L.PixiShader, L.PixiShader.prototype.init = function() {
        var t = this.gl,
            e = L.compileProgram(t, this.vertexSrc || L.PixiShader.defaultVertexSrc, this.fragmentSrc);
        for (var i in t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute], this.uniforms) this.uniforms[i].uniformLocation = t.getUniformLocation(e, i);
        this.initUniforms(), this.program = e
    }, L.PixiShader.prototype.initUniforms = function() { this.textureCount = 1; var t, e = this.gl; for (var i in this.uniforms) { var s = (t = this.uniforms[i]).type; "sampler2D" === s ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === s ? t.glFunc = e.uniformMatrix2fv : "mat3" === s ? t.glFunc = e.uniformMatrix3fv : "mat4" === s && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + s], t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1) } }, L.PixiShader.prototype.initSampler2D = function(t) {
        if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
            var e = this.gl;
            if (e.activeTexture(e["TEXTURE" + this.textureCount]), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                var i = t.textureData,
                    s = i.magFilter ? i.magFilter : e.LINEAR,
                    o = i.minFilter ? i.minFilter : e.LINEAR,
                    n = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                    a = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                    r = i.luminance ? e.LUMINANCE : e.RGBA;
                if (i.repeat && (n = e.REPEAT, a = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                    var h = i.width ? i.width : 512,
                        l = i.height ? i.height : 2,
                        c = i.border ? i.border : 0;
                    e.texImage2D(e.TEXTURE_2D, 0, r, h, l, c, r, e.UNSIGNED_BYTE, null)
                }
                else e.texImage2D(e.TEXTURE_2D, 0, r, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, o), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a)
            }
            e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
        }
    }, L.PixiShader.prototype.syncUniforms = function() {
        var t;
        this.textureCount = 1;
        var e = this.gl;
        for (var i in this.uniforms) 1 === (t = this.uniforms[i]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[e.id] ? L.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), e.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
    }, L.PixiShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null }, L.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"], L.PixiFastShader = function(t) { this._UID = L._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init() }, L.PixiFastShader.prototype.constructor = L.PixiFastShader, L.PixiFastShader.prototype.init = function() {
        var t = this.gl,
            e = L.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.uMatrix = t.getUniformLocation(e, "uMatrix"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"), this.aScale = t.getAttribLocation(e, "aScale"), this.aRotation = t.getAttribLocation(e, "aRotation"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = e
    }, L.PixiFastShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null }, L.StripShader = function(t) { this._UID = L._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init() }, L.StripShader.prototype.constructor = L.StripShader, L.StripShader.prototype.init = function() {
        var t = this.gl,
            e = L.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, L.StripShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null }, L.PrimitiveShader = function(t) { this._UID = L._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init() }, L.PrimitiveShader.prototype.constructor = L.PrimitiveShader, L.PrimitiveShader.prototype.init = function() {
        var t = this.gl,
            e = L.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, L.PrimitiveShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null }, L.ComplexPrimitiveShader = function(t) { this._UID = L._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init() }, L.ComplexPrimitiveShader.prototype.constructor = L.ComplexPrimitiveShader, L.ComplexPrimitiveShader.prototype.init = function() {
        var t = this.gl,
            e = L.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.color = t.getUniformLocation(e, "color"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, L.ComplexPrimitiveShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null }, L.glContexts = [], L.instances = [], L.WebGLRenderer = function(t) { this.game = t, L.defaultRenderer || (L.defaultRenderer = this), this.type = L.WEBGL_RENDERER, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = { alpha: this.transparent, antialias: t.antialias, premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent, stencil: !0, preserveDrawingBuffer: this.preserveDrawingBuffer }, this.projection = new L.Point, this.offset = new L.Point, this.shaderManager = new L.WebGLShaderManager, this.spriteBatch = new L.WebGLSpriteBatch, this.maskManager = new L.WebGLMaskManager, this.filterManager = new L.WebGLFilterManager, this.stencilManager = new L.WebGLStencilManager, this.blendModeManager = new L.WebGLBlendModeManager, this.renderSession = {}, this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, (this.renderSession.renderer = this).renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes() }, L.WebGLRenderer.prototype.constructor = L.WebGLRenderer, L.WebGLRenderer.prototype.initContext = function() {
        var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (!(this.gl = t)) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.glContextId = t.id = L.WebGLRenderer.glContextId++, L.glContexts[this.glContextId] = t, L.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height)
    }, L.WebGLRenderer.prototype.render = function(t) {
        if (!this.contextLost) {
            var e = this.gl;
            e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
        }
    }, L.WebGLRenderer.prototype.renderDisplayObject = function(t, e, i, s) { this.renderSession.blendModeManager.setBlendMode(L.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = i ? -1 : 1, this.renderSession.projection = e, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, i), t._renderWebGL(this.renderSession, s), this.spriteBatch.end() }, L.WebGLRenderer.prototype.resize = function(t, e) { this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution }, L.WebGLRenderer.prototype.updateTexture = function(t) { if (!t.hasLoaded) return !1; var e = this.gl; return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === L.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && L.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === L.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === L.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), !(t._dirty[e.id] = !1) }, L.WebGLRenderer.prototype.destroy = function() { L.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, L.CanvasPool.remove(this), L.instances[this.glContextId] = null, L.WebGLRenderer.glContextId-- }, L.WebGLRenderer.prototype.mapBlendModes = function() {
        var t = this.gl;
        if (!L.blendModesWebGL) {
            var e = [],
                i = L.blendModes;
            e[i.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], e[i.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], e[i.SCREEN] = [t.SRC_ALPHA, t.ONE], e[i.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], L.blendModesWebGL = e
        }
    }, L.WebGLRenderer.glContextId = 0, L.WebGLBlendModeManager = function() { this.currentBlendMode = 99999 }, L.WebGLBlendModeManager.prototype.constructor = L.WebGLBlendModeManager, L.WebGLBlendModeManager.prototype.setContext = function(t) { this.gl = t }, L.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
        if (this.currentBlendMode === t) return !1;
        this.currentBlendMode = t;
        var e = L.blendModesWebGL[this.currentBlendMode];
        return e && this.gl.blendFunc(e[0], e[1]), !0
    }, L.WebGLBlendModeManager.prototype.destroy = function() { this.gl = null }, L.WebGLMaskManager = function() {}, L.WebGLMaskManager.prototype.constructor = L.WebGLMaskManager, L.WebGLMaskManager.prototype.setContext = function(t) { this.gl = t }, L.WebGLMaskManager.prototype.pushMask = function(t, e) {
        var i = e.gl;
        t.dirty && L.WebGLGraphics.updateGraphics(t, i), void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.pushStencil(t, t._webGL[i.id].data[0], e)
    }, L.WebGLMaskManager.prototype.popMask = function(t, e) {
        var i = this.gl;
        void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
    }, L.WebGLMaskManager.prototype.destroy = function() { this.gl = null }, L.WebGLStencilManager = function() { this.stencilStack = [], this.reverse = !0, this.count = 0 }, L.WebGLStencilManager.prototype.setContext = function(t) { this.gl = t }, L.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
        var s = this.gl;
        this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
        var o = this.count;
        s.colorMask(!1, !1, !1, !1), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), 1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - o, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, o, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (o + 1), 255) : s.stencilFunc(s.EQUAL, o + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, o, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - o, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, o + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (o + 1), 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.count++
    }, L.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
        this._currentGraphics = t;
        var s, o = this.gl,
            n = i.projection,
            a = i.offset;
        1 === e.mode ? (s = i.shaderManager.complexPrimitiveShader, i.shaderManager.setShader(s), o.uniform1f(s.flipY, i.flipY), o.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), o.uniform2f(s.projectionVector, n.x, -n.y), o.uniform2f(s.offsetVector, -a.x, -a.y), o.uniform3fv(s.tintColor, L.hex2rgb(t.tint)), o.uniform3fv(s.color, e.color), o.uniform1f(s.alpha, t.worldAlpha * e.alpha), o.bindBuffer(o.ARRAY_BUFFER, e.buffer), o.vertexAttribPointer(s.aVertexPosition, 2, o.FLOAT, !1, 8, 0)) : (s = i.shaderManager.primitiveShader, i.shaderManager.setShader(s), o.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), o.uniform1f(s.flipY, i.flipY), o.uniform2f(s.projectionVector, n.x, -n.y), o.uniform2f(s.offsetVector, -a.x, -a.y), o.uniform3fv(s.tintColor, L.hex2rgb(t.tint)), o.uniform1f(s.alpha, t.worldAlpha), o.bindBuffer(o.ARRAY_BUFFER, e.buffer), o.vertexAttribPointer(s.aVertexPosition, 2, o.FLOAT, !1, 24, 0), o.vertexAttribPointer(s.colorAttribute, 4, o.FLOAT, !1, 24, 8)), o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, e.indexBuffer)
    }, L.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
        var s = this.gl;
        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) s.disable(s.STENCIL_TEST);
        else {
            var o = this.count;
            this.bindGraphics(t, e, i), s.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (o + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, o + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0)) : (this.reverse ? (s.stencilFunc(s.EQUAL, o + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (o + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0)), this.reverse ? s.stencilFunc(s.EQUAL, o, 255) : s.stencilFunc(s.EQUAL, 255 - o, 255), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
        }
    }, L.WebGLStencilManager.prototype.destroy = function() { this.stencilStack = null, this.gl = null }, L.WebGLShaderManager = function() {
        this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
        for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
        this.stack = []
    }, L.WebGLShaderManager.prototype.constructor = L.WebGLShaderManager, L.WebGLShaderManager.prototype.setContext = function(t) { this.gl = t, this.primitiveShader = new L.PrimitiveShader(t), this.complexPrimitiveShader = new L.ComplexPrimitiveShader(t), this.defaultShader = new L.PixiShader(t), this.fastShader = new L.PixiFastShader(t), this.stripShader = new L.StripShader(t), this.setShader(this.defaultShader) }, L.WebGLShaderManager.prototype.setAttribs = function(t) {
        var e;
        for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
        for (e = 0; e < t.length; e++) {
            var i = t[e];
            this.tempAttribState[i] = !0
        }
        var s = this.gl;
        for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
    }, L.WebGLShaderManager.prototype.setShader = function(t) { return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0) }, L.WebGLShaderManager.prototype.destroy = function() { this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null }, L.WebGLSpriteBatch = function() {
        this.vertSize = 5, this.size = 2e3;
        var t = 4 * this.size * 4 * this.vertSize,
            e = 6 * this.size;
        this.vertices = new L.ArrayBuffer(t), this.positions = new L.Float32Array(this.vertices), this.colors = new L.Uint32Array(this.vertices), this.indices = new L.Uint16Array(e);
        for (var i = this.lastIndexCount = 0, s = 0; i < e; i += 6, s += 4) this.indices[i + 0] = s + 0, this.indices[i + 1] = s + 1, this.indices[i + 2] = s + 2, this.indices[i + 3] = s + 0, this.indices[i + 4] = s + 2, this.indices[i + 5] = s + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = new L.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
    }, L.WebGLSpriteBatch.prototype.setContext = function(t) {
        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
        var e = new L.PixiShader(t);
        e.fragmentSrc = this.defaultShader.fragmentSrc, e.uniforms = {}, e.init(), this.defaultShader.shaders[t.id] = e
    }, L.WebGLSpriteBatch.prototype.begin = function(t) { this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start() }, L.WebGLSpriteBatch.prototype.end = function() { this.flush() }, L.WebGLSpriteBatch.prototype.render = function(t, e) {
        var i = t.texture,
            s = t.worldTransform;
        e && (s = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
        var o = i._uvs;
        if (o) {
            var n, a, r, h, l = t.anchor.x,
                c = t.anchor.y;
            if (i.trim) {
                var p = i.trim;
                n = (a = p.x - l * p.width) + i.crop.width, r = (h = p.y - c * p.height) + i.crop.height
            }
            else n = i.frame.width * (1 - l), a = i.frame.width * -l, r = i.frame.height * (1 - c), h = i.frame.height * -c;
            var u = 4 * this.currentBatchSize * this.vertSize,
                d = i.baseTexture.resolution,
                y = s.a / d,
                g = s.b / d,
                f = s.c / d,
                m = s.d / d,
                v = s.tx,
                x = s.ty,
                b = this.colors,
                w = this.positions;
            this.renderSession.roundPixels ? (w[u] = y * a + f * h + v | 0, w[u + 1] = m * h + g * a + x | 0, w[u + 5] = y * n + f * h + v | 0, w[u + 6] = m * h + g * n + x | 0, w[u + 10] = y * n + f * r + v | 0, w[u + 11] = m * r + g * n + x | 0, w[u + 15] = y * a + f * r + v | 0, w[u + 16] = m * r + g * a + x | 0) : (w[u] = y * a + f * h + v, w[u + 1] = m * h + g * a + x, w[u + 5] = y * n + f * h + v, w[u + 6] = m * h + g * n + x, w[u + 10] = y * n + f * r + v, w[u + 11] = m * r + g * n + x, w[u + 15] = y * a + f * r + v, w[u + 16] = m * r + g * a + x), w[u + 2] = o.x0, w[u + 3] = o.y0, w[u + 7] = o.x1, w[u + 8] = o.y1, w[u + 12] = o.x2, w[u + 13] = o.y2, w[u + 17] = o.x3, w[u + 18] = o.y3;
            var P = t.tint;
            b[u + 4] = b[u + 9] = b[u + 14] = b[u + 19] = (P >> 16) + (65280 & P) + ((255 & P) << 16) + (255 * t.worldAlpha << 24), this.sprites[this.currentBatchSize++] = t
        }
    }, L.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
        var e = t.tilingTexture;
        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture), t._uvs || (t._uvs = new L.TextureUvs);
        var i = t._uvs,
            s = e.baseTexture.width,
            o = e.baseTexture.height;
        t.tilePosition.x %= s * t.tileScaleOffset.x, t.tilePosition.y %= o * t.tileScaleOffset.y;
        var n = t.tilePosition.x / (s * t.tileScaleOffset.x),
            a = t.tilePosition.y / (o * t.tileScaleOffset.y),
            r = t.width / s / (t.tileScale.x * t.tileScaleOffset.x),
            h = t.height / o / (t.tileScale.y * t.tileScaleOffset.y);
        i.x0 = 0 - n, i.y0 = 0 - a, i.x1 = 1 * r - n, i.y1 = 0 - a, i.x2 = 1 * r - n, i.y2 = 1 * h - a, i.x3 = 0 - n, i.y3 = 1 * h - a;
        var l = t.tint,
            c = (l >> 16) + (65280 & l) + ((255 & l) << 16) + (255 * t.worldAlpha << 24),
            p = this.positions,
            u = this.colors,
            d = t.width,
            y = t.height,
            g = t.anchor.x,
            f = t.anchor.y,
            m = d * (1 - g),
            v = d * -g,
            x = y * (1 - f),
            b = y * -f,
            w = 4 * this.currentBatchSize * this.vertSize,
            P = e.baseTexture.resolution,
            _ = t.worldTransform,
            T = _.a / P,
            S = _.b / P,
            k = _.c / P,
            B = _.d / P,
            A = _.tx,
            C = _.ty;
        p[w++] = T * v + k * b + A, p[w++] = B * b + S * v + C, p[w++] = i.x0, p[w++] = i.y0, u[w++] = c, p[w++] = T * m + k * b + A, p[w++] = B * b + S * m + C, p[w++] = i.x1, p[w++] = i.y1, u[w++] = c, p[w++] = T * m + k * x + A, p[w++] = B * x + S * m + C, p[w++] = i.x2, p[w++] = i.y2, u[w++] = c, p[w++] = T * v + k * x + A, p[w++] = B * x + S * v + C, p[w++] = i.x3, p[w++] = i.y3, u[w++] = c, this.sprites[this.currentBatchSize++] = t
    }, L.WebGLSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t, e, i, s, o = this.gl;
            if (this.dirty) {
                this.dirty = !1, o.activeTexture(o.TEXTURE0), o.bindBuffer(o.ARRAY_BUFFER, this.vertexBuffer), o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t = this.defaultShader.shaders[o.id];
                var n = 4 * this.vertSize;
                o.vertexAttribPointer(t.aVertexPosition, 2, o.FLOAT, !1, n, 0), o.vertexAttribPointer(t.aTextureCoord, 2, o.FLOAT, !1, n, 8), o.vertexAttribPointer(t.colorAttribute, 4, o.UNSIGNED_BYTE, !0, n, 16)
            }
            if (this.currentBatchSize > .5 * this.size) o.bufferSubData(o.ARRAY_BUFFER, 0, this.vertices);
            else {
                var a = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                o.bufferSubData(o.ARRAY_BUFFER, 0, a)
            }
            for (var r, h = 0, l = 0, c = null, p = this.renderSession.blendModeManager.currentBlendMode, u = null, d = !1, y = !1, g = 0, f = this.currentBatchSize; g < f; g++) {
                e = (r = this.sprites[g]).tilingTexture ? r.tilingTexture.baseTexture : r.texture.baseTexture, d = p !== (i = r.blendMode), y = u !== (s = r.shader || this.defaultShader);
                var m = e.skipRender;
                if (m && 0 < r.children.length && (m = !1), (c !== e && !m || d || y) && (this.renderBatch(c, h, l), l = g, h = 0, c = e, d && (p = i, this.renderSession.blendModeManager.setBlendMode(p)), y)) {
                    (t = (u = s).shaders[o.id]) || ((t = new L.PixiShader(o)).fragmentSrc = u.fragmentSrc, t.uniforms = u.uniforms, t.init(), u.shaders[o.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms();
                    var v = this.renderSession.projection;
                    o.uniform2f(t.projectionVector, v.x, v.y);
                    var x = this.renderSession.offset;
                    o.uniform2f(t.offsetVector, x.x, x.y)
                }
                h++
            }
            this.renderBatch(c, h, l), this.currentBatchSize = 0
        }
    }, L.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
        if (0 !== e) {
            var s = this.gl;
            if (t._dirty[s.id]) { if (!this.renderSession.renderer.updateTexture(t)) return }
            else s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id]);
            s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
        }
    }, L.WebGLSpriteBatch.prototype.stop = function() { this.flush(), this.dirty = !0 }, L.WebGLSpriteBatch.prototype.start = function() { this.dirty = !0 }, L.WebGLSpriteBatch.prototype.destroy = function() { this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null }, L.WebGLFastSpriteBatch = function(t) {
        this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
        var e = 4 * this.size * this.vertSize,
            i = 6 * this.maxSize;
        this.vertices = new L.Float32Array(e), this.indices = new L.Uint16Array(i), this.vertexBuffer = null, this.indexBuffer = null;
        for (var s = this.lastIndexCount = 0, o = 0; s < i; s += 6, o += 4) this.indices[s + 0] = o + 0, this.indices[s + 1] = o + 1, this.indices[s + 2] = o + 2, this.indices[s + 3] = o + 0, this.indices[s + 4] = o + 2, this.indices[s + 5] = o + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
    }, L.WebGLFastSpriteBatch.prototype.constructor = L.WebGLFastSpriteBatch, L.WebGLFastSpriteBatch.prototype.setContext = function(t) { this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW) }, L.WebGLFastSpriteBatch.prototype.begin = function(t, e) { this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start() }, L.WebGLFastSpriteBatch.prototype.end = function() { this.flush() }, L.WebGLFastSpriteBatch.prototype.render = function(t) {
        var e = t.children,
            i = e[0];
        if (i.texture._uvs) {
            this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
            for (var s = 0, o = e.length; s < o; s++) this.renderSprite(e[s]);
            this.flush()
        }
    }, L.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
        if (t.visible && (t.texture.baseTexture === this.currentBaseTexture || t.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = t.texture.baseTexture, t.texture._uvs))) {
            var e, i, s, o, n, a, r = this.vertices;
            if (e = t.texture._uvs, t.texture.frame.width, t.texture.frame.height, t.texture.trim) {
                var h = t.texture.trim;
                i = (s = h.x - t.anchor.x * h.width) + t.texture.crop.width, o = (n = h.y - t.anchor.y * h.height) + t.texture.crop.height
            }
            else i = t.texture.frame.width * (1 - t.anchor.x), s = t.texture.frame.width * -t.anchor.x, o = t.texture.frame.height * (1 - t.anchor.y), n = t.texture.frame.height * -t.anchor.y;
            a = 4 * this.currentBatchSize * this.vertSize, r[a++] = s, r[a++] = n, r[a++] = t.position.x, r[a++] = t.position.y, r[a++] = t.scale.x, r[a++] = t.scale.y, r[a++] = t.rotation, r[a++] = e.x0, r[a++] = e.y1, r[a++] = t.alpha, r[a++] = i, r[a++] = n, r[a++] = t.position.x, r[a++] = t.position.y, r[a++] = t.scale.x, r[a++] = t.scale.y, r[a++] = t.rotation, r[a++] = e.x1, r[a++] = e.y1, r[a++] = t.alpha, r[a++] = i, r[a++] = o, r[a++] = t.position.x, r[a++] = t.position.y, r[a++] = t.scale.x, r[a++] = t.scale.y, r[a++] = t.rotation, r[a++] = e.x2, r[a++] = e.y2, r[a++] = t.alpha, r[a++] = s, r[a++] = o, r[a++] = t.position.x, r[a++] = t.position.y, r[a++] = t.scale.x, r[a++] = t.scale.y, r[a++] = t.rotation, r[a++] = e.x3, r[a++] = e.y3, r[a++] = t.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush()
        }
    }, L.WebGLFastSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t = this.gl;
            if (this.currentBaseTexture._glTextures[t.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, t), t.bindTexture(t.TEXTURE_2D, this.currentBaseTexture._glTextures[t.id]), this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
            else {
                var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                t.bufferSubData(t.ARRAY_BUFFER, 0, e)
            }
            t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
        }
    }, L.WebGLFastSpriteBatch.prototype.stop = function() { this.flush() }, L.WebGLFastSpriteBatch.prototype.start = function() {
        var t = this.gl;
        t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var e = this.renderSession.projection;
        t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var i = 4 * this.vertSize;
        t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36)
    }, L.WebGLFilterManager = function() { this.filterStack = [], this.offsetX = 0, this.offsetY = 0 }, L.WebGLFilterManager.prototype.constructor = L.WebGLFilterManager, L.WebGLFilterManager.prototype.setContext = function(t) { this.gl = t, this.texturePool = [], this.initShaderBuffers() }, L.WebGLFilterManager.prototype.begin = function(t, e) {
        this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
        var i = this.renderSession.projection;
        this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
    }, L.WebGLFilterManager.prototype.pushFilter = function(t) {
        var e = this.gl,
            i = this.renderSession.projection,
            s = this.renderSession.offset;
        t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new L.WebGLStencilManager, this.renderSession.stencilManager.setContext(e), e.disable(e.STENCIL_TEST), this.filterStack.push(t);
        var o = t.filterPasses[0];
        this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
        var n = this.texturePool.pop();
        n ? n.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : n = new L.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), e.bindTexture(e.TEXTURE_2D, n.texture);
        var a = t._filterArea,
            r = o.padding;
        a.x -= r, a.y -= r, a.width += 2 * r, a.height += 2 * r, a.x < 0 && (a.x = 0), a.width > this.width && (a.width = this.width), a.y < 0 && (a.y = 0), a.height > this.height && (a.height = this.height), e.bindFramebuffer(e.FRAMEBUFFER, n.frameBuffer), e.viewport(0, 0, a.width * this.renderSession.resolution, a.height * this.renderSession.resolution), i.x = a.width / 2, i.y = -a.height / 2, s.x = -a.x, s.y = -a.y, e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t._glFilterTexture = n
    }, L.WebGLFilterManager.prototype.popFilter = function() {
        var t = this.gl,
            e = this.filterStack.pop(),
            i = e._filterArea,
            s = e._glFilterTexture,
            o = this.renderSession.projection,
            n = this.renderSession.offset;
        if (1 < e.filterPasses.length) {
            t.viewport(0, 0, i.width * this.renderSession.resolution, i.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = i.height, this.vertexArray[2] = i.width, this.vertexArray[3] = i.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = i.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
            var a = s,
                r = this.texturePool.pop();
            r || (r = new L.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), r.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, r.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
            for (var h = 0; h < e.filterPasses.length - 1; h++) {
                var l = e.filterPasses[h];
                t.bindFramebuffer(t.FRAMEBUFFER, r.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, a.texture), this.applyFilterPass(l, i, i.width, i.height);
                var c = a;
                a = r, r = c
            }
            t.enable(t.BLEND), s = a, this.texturePool.push(r)
        }
        var p = e.filterPasses[e.filterPasses.length - 1];
        this.offsetX -= i.x, this.offsetY -= i.y;
        var u = this.width,
            d = this.height,
            y = 0,
            g = 0,
            f = this.buffer;
        if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
        else {
            var m = this.filterStack[this.filterStack.length - 1];
            u = (i = m._filterArea).width, d = i.height, y = i.x, g = i.y, f = m._glFilterTexture.frameBuffer
        }
        o.x = u / 2, o.y = -d / 2, n.x = y, n.y = g;
        var v = (i = e._filterArea).x - y,
            x = i.y - g;
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = v, this.vertexArray[1] = x + i.height, this.vertexArray[2] = v + i.width, this.vertexArray[3] = x + i.height, this.vertexArray[4] = v, this.vertexArray[5] = x, this.vertexArray[6] = v + i.width, this.vertexArray[7] = x, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, u * this.renderSession.resolution, d * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, f), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, s.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = e._previous_stencil_mgr, e._previous_stencil_mgr = null, 0 < this.renderSession.stencilManager.count ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(p, i, u, d), this.texturePool.push(s), e._glFilterTexture = null
    }, L.WebGLFilterManager.prototype.applyFilterPass = function(t, e, i, s) {
        var o = this.gl,
            n = t.shaders[o.id];
        n || ((n = new L.PixiShader(o)).fragmentSrc = t.fragmentSrc, n.uniforms = t.uniforms, n.init(), t.shaders[o.id] = n), this.renderSession.shaderManager.setShader(n), o.uniform2f(n.projectionVector, i / 2, -s / 2), o.uniform2f(n.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), n.syncUniforms(), o.bindBuffer(o.ARRAY_BUFFER, this.vertexBuffer), o.vertexAttribPointer(n.aVertexPosition, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, this.uvBuffer), o.vertexAttribPointer(n.aTextureCoord, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ARRAY_BUFFER, this.colorBuffer), o.vertexAttribPointer(n.colorAttribute, 2, o.FLOAT, !1, 0, 0), o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, this.indexBuffer), o.drawElements(o.TRIANGLES, 6, o.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
    }, L.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var t = this.gl;
        this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new L.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new L.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new L.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
    }, L.WebGLFilterManager.prototype.destroy = function() {
        var t = this.gl;
        this.filterStack = null, this.offsetX = 0;
        for (var e = this.offsetY = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
        this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
    }, L.FilterTexture = function(t, e, i, s) { this.gl = t, this.frameBuffer = t.createFramebuffer(), this.texture = t.createTexture(), s = s || L.scaleModes.DEFAULT, t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, s === L.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, s === L.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0), this.renderBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.renderBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), this.resize(e, i) }, L.FilterTexture.prototype.constructor = L.FilterTexture, L.FilterTexture.prototype.clear = function() {
        var t = this.gl;
        t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
    }, L.FilterTexture.prototype.resize = function(t, e) {
        if (this.width !== t || this.height !== e) {
            this.width = t, this.height = e;
            var i = this.gl;
            i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
        }
    }, L.FilterTexture.prototype.destroy = function() {
        var t = this.gl;
        t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
    }, L.CanvasBuffer = function(t, e) { this.width = t, this.height = e, this.canvas = L.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e }, L.CanvasBuffer.prototype.constructor = L.CanvasBuffer, L.CanvasBuffer.prototype.clear = function() { this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height) }, L.CanvasBuffer.prototype.resize = function(t, e) { this.width = this.canvas.width = t, this.height = this.canvas.height = e }, L.CanvasBuffer.prototype.destroy = function() { L.CanvasPool.remove(this) }, L.CanvasMaskManager = function() {}, L.CanvasMaskManager.prototype.constructor = L.CanvasMaskManager, L.CanvasMaskManager.prototype.pushMask = function(t, e) {
        var i = e.context;
        i.save();
        var s = t.alpha,
            o = t.worldTransform,
            n = e.resolution;
        i.setTransform(o.a * n, o.b * n, o.c * n, o.d * n, o.tx * n, o.ty * n), L.CanvasGraphics.renderGraphicsMask(t, i), i.clip(), t.worldAlpha = s
    }, L.CanvasMaskManager.prototype.popMask = function(t) { t.context.restore() }, L.CanvasTinter = function() {}, L.CanvasTinter.getTintedTexture = function(t, e) { var i = t.tintedTexture || L.CanvasPool.create(this); return L.CanvasTinter.tintMethod(t.texture, e, i), i }, L.CanvasTinter.tintWithMultiply = function(t, e, i) {
        var s = i.getContext("2d"),
            o = t.crop;
        i.width === o.width && i.height === o.height || (i.width = o.width, i.height = o.height), s.clearRect(0, 0, o.width, o.height), s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), s.fillRect(0, 0, o.width, o.height), s.globalCompositeOperation = "multiply", s.drawImage(t.baseTexture.source, o.x, o.y, o.width, o.height, 0, 0, o.width, o.height), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, o.x, o.y, o.width, o.height, 0, 0, o.width, o.height)
    }, L.CanvasTinter.tintWithPerPixel = function(t, e, i) {
        var s = i.getContext("2d"),
            o = t.crop;
        i.width = o.width, i.height = o.height, s.globalCompositeOperation = "copy", s.drawImage(t.baseTexture.source, o.x, o.y, o.width, o.height, 0, 0, o.width, o.height);
        for (var n = L.hex2rgb(e), a = n[0], r = n[1], h = n[2], l = s.getImageData(0, 0, o.width, o.height), c = l.data, p = 0; p < c.length; p += 4)
            if (c[p + 0] *= a, c[p + 1] *= r, c[p + 2] *= h, !L.CanvasTinter.canHandleAlpha) {
                var u = c[p + 3];
                c[p + 0] /= 255 / u, c[p + 1] /= 255 / u, c[p + 2] /= 255 / u
            }
        s.putImageData(l, 0, 0)
    }, L.CanvasTinter.checkInverseAlpha = function() {
        var t = new L.CanvasBuffer(2, 1);
        t.context.fillStyle = "rgba(10, 20, 30, 0.5)", t.context.fillRect(0, 0, 1, 1);
        var e = t.context.getImageData(0, 0, 1, 1);
        if (null === e) return !1;
        t.context.putImageData(e, 1, 0);
        var i = t.context.getImageData(1, 0, 1, 1);
        return i.data[0] === e.data[0] && i.data[1] === e.data[1] && i.data[2] === e.data[2] && i.data[3] === e.data[3]
    }, L.CanvasTinter.canHandleAlpha = L.CanvasTinter.checkInverseAlpha(), L.CanvasTinter.canUseMultiply = L.canUseNewCanvasBlendModes(), L.CanvasTinter.tintMethod = L.CanvasTinter.canUseMultiply ? L.CanvasTinter.tintWithMultiply : L.CanvasTinter.tintWithPerPixel, L.CanvasRenderer = function(t) { this.game = t, L.defaultRenderer || (L.defaultRenderer = this), this.type = L.CANVAS_RENDERER, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", { alpha: this.transparent }), this.refresh = !0, this.count = 0, this.maskManager = new L.CanvasMaskManager, this.renderSession = { context: this.context, maskManager: this.maskManager, scaleMode: null, smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context), roundPixels: !1 }, this.mapBlendModes(), this.resize(this.width, this.height) }, L.CanvasRenderer.prototype.constructor = L.CanvasRenderer, L.CanvasRenderer.prototype.render = function(t) { this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t) }, L.CanvasRenderer.prototype.destroy = function(t) { void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null }, L.CanvasRenderer.prototype.resize = function(t, e) { this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === L.scaleModes.LINEAR) }, L.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) { this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i) }, L.CanvasRenderer.prototype.mapBlendModes = function() {
        if (!L.blendModesCanvas) {
            var t = [],
                e = L.blendModes,
                i = L.canUseNewCanvasBlendModes();
            t[e.NORMAL] = "source-over", t[e.ADD] = "lighter", t[e.MULTIPLY] = i ? "multiply" : "source-over", t[e.SCREEN] = i ? "screen" : "source-over", t[e.OVERLAY] = i ? "overlay" : "source-over", t[e.DARKEN] = i ? "darken" : "source-over", t[e.LIGHTEN] = i ? "lighten" : "source-over", t[e.COLOR_DODGE] = i ? "color-dodge" : "source-over", t[e.COLOR_BURN] = i ? "color-burn" : "source-over", t[e.HARD_LIGHT] = i ? "hard-light" : "source-over", t[e.SOFT_LIGHT] = i ? "soft-light" : "source-over", t[e.DIFFERENCE] = i ? "difference" : "source-over", t[e.EXCLUSION] = i ? "exclusion" : "source-over", t[e.HUE] = i ? "hue" : "source-over", t[e.SATURATION] = i ? "saturation" : "source-over", t[e.COLOR] = i ? "color" : "source-over", t[e.LUMINOSITY] = i ? "luminosity" : "source-over", L.blendModesCanvas = t
        }
    }, L.BaseTexture = function(t, e) { this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = e || L.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1) }, L.BaseTexture.prototype.constructor = L.BaseTexture, L.BaseTexture.prototype.forceLoaded = function(t, e) { this.hasLoaded = !0, this.width = t, this.height = e, this.dirty() }, L.BaseTexture.prototype.destroy = function() { this.source && L.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU() }, L.BaseTexture.prototype.updateSourceImage = function(t) {}, L.BaseTexture.prototype.dirty = function() { for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0 }, L.BaseTexture.prototype.unloadFromGPU = function() {
        this.dirty();
        for (var t = this._glTextures.length - 1; 0 <= t; t--) {
            var e = this._glTextures[t],
                i = L.glContexts[t];
            i && e && i.deleteTexture(e)
        }
        this._glTextures.length = 0, this.dirty()
    }, L.BaseTexture.fromCanvas = function(t, e) { return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), new L.BaseTexture(t, e) }, L.TextureSilentFail = !1, L.Texture = function(t, e, i, s) { this.noFrame = !1, e || (this.noFrame = !0, e = new L.Rectangle(0, 0, 1, 1)), t instanceof L.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = e, this.trim = s, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = i || new L.Rectangle(0, 0, 1, 1), t.hasLoaded && (this.noFrame && (e = new L.Rectangle(0, 0, t.width, t.height)), this.setFrame(e)) }, L.Texture.prototype.constructor = L.Texture, L.Texture.prototype.onBaseTextureLoaded = function() {
        var t = this.baseTexture;
        this.noFrame && (this.frame = new L.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
    }, L.Texture.prototype.destroy = function(t) { t && this.baseTexture.destroy(), this.valid = !1 }, L.Texture.prototype.setFrame = function(t) {
        if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
        else {
            if (!L.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            this.valid = !1
        }
    }, L.Texture.prototype._updateUvs = function() {
        this._uvs || (this._uvs = new L.TextureUvs);
        var t = this.crop,
            e = this.baseTexture.width,
            i = this.baseTexture.height;
        this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / i, this._uvs.x1 = (t.x + t.width) / e, this._uvs.y1 = t.y / i, this._uvs.x2 = (t.x + t.width) / e, this._uvs.y2 = (t.y + t.height) / i, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.height) / i
    }, L.Texture.fromCanvas = function(t, e) { var i = L.BaseTexture.fromCanvas(t, e); return new L.Texture(i) }, L.TextureUvs = function() { this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0 }, L.RenderTexture = function(t, e, i, s, o) {
        if (this.width = t || 100, this.height = e || 100, this.resolution = o || 1, this.frame = new L.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new L.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new L.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = s || L.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, L.Texture.call(this, this.baseTexture, new L.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = i || L.defaultRenderer, this.renderer.type === L.WEBGL_RENDERER) {
            var n = this.renderer.gl;
            this.baseTexture._dirty[n.id] = !1, this.textureBuffer = new L.FilterTexture(n, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[n.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new L.Point(.5 * this.width, .5 * -this.height)
        }
        else this.render = this.renderCanvas, this.textureBuffer = new L.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
        this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs()
    }, L.RenderTexture.prototype = Object.create(L.Texture.prototype), L.RenderTexture.prototype.constructor = L.RenderTexture, L.RenderTexture.prototype.resize = function(t, e, i) { t === this.width && e === this.height || (this.valid = 0 < t && 0 < e, this.width = t, this.height = e, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = e * this.resolution, i && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === L.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height)) }, L.RenderTexture.prototype.clear = function() { this.valid && (this.renderer.type === L.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear()) }, L.RenderTexture.prototype.renderWebGL = function(t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var s = t.worldTransform;
            s.identity(), s.translate(0, 2 * this.projection.y), e && s.append(e), s.scale(1, -1);
            for (var o = 0; o < t.children.length; o++) t.children[o].updateTransform();
            var n = this.renderer.gl;
            n.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), n.bindFramebuffer(n.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0
        }
    }, L.RenderTexture.prototype.renderCanvas = function(t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var s = t.worldTransform;
            s.identity(), e && s.append(e);
            for (var o = 0; o < t.children.length; o++) t.children[o].updateTransform();
            i && this.textureBuffer.clear();
            var n = this.renderer.resolution;
            this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = n
        }
    }, L.RenderTexture.prototype.getImage = function() { var t = new Image; return t.src = this.getBase64(), t }, L.RenderTexture.prototype.getBase64 = function() { return this.getCanvas().toDataURL() }, L.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type !== L.WEBGL_RENDERER) return this.textureBuffer.canvas;
        var t = this.renderer.gl,
            e = this.textureBuffer.width,
            i = this.textureBuffer.height,
            s = new Uint8Array(4 * e * i);
        t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, e, i, t.RGBA, t.UNSIGNED_BYTE, s), t.bindFramebuffer(t.FRAMEBUFFER, null);
        var o = new L.CanvasBuffer(e, i),
            n = o.context.getImageData(0, 0, e, i);
        return n.data.set(s), o.context.putImageData(n, 0, 0), o.canvas
    }, L.AbstractFilter = function(t, e) { this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = e || {}, this.fragmentSrc = t || [] }, L.AbstractFilter.prototype.constructor = L.AbstractFilter, L.AbstractFilter.prototype.syncUniforms = function() { for (var t = 0, e = this.shaders.length; t < e; t++) this.shaders[t].dirty = !0 }, L.Strip = function(t) { L.DisplayObjectContainer.call(this), this.texture = t, this.uvs = new L.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new L.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new L.Float32Array([1, 1, 1, 1]), this.indices = new L.Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = L.blendModes.NORMAL, this.canvasPadding = 0, this.drawMode = L.Strip.DrawModes.TRIANGLE_STRIP }, L.Strip.prototype = Object.create(L.DisplayObjectContainer.prototype), L.Strip.prototype.constructor = L.Strip, L.Strip.prototype._renderWebGL = function(t) {!this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start()) }, L.Strip.prototype._initWebGL = function(t) {
        var e = t.gl;
        this._vertexBuffer = e.createBuffer(), this._indexBuffer = e.createBuffer(), this._uvBuffer = e.createBuffer(), this._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer), e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
    }, L.Strip.prototype._renderStrip = function(t) {
        var e = t.gl,
            i = t.projection,
            s = t.offset,
            o = t.shaderManager.stripShader,
            n = this.drawMode === L.Strip.DrawModes.TRIANGLE_STRIP ? e.TRIANGLE_STRIP : e.TRIANGLES;
        t.blendModeManager.setBlendMode(this.blendMode), e.uniformMatrix3fv(o.translationMatrix, !1, this.worldTransform.toArray(!0)), e.uniform2f(o.projectionVector, i.x, -i.y), e.uniform2f(o.offsetVector, -s.x, -s.y), e.uniform1f(o.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.STATIC_DRAW), e.vertexAttribPointer(o.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.vertexAttribPointer(o.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)) : (e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices), e.vertexAttribPointer(o.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.vertexAttribPointer(o.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), e.drawElements(n, this.indices.length, e.UNSIGNED_SHORT, 0)
    }, L.Strip.prototype._renderCanvas = function(t) {
        var e = t.context,
            i = this.worldTransform,
            s = i.tx * t.resolution + t.shakeX,
            o = i.ty * t.resolution + t.shakeY;
        t.roundPixels ? e.setTransform(i.a, i.b, i.c, i.d, 0 | s, 0 | o) : e.setTransform(i.a, i.b, i.c, i.d, s, o), this.drawMode === L.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(e) : this._renderCanvasTriangles(e)
    }, L.Strip.prototype._renderCanvasTriangleStrip = function(t) {
        var e = this.vertices,
            i = this.uvs,
            s = e.length / 2;
        this.count++;
        for (var o = 0; o < s - 2; o++) {
            var n = 2 * o;
            this._renderCanvasDrawTriangle(t, e, i, n, n + 2, n + 4)
        }
    }, L.Strip.prototype._renderCanvasTriangles = function(t) {
        var e = this.vertices,
            i = this.uvs,
            s = this.indices,
            o = s.length;
        this.count++;
        for (var n = 0; n < o; n += 3) {
            var a = 2 * s[n],
                r = 2 * s[n + 1],
                h = 2 * s[n + 2];
            this._renderCanvasDrawTriangle(t, e, i, a, r, h)
        }
    }, L.Strip.prototype._renderCanvasDrawTriangle = function(t, e, i, s, o, n) {
        var a = this.texture.baseTexture.source,
            r = this.texture.width,
            h = this.texture.height,
            l = e[s],
            c = e[o],
            p = e[n],
            u = e[s + 1],
            d = e[o + 1],
            y = e[n + 1],
            g = i[s] * r,
            f = i[o] * r,
            m = i[n] * r,
            v = i[s + 1] * h,
            x = i[o + 1] * h,
            b = i[n + 1] * h;
        if (0 < this.canvasPadding) {
            var w = this.canvasPadding / this.worldTransform.a,
                P = this.canvasPadding / this.worldTransform.d,
                _ = (l + c + p) / 3,
                T = (u + d + y) / 3,
                S = l - _,
                k = u - T,
                B = Math.sqrt(S * S + k * k);
            l = _ + S / B * (B + w), u = T + k / B * (B + P), k = d - T, c = _ + (S = c - _) / (B = Math.sqrt(S * S + k * k)) * (B + w), d = T + k / B * (B + P), k = y - T, p = _ + (S = p - _) / (B = Math.sqrt(S * S + k * k)) * (B + w), y = T + k / B * (B + P)
        }
        t.save(), t.beginPath(), t.moveTo(l, u), t.lineTo(c, d), t.lineTo(p, y), t.closePath(), t.clip();
        var A = g * x + v * m + f * b - x * m - v * f - g * b,
            C = l * x + v * p + c * b - x * p - v * c - l * b,
            I = g * c + l * m + f * p - c * m - l * f - g * p,
            E = g * x * p + v * c * m + l * f * b - l * x * m - v * f * p - g * c * b,
            O = u * x + v * y + d * b - x * y - v * d - u * b,
            M = g * d + u * m + f * y - d * m - u * f - g * y,
            L = g * x * y + v * d * m + u * f * b - u * x * m - v * f * y - g * d * b;
        t.transform(C / A, O / A, I / A, M / A, E / A, L / A), t.drawImage(a, 0, 0), t.restore()
    }, L.Strip.prototype.renderStripFlat = function(t) {
        var e = this.context,
            i = t.vertices,
            s = i.length / 2;
        this.count++, e.beginPath();
        for (var o = 1; o < s - 2; o++) {
            var n = 2 * o,
                a = i[n],
                r = i[n + 2],
                h = i[n + 4],
                l = i[n + 1],
                c = i[n + 3],
                p = i[n + 5];
            e.moveTo(a, l), e.lineTo(r, c), e.lineTo(h, p)
        }
        e.fillStyle = "#FF0000", e.fill(), e.closePath()
    }, L.Strip.prototype.onTextureUpdate = function() { this.updateFrame = !0 }, L.Strip.prototype.getBounds = function(t) {
        for (var e = t || this.worldTransform, i = e.a, s = e.b, o = e.c, n = e.d, a = e.tx, r = e.ty, h = -1 / 0, l = -1 / 0, c = 1 / 0, p = 1 / 0, u = this.vertices, d = 0, y = u.length; d < y; d += 2) {
            var g = u[d],
                f = u[d + 1],
                m = i * g + o * f + a,
                v = n * f + s * g + r;
            c = m < c ? m : c, p = v < p ? v : p, h = h < m ? m : h, l = l < v ? v : l
        }
        if (c === -1 / 0 || l === 1 / 0) return L.EmptyRectangle;
        var x = this._bounds;
        return x.x = c, x.width = h - c, x.y = p, x.height = l - p, this._currentBounds = x
    }, L.Strip.DrawModes = { TRIANGLE_STRIP: 0, TRIANGLES: 1 }, L.Rope = function(t, e) { L.Strip.call(this, t), this.points = e, this.vertices = new L.Float32Array(4 * e.length), this.uvs = new L.Float32Array(4 * e.length), this.colors = new L.Float32Array(2 * e.length), this.indices = new L.Uint16Array(2 * e.length), this.refresh() }, L.Rope.prototype = Object.create(L.Strip.prototype), L.Rope.prototype.constructor = L.Rope, L.Rope.prototype.refresh = function() {
        var t = this.points;
        if (!(t.length < 1)) {
            var e = this.uvs,
                i = (t[0], this.indices),
                s = this.colors;
            this.count -= .2, e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, s[0] = 1, s[1] = 1, i[0] = 0, i[1] = 1;
            for (var o, n, a, r = t.length, h = 1; h < r; h++) o = t[h], a = h / (r - 1), e[(n = 4 * h) + 3] = (e[n] = a, e[n + 1] = 0, e[n + 2] = a, 1), s[n = 2 * h] = 1, s[n + 1] = 1, i[n = 2 * h] = n, i[n + 1] = n + 1, o
        }
    }, L.Rope.prototype.updateTransform = function() {
        var t = this.points;
        if (!(t.length < 1)) {
            var e, i = t[0],
                s = { x: 0, y: 0 };
            this.count -= .2;
            for (var o, n, a, r, h = this.vertices, l = t.length, c = 0; c < l; c++) o = t[c], n = 4 * c, e = c < t.length - 1 ? t[c + 1] : o, s.y = -(e.x - i.x), s.x = e.y - i.y, 1 < 10 * (1 - c / (l - 1)) && 1, a = Math.sqrt(s.x * s.x + s.y * s.y), r = this.texture.height / 2, s.x /= a, s.y /= a, s.x *= r, s.y *= r, h[n] = o.x + s.x, h[n + 1] = o.y + s.y, h[n + 2] = o.x - s.x, h[n + 3] = o.y - s.y, i = o;
            L.DisplayObjectContainer.prototype.updateTransform.call(this)
        }
    }, L.Rope.prototype.setTexture = function(t) { this.texture = t }, L.TilingSprite = function(t, e, i) { L.Sprite.call(this, t), this._width = e || 128, this._height = i || 128, this.tileScale = new L.Point(1, 1), this.tileScaleOffset = new L.Point(1, 1), this.tilePosition = new L.Point, this.renderable = !0, this.tint = 16777215, this.textureDebug = !1, this.blendMode = L.blendModes.NORMAL, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0 }, L.TilingSprite.prototype = Object.create(L.Sprite.prototype), L.TilingSprite.prototype.constructor = L.TilingSprite, L.TilingSprite.prototype.setTexture = function(t) { this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215) }, L.TilingSprite.prototype._renderWebGL = function(t) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                this.tilingTexture.needsUpdate && (t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
            }
            t.spriteBatch.renderTilingSprite(this);
            for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
            t.spriteBatch.stop(), this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this._mask, t), t.spriteBatch.start()
        }
    }, L.TilingSprite.prototype._renderCanvas = function(t) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            var e = t.context;
            this._mask && t.maskManager.pushMask(this._mask, t), e.globalAlpha = this.worldAlpha;
            var i = this.worldTransform,
                s = t.resolution,
                o = i.tx * s + t.shakeX,
                n = i.ty * s + t.shakeY;
            if (e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, o, n), this.refreshTexture) {
                if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                this.tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
            }
            var a = t.currentBlendMode;
            this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = L.blendModesCanvas[t.currentBlendMode]);
            var r = this.tilePosition,
                h = this.tileScale;
            r.x %= this.tilingTexture.baseTexture.width, r.y %= this.tilingTexture.baseTexture.height, e.scale(h.x, h.y), e.translate(r.x + this.anchor.x * -this._width, r.y + this.anchor.y * -this._height), e.fillStyle = this.tilePattern;
            o = -r.x, n = -r.y;
            var l = this._width / h.x,
                c = this._height / h.y;
            t.roundPixels && (o |= 0, n |= 0, l |= 0, c |= 0), e.fillRect(o, n, l, c), e.scale(1 / h.x, 1 / h.y), e.translate(-r.x + this.anchor.x * this._width, -r.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
            for (var p = 0; p < this.children.length; p++) this.children[p]._renderCanvas(t);
            a !== this.blendMode && (t.currentBlendMode = a, e.globalCompositeOperation = L.blendModesCanvas[a])
        }
    }, L.TilingSprite.prototype.onTextureUpdate = function() {}, L.TilingSprite.prototype.generateTilingTexture = function(t, e) {
        if (this.texture.baseTexture.hasLoaded) {
            var i = this.texture,
                s = i.frame,
                o = this._frame.sourceSizeW || this._frame.width,
                n = this._frame.sourceSizeH || this._frame.height,
                a = 0,
                r = 0;
            this._frame.trimmed && (a = this._frame.spriteSourceSizeX, r = this._frame.spriteSourceSizeY), t && (o = L.getNextPowerOfTwo(o), n = L.getNextPowerOfTwo(n)), this.canvasBuffer ? (this.canvasBuffer.resize(o, n), this.tilingTexture.baseTexture.width = o, this.tilingTexture.baseTexture.height = n) : (this.canvasBuffer = new L.CanvasBuffer(o, n), this.tilingTexture = L.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0), this.tilingTexture.needsUpdate = !0, this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, o, n));
            var h = i.crop.width,
                l = i.crop.height;
            h === o && l === n || (h = o, l = n), this.canvasBuffer.context.drawImage(i.baseTexture.source, i.crop.x, i.crop.y, i.crop.width, i.crop.height, a, r, h, l), this.tileScaleOffset.x = s.width / o, this.tileScaleOffset.y = s.height / n, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
        }
    }, L.TilingSprite.prototype.getBounds = function() {
        var t = this._width,
            e = this._height,
            i = t * (1 - this.anchor.x),
            s = t * -this.anchor.x,
            o = e * (1 - this.anchor.y),
            n = e * -this.anchor.y,
            a = this.worldTransform,
            r = a.a,
            h = a.b,
            l = a.c,
            c = a.d,
            p = a.tx,
            u = a.ty,
            d = r * s + l * n + p,
            y = c * n + h * s + u,
            g = r * i + l * n + p,
            f = c * n + h * i + u,
            m = r * i + l * o + p,
            v = c * o + h * i + u,
            x = r * s + l * o + p,
            b = c * o + h * s + u,
            w = -1 / 0,
            P = -1 / 0,
            _ = 1 / 0,
            T = 1 / 0;
        _ = x < (_ = m < (_ = g < (_ = d < _ ? d : _) ? g : _) ? m : _) ? x : _, T = b < (T = v < (T = f < (T = y < T ? y : T) ? f : T) ? v : T) ? b : T, w = (w = (w = (w = w < d ? d : w) < g ? g : w) < m ? m : w) < x ? x : w, P = (P = (P = (P = P < y ? y : P) < f ? f : P) < v ? v : P) < b ? b : P;
        var S = this._bounds;
        return S.x = _, S.width = w - _, S.y = T, S.height = P - T, this._currentBounds = S
    }, L.TilingSprite.prototype.destroy = function() { L.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null) }, Object.defineProperty(L.TilingSprite.prototype, "width", { get: function() { return this._width }, set: function(t) { this._width = t } }), Object.defineProperty(L.TilingSprite.prototype, "height", { get: function() { return this._height }, set: function(t) { this._height = t } }), "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = L), exports.PIXI = L) : "undefined" != typeof define && define.amd ? define("PIXI", t.PIXI = L) : t.PIXI = L, L
}.call(this),
    function() {
        var n, t = this,
            H = H || { VERSION: "2.6.12", GAMES: [], AUTO: 0, CANVAS: 1, WEBGL: 2, HEADLESS: 3, NONE: 0, LEFT: 1, RIGHT: 2, UP: 3, DOWN: 4, SPRITE: 0, BUTTON: 1, IMAGE: 2, GRAPHICS: 3, TEXT: 4, TILESPRITE: 5, BITMAPTEXT: 6, GROUP: 7, RENDERTEXTURE: 8, TILEMAP: 9, TILEMAPLAYER: 10, EMITTER: 11, POLYGON: 12, BITMAPDATA: 13, CANVAS_FILTER: 14, WEBGL_FILTER: 15, ELLIPSE: 16, SPRITEBATCH: 17, RETROFONT: 18, POINTER: 19, ROPE: 20, CIRCLE: 21, RECTANGLE: 22, LINE: 23, MATRIX: 24, POINT: 25, ROUNDEDRECTANGLE: 26, CREATURE: 27, VIDEO: 28, PENDING_ATLAS: -1, HORIZONTAL: 0, VERTICAL: 1, LANDSCAPE: 0, PORTRAIT: 1, ANGLE_UP: 270, ANGLE_DOWN: 90, ANGLE_LEFT: 180, ANGLE_RIGHT: 0, ANGLE_NORTH_EAST: 315, ANGLE_NORTH_WEST: 225, ANGLE_SOUTH_EAST: 45, ANGLE_SOUTH_WEST: 135, TOP_LEFT: 0, TOP_CENTER: 1, TOP_RIGHT: 2, LEFT_TOP: 3, LEFT_CENTER: 4, LEFT_BOTTOM: 5, CENTER: 6, RIGHT_TOP: 7, RIGHT_CENTER: 8, RIGHT_BOTTOM: 9, BOTTOM_LEFT: 10, BOTTOM_CENTER: 11, BOTTOM_RIGHT: 12, blendModes: { NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16 }, scaleModes: { DEFAULT: 0, LINEAR: 0, NEAREST: 1 }, PIXI: PIXI || {} };
        if (Math.trunc || (Math.trunc = function(t) { return t < 0 ? Math.ceil(t) : Math.floor(t) }), Function.prototype.bind || (Function.prototype.bind = (n = Array.prototype.slice, function(e) {
                var i = this,
                    s = n.call(arguments, 1);
                if ("function" != typeof i) throw new TypeError;

                function o() {
                    var t = s.concat(n.call(arguments));
                    i.apply(this instanceof o ? this : e, t)
                }
                return o.prototype = function t(e) { if (e && (t.prototype = e), !(this instanceof t)) return new t }(i.prototype), o
            })), Array.isArray || (Array.isArray = function(t) { return "[object Array]" === Object.prototype.toString.call(t) }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                "use strict";
                if (null == this) throw new TypeError;
                var e = Object(this),
                    i = e.length >>> 0;
                if ("function" != typeof t) throw new TypeError;
                for (var s = 2 <= arguments.length ? arguments[1] : void 0, o = 0; o < i; o++) o in e && t.call(s, e[o], o, e)
            }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
            var e = function(t) {
                var e = new Array;
                window[t] = function(t) { if ("number" == typeof t) { Array.call(this, t), this.length = t; for (var e = 0; e < this.length; e++) this[e] = 0 } else { Array.call(this, t.length), this.length = t.length; for (e = 0; e < this.length; e++) this[e] = t[e] } }, window[t].prototype = e, window[t].constructor = window[t]
            };
            e("Uint32Array"), e("Int16Array")
        }

        function s(t, e) { this._scaleFactor = t, this._deltaMode = e, this.originalEvent = null }
        for (var i in window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), /firefox/i.test(navigator.userAgent) && (window.oldGetComputedStyle = window.getComputedStyle, window.getComputedStyle = function(t, e) { var i = window.oldGetComputedStyle(t, e); return null === i ? { getPropertyValue: function() {} } : i }), H.Utils = {
                reverseString: function(t) { return t.split("").reverse().join("") },
                getProperty: function(t, e) { for (var i = e.split("."), s = i.pop(), o = i.length, n = 1, a = i[0]; n < o && (t = t[a]);) a = i[n], n++; return t ? t[s] : null },
                setProperty: function(t, e, i) { for (var s = e.split("."), o = s.pop(), n = s.length, a = 1, r = s[0]; a < n && (t = t[r]);) r = s[a], a++; return t && (t[o] = i), t },
                chanceRoll: function(t) { return void 0 === t && (t = 50), 0 < t && 100 * Math.random() <= t },
                randomChoice: function(t, e) { return Math.random() < .5 ? t : e },
                parseDimension: function(t, e) { var i = 0; return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, 0 === e ? window.innerWidth * i : window.innerHeight * i) : parseInt(t, 10) : t },
                pad: function(t, e, i, s) {
                    if (void 0 === e) e = 0;
                    if (void 0 === i) i = " ";
                    if (void 0 === s) s = 3;
                    var o = 0;
                    if (e + 1 >= (t = t.toString()).length) switch (s) {
                        case 1:
                            t = new Array(e + 1 - t.length).join(i) + t;
                            break;
                        case 3:
                            var n = Math.ceil((o = e - t.length) / 2);
                            t = new Array(o - n + 1).join(i) + t + new Array(n + 1).join(i);
                            break;
                        default:
                            t += new Array(e + 1 - t.length).join(i)
                    }
                    return t
                },
                isPlainObject: function(t) { if ("object" != typeof t || t.nodeType || t === t.window) return !1; try { if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1 } catch (t) { return !1 } return !0 },
                extend: function() {
                    var t, e, i, s, o, n, a = arguments[0] || {},
                        r = 1,
                        h = arguments.length,
                        l = !1;
                    for ("boolean" == typeof a && (l = a, a = arguments[1] || {}, r = 2), h === r && (a = this, --r); r < h; r++)
                        if (null != (t = arguments[r]))
                            for (e in t) i = a[e], a !== (s = t[e]) && (l && s && (H.Utils.isPlainObject(s) || (o = Array.isArray(s))) ? (n = o ? (o = !1, i && Array.isArray(i) ? i : []) : i && H.Utils.isPlainObject(i) ? i : {}, a[e] = H.Utils.extend(l, n, s)) : void 0 !== s && (a[e] = s));
                    return a
                },
                mixinPrototype: function(t, e, i) {
                    void 0 === i && (i = !1);
                    for (var s = Object.keys(e), o = 0; o < s.length; o++) {
                        var n = s[o],
                            a = e[n];
                        !i && n in t || (!a || "function" != typeof a.get && "function" != typeof a.set ? t[n] = a : "function" == typeof a.clone ? t[n] = a.clone() : Object.defineProperty(t, n, a))
                    }
                },
                mixin: function(t, e) {
                    if (!t || "object" != typeof t) return e;
                    for (var i in t) {
                        var s = t[i];
                        if (!s.childNodes && !s.cloneNode) {
                            var o = typeof t[i];
                            t[i] && "object" === o ? typeof e[i] === o ? e[i] = H.Utils.mixin(t[i], e[i]) : e[i] = H.Utils.mixin(t[i], new s.constructor) : e[i] = t[i]
                        }
                    }
                    return e
                }
            }, H.Circle = function(t, e, i) { t = t || 0, e = e || 0, i = i || 0, this.x = t, this.y = e, this._diameter = i, (this._radius = 0) < i && (this._radius = .5 * i), this.type = H.CIRCLE }, H.Circle.prototype = {
                circumference: function() { return Math.PI * this._radius * 2 },
                random: function(t) {
                    void 0 === t && (t = new H.Point);
                    var e = 2 * Math.PI * Math.random(),
                        i = Math.random() + Math.random(),
                        s = 1 < i ? 2 - i : i,
                        o = s * Math.cos(e),
                        n = s * Math.sin(e);
                    return t.x = this.x + o * this.radius, t.y = this.y + n * this.radius, t
                },
                getBounds: function() { return new H.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter) },
                setTo: function(t, e, i) { return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this },
                copyFrom: function(t) { return this.setTo(t.x, t.y, t.diameter) },
                copyTo: function(t) { return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t },
                distance: function(t, e) { var i = H.Math.distance(this.x, this.y, t.x, t.y); return e ? Math.round(i) : i },
                clone: function(t) { return null == t ? t = new H.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t },
                contains: function(t, e) { return H.Circle.contains(this, t, e) },
                circumferencePoint: function(t, e, i) { return H.Circle.circumferencePoint(this, t, e, i) },
                offset: function(t, e) { return this.x += t, this.y += e, this },
                offsetPoint: function(t) { return this.offset(t.x, t.y) },
                toString: function() { return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]" }
            }, H.Circle.prototype.constructor = H.Circle, Object.defineProperty(H.Circle.prototype, "diameter", { get: function() { return this._diameter }, set: function(t) { 0 < t && (this._diameter = t, this._radius = .5 * t) } }), Object.defineProperty(H.Circle.prototype, "radius", { get: function() { return this._radius }, set: function(t) { 0 < t && (this._radius = t, this._diameter = 2 * t) } }), Object.defineProperty(H.Circle.prototype, "left", { get: function() { return this.x - this._radius }, set: function(t) { t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t } }), Object.defineProperty(H.Circle.prototype, "right", { get: function() { return this.x + this._radius }, set: function(t) { t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x } }), Object.defineProperty(H.Circle.prototype, "top", { get: function() { return this.y - this._radius }, set: function(t) { t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t } }), Object.defineProperty(H.Circle.prototype, "bottom", { get: function() { return this.y + this._radius }, set: function(t) { t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y } }), Object.defineProperty(H.Circle.prototype, "area", { get: function() { return 0 < this._radius ? Math.PI * this._radius * this._radius : 0 } }), Object.defineProperty(H.Circle.prototype, "empty", { get: function() { return 0 === this._diameter }, set: function(t) {!0 === t && this.setTo(0, 0, 0) } }), H.Circle.contains = function(t, e, i) { return 0 < t.radius && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius }, H.Circle.equals = function(t, e) { return t.x === e.x && t.y === e.y && t.diameter === e.diameter }, H.Circle.intersects = function(t, e) { return H.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius }, H.Circle.circumferencePoint = function(t, e, i, s) { return void 0 === i && (i = !1), void 0 === s && (s = new H.Point), !0 === i && (e = H.Math.degToRad(e)), s.x = t.x + t.radius * Math.cos(e), s.y = t.y + t.radius * Math.sin(e), s }, H.Circle.intersectsRectangle = function(t, e) {
                var i = Math.abs(t.x - e.x - e.halfWidth);
                if (e.halfWidth + t.radius < i) return !1;
                var s = Math.abs(t.y - e.y - e.halfHeight);
                if (e.halfHeight + t.radius < s) return !1;
                if (i <= e.halfWidth || s <= e.halfHeight) return !0;
                var o = i - e.halfWidth,
                    n = s - e.halfHeight;
                return o * o + n * n <= t.radius * t.radius
            }, PIXI.Circle = H.Circle, H.Ellipse = function(t, e, i, s) { t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s, this.type = H.ELLIPSE }, H.Ellipse.prototype = {
                setTo: function(t, e, i, s) { return this.x = t, this.y = e, this.width = i, this.height = s, this },
                getBounds: function() { return new H.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height) },
                copyFrom: function(t) { return this.setTo(t.x, t.y, t.width, t.height) },
                copyTo: function(t) { return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t },
                clone: function(t) { return null == t ? t = new H.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t },
                contains: function(t, e) { return H.Ellipse.contains(this, t, e) },
                random: function(t) {
                    void 0 === t && (t = new H.Point);
                    var e = Math.random() * Math.PI * 2,
                        i = Math.random();
                    return t.x = Math.sqrt(i) * Math.cos(e), t.y = Math.sqrt(i) * Math.sin(e), t.x = this.x + t.x * this.width / 2, t.y = this.y + t.y * this.height / 2, t
                },
                toString: function() { return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]" }
            }, H.Ellipse.prototype.constructor = H.Ellipse, Object.defineProperty(H.Ellipse.prototype, "left", { get: function() { return this.x }, set: function(t) { this.x = t } }), Object.defineProperty(H.Ellipse.prototype, "right", { get: function() { return this.x + this.width }, set: function(t) { t < this.x ? this.width = 0 : this.width = t - this.x } }), Object.defineProperty(H.Ellipse.prototype, "top", { get: function() { return this.y }, set: function(t) { this.y = t } }), Object.defineProperty(H.Ellipse.prototype, "bottom", { get: function() { return this.y + this.height }, set: function(t) { t < this.y ? this.height = 0 : this.height = t - this.y } }), Object.defineProperty(H.Ellipse.prototype, "empty", { get: function() { return 0 === this.width || 0 === this.height }, set: function(t) {!0 === t && this.setTo(0, 0, 0, 0) } }), H.Ellipse.contains = function(t, e, i) {
                if (t.width <= 0 || t.height <= 0) return !1;
                var s = (e - t.x) / t.width - .5,
                    o = (i - t.y) / t.height - .5;
                return (s *= s) + (o *= o) < .25
            }, PIXI.Ellipse = H.Ellipse, H.Line = function(t, e, i, s) { t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.start = new H.Point(t, e), this.end = new H.Point(i, s), this.type = H.LINE }, H.Line.prototype = {
                setTo: function(t, e, i, s) { return this.start.setTo(t, e), this.end.setTo(i, s), this },
                fromSprite: function(t, e, i) { return void 0 === i && (i = !1), i ? this.setTo(t.center.x, t.center.y, e.center.x, e.center.y) : this.setTo(t.x, t.y, e.x, e.y) },
                fromAngle: function(t, e, i, s) { return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * s, e + Math.sin(i) * s), this },
                rotate: function(t, e) {
                    var i = (this.start.x + this.end.x) / 2,
                        s = (this.start.y + this.end.y) / 2;
                    return this.start.rotate(i, s, t, e), this.end.rotate(i, s, t, e), this
                },
                rotateAround: function(t, e, i, s) { return this.start.rotate(t, e, i, s), this.end.rotate(t, e, i, s), this },
                intersects: function(t, e, i) { return H.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, i) },
                reflect: function(t) { return H.Line.reflect(this, t) },
                midPoint: function(t) { return void 0 === t && (t = new H.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t },
                centerOn: function(t, e) {
                    var i = t - (this.start.x + this.end.x) / 2,
                        s = e - (this.start.y + this.end.y) / 2;
                    this.start.add(i, s), this.end.add(i, s)
                },
                pointOnLine: function(t, e) { return (t - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (e - this.start.y) },
                pointOnSegment: function(t, e) {
                    var i = Math.min(this.start.x, this.end.x),
                        s = Math.max(this.start.x, this.end.x),
                        o = Math.min(this.start.y, this.end.y),
                        n = Math.max(this.start.y, this.end.y);
                    return this.pointOnLine(t, e) && i <= t && t <= s && o <= e && e <= n
                },
                random: function(t) { void 0 === t && (t = new H.Point); var e = Math.random(); return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t },
                coordinatesOnLine: function(t, e) {
                    void 0 === t && (t = 1), void 0 === e && (e = []);
                    var i = Math.round(this.start.x),
                        s = Math.round(this.start.y),
                        o = Math.round(this.end.x),
                        n = Math.round(this.end.y),
                        a = Math.abs(o - i),
                        r = Math.abs(n - s),
                        h = i < o ? 1 : -1,
                        l = s < n ? 1 : -1,
                        c = a - r;
                    e.push([i, s]);
                    for (var p = 1; i !== o || s !== n;) { var u = c << 1; - r < u && (c -= r, i += h), u < a && (c += a, s += l), p % t == 0 && e.push([i, s]), p++ }
                    return e
                },
                clone: function(t) { return null == t ? t = new H.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t }
            }, Object.defineProperty(H.Line.prototype, "length", { get: function() { return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y)) } }), Object.defineProperty(H.Line.prototype, "angle", { get: function() { return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x) } }), Object.defineProperty(H.Line.prototype, "slope", { get: function() { return (this.end.y - this.start.y) / (this.end.x - this.start.x) } }), Object.defineProperty(H.Line.prototype, "perpSlope", { get: function() { return -(this.end.x - this.start.x) / (this.end.y - this.start.y) } }), Object.defineProperty(H.Line.prototype, "x", { get: function() { return Math.min(this.start.x, this.end.x) } }), Object.defineProperty(H.Line.prototype, "y", { get: function() { return Math.min(this.start.y, this.end.y) } }), Object.defineProperty(H.Line.prototype, "left", { get: function() { return Math.min(this.start.x, this.end.x) } }), Object.defineProperty(H.Line.prototype, "right", { get: function() { return Math.max(this.start.x, this.end.x) } }), Object.defineProperty(H.Line.prototype, "top", { get: function() { return Math.min(this.start.y, this.end.y) } }), Object.defineProperty(H.Line.prototype, "bottom", { get: function() { return Math.max(this.start.y, this.end.y) } }), Object.defineProperty(H.Line.prototype, "width", { get: function() { return Math.abs(this.start.x - this.end.x) } }), Object.defineProperty(H.Line.prototype, "height", { get: function() { return Math.abs(this.start.y - this.end.y) } }), Object.defineProperty(H.Line.prototype, "normalX", { get: function() { return Math.cos(this.angle - 1.5707963267948966) } }), Object.defineProperty(H.Line.prototype, "normalY", { get: function() { return Math.sin(this.angle - 1.5707963267948966) } }), Object.defineProperty(H.Line.prototype, "normalAngle", { get: function() { return H.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI) } }), H.Line.intersectsPoints = function(t, e, i, s, o, n) {
                void 0 === o && (o = !0), void 0 === n && (n = new H.Point);
                var a = e.y - t.y,
                    r = s.y - i.y,
                    h = t.x - e.x,
                    l = i.x - s.x,
                    c = e.x * t.y - t.x * e.y,
                    p = s.x * i.y - i.x * s.y,
                    u = a * l - r * h;
                if (0 === u) return null;
                if (n.x = (h * p - l * c) / u, n.y = (r * c - a * p) / u, o) {
                    var d = (s.y - i.y) * (e.x - t.x) - (s.x - i.x) * (e.y - t.y),
                        y = ((s.x - i.x) * (t.y - i.y) - (s.y - i.y) * (t.x - i.x)) / d,
                        g = ((e.x - t.x) * (t.y - i.y) - (e.y - t.y) * (t.x - i.x)) / d;
                    return 0 <= y && y <= 1 && 0 <= g && g <= 1 ? n : null
                }
                return n
            }, H.Line.intersects = function(t, e, i, s) { return H.Line.intersectsPoints(t.start, t.end, e.start, e.end, i, s) }, H.Line.intersectsRectangle = function(t, e) {
                if (!H.Rectangle.intersects(t, e)) return !1;
                var i = t.start.x,
                    s = t.start.y,
                    o = t.end.x,
                    n = t.end.y,
                    a = e.x,
                    r = e.y,
                    h = e.right,
                    l = e.bottom,
                    c = 0;
                if (a <= i && i <= h && r <= s && s <= l || a <= o && o <= h && r <= n && n <= l) return !0;
                if (i < a && a <= o) { if (r < (c = s + (n - s) * (a - i) / (o - i)) && c <= l) return !0 }
                else if (h < i && o <= h && r <= (c = s + (n - s) * (h - i) / (o - i)) && c <= l) return !0;
                if (s < r && r <= n) { if (a <= (c = i + (o - i) * (r - s) / (n - s)) && c <= h) return !0 }
                else if (l < s && n <= l && a <= (c = i + (o - i) * (l - s) / (n - s)) && c <= h) return !0;
                return !1
            }, H.Line.reflect = function(t, e) { return 2 * e.normalAngle - 3.141592653589793 - t.angle }, H.Matrix = function(t, e, i, s, o, n) { null == t && (t = 1), null == e && (e = 0), null == i && (i = 0), null == s && (s = 1), null == o && (o = 0), null == n && (n = 0), this.a = t, this.b = e, this.c = i, this.d = s, this.tx = o, this.ty = n, this.type = H.MATRIX }, H.Matrix.prototype = {
                fromArray: function(t) { return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5]) },
                setTo: function(t, e, i, s, o, n) { return this.a = t, this.b = e, this.c = i, this.d = s, this.tx = o, this.ty = n, this },
                clone: function(t) { return null == t ? t = new H.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t },
                copyTo: function(t) { return t.copyFrom(this), t },
                copyFrom: function(t) { return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this },
                toArray: function(t, e) { return void 0 === e && (e = new PIXI.Float32Array(9)), e[8] = (e[7] = t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, this.ty) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0), 1), e },
                apply: function(t, e) { return void 0 === e && (e = new H.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e },
                applyInverse: function(t, e) {
                    void 0 === e && (e = new H.Point);
                    var i = 1 / (this.a * this.d + this.c * -this.b),
                        s = t.x,
                        o = t.y;
                    return e.x = this.d * i * s + -this.c * i * o + (this.ty * this.c - this.tx * this.d) * i, e.y = this.a * i * o + -this.b * i * s + (-this.ty * this.a + this.tx * this.b) * i, e
                },
                translate: function(t, e) { return this.tx += t, this.ty += e, this },
                scale: function(t, e) { return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this },
                rotate: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t),
                        s = this.a,
                        o = this.c,
                        n = this.tx;
                    return this.a = s * e - this.b * i, this.b = s * i + this.b * e, this.c = o * e - this.d * i, this.d = o * i + this.d * e, this.tx = n * e - this.ty * i, this.ty = n * i + this.ty * e, this
                },
                append: function(t) {
                    var e = this.a,
                        i = this.b,
                        s = this.c,
                        o = this.d;
                    return this.a = t.a * e + t.b * s, this.b = t.a * i + t.b * o, this.c = t.c * e + t.d * s, this.d = t.c * i + t.d * o, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * i + t.ty * o + this.ty, this
                },
                identity: function() { return this.setTo(1, 0, 0, 1, 0, 0) }
            }, H.identityMatrix = new H.Matrix, PIXI.Matrix = H.Matrix, PIXI.identityMatrix = H.identityMatrix, H.Point = function(t, e) { t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = H.POINT }, H.Point.prototype = {
                copyFrom: function(t) { return this.setTo(t.x, t.y) },
                invert: function() { return this.setTo(this.y, this.x) },
                setTo: function(t, e) { return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this },
                set: function(t, e) { return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this },
                add: function(t, e) { return this.x += t, this.y += e, this },
                subtract: function(t, e) { return this.x -= t, this.y -= e, this },
                multiply: function(t, e) { return this.x *= t, this.y *= e, this },
                divide: function(t, e) { return this.x /= t, this.y /= e, this },
                clampX: function(t, e) { return this.x = H.Math.clamp(this.x, t, e), this },
                clampY: function(t, e) { return this.y = H.Math.clamp(this.y, t, e), this },
                clamp: function(t, e) { return this.x = H.Math.clamp(this.x, t, e), this.y = H.Math.clamp(this.y, t, e), this },
                clone: function(t) { return null == t ? t = new H.Point(this.x, this.y) : t.setTo(this.x, this.y), t },
                copyTo: function(t) { return t.x = this.x, t.y = this.y, t },
                distance: function(t, e) { return H.Point.distance(this, t, e) },
                equals: function(t) { return t.x === this.x && t.y === this.y },
                angle: function(t, e) { return void 0 === e && (e = !1), e ? H.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x) },
                rotate: function(t, e, i, s, o) { return H.Point.rotate(this, t, e, i, s, o) },
                getMagnitude: function() { return Math.sqrt(this.x * this.x + this.y * this.y) },
                getMagnitudeSq: function() { return this.x * this.x + this.y * this.y },
                setMagnitude: function(t) { return this.normalize().multiply(t, t) },
                normalize: function() {
                    if (!this.isZero()) {
                        var t = this.getMagnitude();
                        this.x /= t, this.y /= t
                    }
                    return this
                },
                isZero: function() { return 0 === this.x && 0 === this.y },
                dot: function(t) { return this.x * t.x + this.y * t.y },
                cross: function(t) { return this.x * t.y - this.y * t.x },
                perp: function() { return this.setTo(-this.y, this.x) },
                rperp: function() { return this.setTo(this.y, -this.x) },
                normalRightHand: function() { return this.setTo(-1 * this.y, this.x) },
                floor: function() { return this.setTo(Math.floor(this.x), Math.floor(this.y)) },
                ceil: function() { return this.setTo(Math.ceil(this.x), Math.ceil(this.y)) },
                toString: function() { return "[{Point (x=" + this.x + " y=" + this.y + ")}]" }
            }, H.Point.prototype.constructor = H.Point, H.Point.add = function(t, e, i) { return void 0 === i && (i = new H.Point), i.x = t.x + e.x, i.y = t.y + e.y, i }, H.Point.subtract = function(t, e, i) { return void 0 === i && (i = new H.Point), i.x = t.x - e.x, i.y = t.y - e.y, i }, H.Point.multiply = function(t, e, i) { return void 0 === i && (i = new H.Point), i.x = t.x * e.x, i.y = t.y * e.y, i }, H.Point.divide = function(t, e, i) { return void 0 === i && (i = new H.Point), i.x = t.x / e.x, i.y = t.y / e.y, i }, H.Point.equals = function(t, e) { return t.x === e.x && t.y === e.y }, H.Point.angle = function(t, e) { return Math.atan2(t.y - e.y, t.x - e.x) }, H.Point.negative = function(t, e) { return void 0 === e && (e = new H.Point), e.setTo(-t.x, -t.y) }, H.Point.multiplyAdd = function(t, e, i, s) { return void 0 === s && (s = new H.Point), s.setTo(t.x + e.x * i, t.y + e.y * i) }, H.Point.interpolate = function(t, e, i, s) { return void 0 === s && (s = new H.Point), s.setTo(t.x + (e.x - t.x) * i, t.y + (e.y - t.y) * i) }, H.Point.perp = function(t, e) { return void 0 === e && (e = new H.Point), e.setTo(-t.y, t.x) }, H.Point.rperp = function(t, e) { return void 0 === e && (e = new H.Point), e.setTo(t.y, -t.x) }, H.Point.distance = function(t, e, i) { var s = H.Math.distance(t.x, t.y, e.x, e.y); return i ? Math.round(s) : s }, H.Point.project = function(t, e, i) { void 0 === i && (i = new H.Point); var s = t.dot(e) / e.getMagnitudeSq(); return 0 !== s && i.setTo(s * e.x, s * e.y), i }, H.Point.projectUnit = function(t, e, i) { void 0 === i && (i = new H.Point); var s = t.dot(e); return 0 !== s && i.setTo(s * e.x, s * e.y), i }, H.Point.normalRightHand = function(t, e) { return void 0 === e && (e = new H.Point), e.setTo(-1 * t.y, t.x) }, H.Point.normalize = function(t, e) { void 0 === e && (e = new H.Point); var i = t.getMagnitude(); return 0 !== i && e.setTo(t.x / i, t.y / i), e }, H.Point.rotate = function(t, e, i, s, o, n) {
                if (o && (s = H.Math.degToRad(s)), void 0 === n) {
                    t.subtract(e, i);
                    var a = Math.sin(s),
                        r = Math.cos(s),
                        h = r * t.x - a * t.y,
                        l = a * t.x + r * t.y;
                    t.x = h + e, t.y = l + i
                }
                else {
                    var c = s + Math.atan2(t.y - i, t.x - e);
                    t.x = e + n * Math.cos(c), t.y = i + n * Math.sin(c)
                }
                return t
            }, H.Point.centroid = function(t, e) { if (void 0 === e && (e = new H.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array"); var i = t.length; if (i < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty"); if (1 === i) return e.copyFrom(t[0]), e; for (var s = 0; s < i; s++) H.Point.add(e, t[s], e); return e.divide(i, i), e }, H.Point.parse = function(t, e, i) { e = e || "x", i = i || "y"; var s = new H.Point; return t[e] && (s.x = parseInt(t[e], 10)), t[i] && (s.y = parseInt(t[i], 10)), s }, PIXI.Point = H.Point, H.Polygon = function() { this.area = 0, this._points = [], 0 < arguments.length && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = H.POLYGON }, H.Polygon.prototype = {
                toNumberArray: function(t) { void 0 === t && (t = []); for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y)); return t },
                flatten: function() { return this._points = this.toNumberArray(), this.flattened = !0, this },
                clone: function(t) { var e = this._points.slice(); return null == t ? t = new H.Polygon(e) : t.setTo(e), t },
                contains: function(t, e) {
                    var i = !1;
                    if (this.flattened)
                        for (var s = -2, o = this._points.length - 2;
                            (s += 2) < this._points.length; o = s) {
                            var n = this._points[s],
                                a = this._points[s + 1],
                                r = this._points[o],
                                h = this._points[o + 1];
                            (a <= e && e < h || h <= e && e < a) && t < (r - n) * (e - a) / (h - a) + n && (i = !i)
                        }
                    else
                        for (s = -1, o = this._points.length - 1; ++s < this._points.length; o = s) {
                            n = this._points[s].x, a = this._points[s].y, r = this._points[o].x, h = this._points[o].y;
                            (a <= e && e < h || h <= e && e < a) && t < (r - n) * (e - a) / (h - a) + n && (i = !i)
                        }
                    return i
                },
                setTo: function(t) {
                    if (this.area = 0, this._points = [], 0 < arguments.length) {
                        Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                        for (var e = Number.MAX_VALUE, i = 0, s = t.length; i < s; i++) {
                            if ("number" == typeof t[i]) {
                                var o = new PIXI.Point(t[i], t[i + 1]);
                                i++
                            }
                            else if (Array.isArray(t[i])) o = new PIXI.Point(t[i][0], t[i][1]);
                            else o = new PIXI.Point(t[i].x, t[i].y);
                            this._points.push(o), o.y < e && (e = o.y)
                        }
                        this.calculateArea(e)
                    }
                    return this
                },
                calculateArea: function(t) { for (var e, i, s, o, n = 0, a = this._points.length; n < a; n++) e = this._points[n], i = n === a - 1 ? this._points[0] : this._points[n + 1], s = (e.y - t + (i.y - t)) / 2, o = e.x - i.x, this.area += s * o; return this.area }
            }, H.Polygon.prototype.constructor = H.Polygon, Object.defineProperty(H.Polygon.prototype, "points", { get: function() { return this._points }, set: function(t) { null != t ? this.setTo(t) : this.setTo() } }), PIXI.Polygon = H.Polygon, H.Rectangle = function(t, e, i, s) { t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s, this.type = H.RECTANGLE }, H.Rectangle.prototype = {
                offset: function(t, e) { return this.x += t, this.y += e, this },
                offsetPoint: function(t) { return this.offset(t.x, t.y) },
                setTo: function(t, e, i, s) { return this.x = t, this.y = e, this.width = i, this.height = s, this },
                scale: function(t, e) { return void 0 === e && (e = t), this.width *= t, this.height *= e, this },
                centerOn: function(t, e) { return this.centerX = t, this.centerY = e, this },
                floor: function() { this.x = Math.floor(this.x), this.y = Math.floor(this.y) },
                floorAll: function() { this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height) },
                ceil: function() { this.x = Math.ceil(this.x), this.y = Math.ceil(this.y) },
                ceilAll: function() { this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height) },
                copyFrom: function(t) { return this.setTo(t.x, t.y, t.width, t.height) },
                copyTo: function(t) { return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t },
                inflate: function(t, e) { return H.Rectangle.inflate(this, t, e) },
                size: function(t) { return H.Rectangle.size(this, t) },
                resize: function(t, e) { return this.width = t, this.height = e, this },
                clone: function(t) { return H.Rectangle.clone(this, t) },
                contains: function(t, e) { return H.Rectangle.contains(this, t, e) },
                containsRect: function(t) { return H.Rectangle.containsRect(t, this) },
                equals: function(t) { return H.Rectangle.equals(this, t) },
                intersection: function(t, e) { return H.Rectangle.intersection(this, t, e) },
                intersects: function(t) { return H.Rectangle.intersects(this, t) },
                intersectsRaw: function(t, e, i, s, o) { return H.Rectangle.intersectsRaw(this, t, e, i, s, o) },
                union: function(t, e) { return H.Rectangle.union(this, t, e) },
                random: function(t) { return void 0 === t && (t = new H.Point), t.x = this.randomX, t.y = this.randomY, t },
                getPoint: function(t, e) {
                    switch (void 0 === e && (e = new H.Point), t) {
                        default:
                            case H.TOP_LEFT:
                            return e.set(this.x, this.y);
                        case H.TOP_CENTER:
                                return e.set(this.centerX, this.y);
                        case H.TOP_RIGHT:
                                return e.set(this.right, this.y);
                        case H.LEFT_CENTER:
                                return e.set(this.x, this.centerY);
                        case H.CENTER:
                                return e.set(this.centerX, this.centerY);
                        case H.RIGHT_CENTER:
                                return e.set(this.right, this.centerY);
                        case H.BOTTOM_LEFT:
                                return e.set(this.x, this.bottom);
                        case H.BOTTOM_CENTER:
                                return e.set(this.centerX, this.bottom);
                        case H.BOTTOM_RIGHT:
                                return e.set(this.right, this.bottom)
                    }
                },
                toString: function() { return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]" }
            }, Object.defineProperty(H.Rectangle.prototype, "halfWidth", { get: function() { return Math.round(this.width / 2) } }), Object.defineProperty(H.Rectangle.prototype, "halfHeight", { get: function() { return Math.round(this.height / 2) } }), Object.defineProperty(H.Rectangle.prototype, "bottom", { get: function() { return this.y + this.height }, set: function(t) { t <= this.y ? this.height = 0 : this.height = t - this.y } }), Object.defineProperty(H.Rectangle.prototype, "bottomLeft", { get: function() { return new H.Point(this.x, this.bottom) }, set: function(t) { this.x = t.x, this.bottom = t.y } }), Object.defineProperty(H.Rectangle.prototype, "bottomRight", { get: function() { return new H.Point(this.right, this.bottom) }, set: function(t) { this.right = t.x, this.bottom = t.y } }), Object.defineProperty(H.Rectangle.prototype, "left", { get: function() { return this.x }, set: function(t) { t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t } }), Object.defineProperty(H.Rectangle.prototype, "right", { get: function() { return this.x + this.width }, set: function(t) { t <= this.x ? this.width = 0 : this.width = t - this.x } }), Object.defineProperty(H.Rectangle.prototype, "volume", { get: function() { return this.width * this.height } }), Object.defineProperty(H.Rectangle.prototype, "perimeter", { get: function() { return 2 * this.width + 2 * this.height } }), Object.defineProperty(H.Rectangle.prototype, "centerX", { get: function() { return this.x + this.halfWidth }, set: function(t) { this.x = t - this.halfWidth } }), Object.defineProperty(H.Rectangle.prototype, "centerY", { get: function() { return this.y + this.halfHeight }, set: function(t) { this.y = t - this.halfHeight } }), Object.defineProperty(H.Rectangle.prototype, "randomX", { get: function() { return this.x + Math.random() * this.width } }), Object.defineProperty(H.Rectangle.prototype, "randomY", { get: function() { return this.y + Math.random() * this.height } }), Object.defineProperty(H.Rectangle.prototype, "top", { get: function() { return this.y }, set: function(t) { t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t } }), Object.defineProperty(H.Rectangle.prototype, "topLeft", { get: function() { return new H.Point(this.x, this.y) }, set: function(t) { this.x = t.x, this.y = t.y } }), Object.defineProperty(H.Rectangle.prototype, "topRight", { get: function() { return new H.Point(this.x + this.width, this.y) }, set: function(t) { this.right = t.x, this.y = t.y } }), Object.defineProperty(H.Rectangle.prototype, "empty", { get: function() { return !this.width || !this.height }, set: function(t) {!0 === t && this.setTo(0, 0, 0, 0) } }), H.Rectangle.prototype.constructor = H.Rectangle, H.Rectangle.inflate = function(t, e, i) { return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t }, H.Rectangle.inflatePoint = function(t, e) { return H.Rectangle.inflate(t, e.x, e.y) }, H.Rectangle.size = function(t, e) { return null == e ? e = new H.Point(t.width, t.height) : e.setTo(t.width, t.height), e }, H.Rectangle.clone = function(t, e) { return null == e ? e = new H.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e }, H.Rectangle.contains = function(t, e, i) { return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom) }, H.Rectangle.containsRaw = function(t, e, i, s, o, n) { return t <= o && o < t + i && e <= n && n < e + s }, H.Rectangle.containsPoint = function(t, e) { return H.Rectangle.contains(t, e.x, e.y) }, H.Rectangle.containsRect = function(t, e) { return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom) }, H.Rectangle.equals = function(t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height }, H.Rectangle.sameDimensions = function(t, e) { return t.width === e.width && t.height === e.height }, H.Rectangle.intersection = function(t, e, i) { return void 0 === i && (i = new H.Rectangle), H.Rectangle.intersects(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i }, H.Rectangle.intersects = function(t, e) { return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom) }, H.Rectangle.intersectsRaw = function(t, e, i, s, o, n) { return void 0 === n && (n = 0), !(e > t.right + n || i < t.left - n || s > t.bottom + n || o < t.top - n) }, H.Rectangle.union = function(t, e, i) { return void 0 === i && (i = new H.Rectangle), i.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top)) }, H.Rectangle.aabb = function(t, e) {
                void 0 === e && (e = new H.Rectangle);
                var i = Number.NEGATIVE_INFINITY,
                    s = Number.POSITIVE_INFINITY,
                    o = Number.NEGATIVE_INFINITY,
                    n = Number.POSITIVE_INFINITY;
                return t.forEach(function(t) { t.x > i && (i = t.x), t.x < s && (s = t.x), t.y > o && (o = t.y), t.y < n && (n = t.y) }), e.setTo(s, n, i - s, o - n), e
            }, PIXI.Rectangle = H.Rectangle, PIXI.EmptyRectangle = new H.Rectangle(0, 0, 0, 0), H.RoundedRectangle = function(t, e, i, s, o) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === o && (o = 20), this.x = t, this.y = e, this.width = i, this.height = s, this.radius = o || 20, this.type = H.ROUNDEDRECTANGLE }, H.RoundedRectangle.prototype = { clone: function() { return new H.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius) }, contains: function(t, e) { if (this.width <= 0 || this.height <= 0) return !1; var i = this.x; if (i <= t && t <= i + this.width) { var s = this.y; if (s <= e && e <= s + this.height) return !0 } return !1 } }, H.RoundedRectangle.prototype.constructor = H.RoundedRectangle, PIXI.RoundedRectangle = H.RoundedRectangle, H.Camera = function(t, e, i, s, o, n) { this.game = t, this.world = t.world, this.id = 0, this.view = new H.Rectangle(i, s, o, n), this.bounds = new H.Rectangle(i, s, o, n), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = { x: !1, y: !1 }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new H.Point(1, 1), this.onShakeComplete = new H.Signal, this.onFlashComplete = new H.Signal, this.onFadeComplete = new H.Signal, this.fx = null, this._targetPosition = new H.Point, this._edge = 0, this._position = new H.Point, this._shake = { intensity: 0, duration: 0, horizontal: !1, vertical: !1, shakeBounds: !0, x: 0, y: 0 }, this._fxDuration = 0, this._fxType = 0 }, H.Camera.FOLLOW_LOCKON = 0, H.Camera.FOLLOW_PLATFORMER = 1, H.Camera.FOLLOW_TOPDOWN = 2, H.Camera.FOLLOW_TOPDOWN_TIGHT = 3, H.Camera.SHAKE_BOTH = 4, H.Camera.SHAKE_HORIZONTAL = 5, H.Camera.SHAKE_VERTICAL = 6, H.Camera.ENABLE_FX = !0, H.Camera.prototype = {
                boot: function() { this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, H.Graphics && H.Camera.ENABLE_FX && (this.fx = new H.Graphics(this.game), this.game.stage.addChild(this.fx)) },
                preUpdate: function() { this.totalInView = 0 },
                follow: function(t, e, i, s) {
                    var o;
                    switch (void 0 === e && (e = H.Camera.FOLLOW_LOCKON), void 0 === i && (i = 1), void 0 === s && (s = 1), this.target = t, this.lerp.set(i, s), e) {
                        case H.Camera.FOLLOW_PLATFORMER:
                            var n = this.width / 8,
                                a = this.height / 3;
                            this.deadzone = new H.Rectangle((this.width - n) / 2, (this.height - a) / 2 - .25 * a, n, a);
                            break;
                        case H.Camera.FOLLOW_TOPDOWN:
                            o = Math.max(this.width, this.height) / 4, this.deadzone = new H.Rectangle((this.width - o) / 2, (this.height - o) / 2, o, o);
                            break;
                        case H.Camera.FOLLOW_TOPDOWN_TIGHT:
                            o = Math.max(this.width, this.height) / 8, this.deadzone = new H.Rectangle((this.width - o) / 2, (this.height - o) / 2, o, o);
                            break;
                        case H.Camera.FOLLOW_LOCKON:
                        default:
                            this.deadzone = null
                    }
                },
                unfollow: function() { this.target = null },
                focusOn: function(t) { this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight)) },
                focusOnXY: function(t, e) { this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight)) },
                shake: function(t, e, i, s, o) { return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === i && (i = !0), void 0 === s && (s = H.Camera.SHAKE_BOTH), void 0 === o && (o = !0), !(!i && 0 < this._shake.duration) && (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = o, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = s === H.Camera.SHAKE_BOTH || s === H.Camera.SHAKE_HORIZONTAL, this._shake.vertical = s === H.Camera.SHAKE_BOTH || s === H.Camera.SHAKE_VERTICAL, !0) },
                flash: function(t, e, i) { return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && 0 < this._fxDuration) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, !(this._fxType = 0)) },
                fade: function(t, e, i) { return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && 0 < this._fxDuration) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, !0) },
                update: function() { 0 < this._fxDuration && this.updateFX(), 0 < this._shake.duration && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y },
                updateFX: function() { 0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, 1 <= this.fx.alpha && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch())) },
                updateShake: function() { this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height)) },
                updateTarget: function() { this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y },
                setBoundsToWorld: function() { this.bounds && this.bounds.copyFrom(this.game.world.bounds) },
                checkBounds: function() {
                    this.atLimit.x = !1, this.atLimit.y = !1;
                    var t = this.view.x + this._shake.x,
                        e = this.view.right + this._shake.x,
                        i = this.view.y + this._shake.y,
                        s = this.view.bottom + this._shake.y;
                    t <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), s >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
                },
                setPosition: function(t, e) { this.view.x = t, this.view.y = e, this.bounds && this.checkBounds() },
                setSize: function(t, e) { this.view.width = t, this.view.height = e },
                reset: function() { this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX() },
                resetFX: function() { this.fx && (this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0) }
            }, H.Camera.prototype.constructor = H.Camera, Object.defineProperty(H.Camera.prototype, "x", { get: function() { return this.view.x }, set: function(t) { this.view.x = t, this.bounds && this.checkBounds() } }), Object.defineProperty(H.Camera.prototype, "y", { get: function() { return this.view.y }, set: function(t) { this.view.y = t, this.bounds && this.checkBounds() } }), Object.defineProperty(H.Camera.prototype, "position", { get: function() { return this._position.set(this.view.x, this.view.y), this._position }, set: function(t) { void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds() } }), Object.defineProperty(H.Camera.prototype, "width", { get: function() { return this.view.width }, set: function(t) { this.view.width = t } }), Object.defineProperty(H.Camera.prototype, "height", { get: function() { return this.view.height }, set: function(t) { this.view.height = t } }), Object.defineProperty(H.Camera.prototype, "shakeIntensity", { get: function() { return this._shake.intensity }, set: function(t) { this._shake.intensity = t } }), H.State = function() { this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null }, H.State.prototype = { init: function() {}, preload: function() {}, loadUpdate: function() {}, loadRender: function() {}, create: function() {}, update: function() {}, preRender: function() {}, render: function() {}, resize: function() {}, paused: function() {}, resumed: function() {}, pauseUpdate: function() {}, shutdown: function() {} }, H.State.prototype.constructor = H.State, H.StateManager = function(t, e) { this.game = t, this.states = {}, (this._pendingState = null) != e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new H.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null }, H.StateManager.prototype = {
                boot: function() { this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0) },
                add: function(t, e, i) { var s; return void 0 === i && (i = !1), e instanceof H.State ? s = e : "object" == typeof e ? (s = e).game = this.game : "function" == typeof e && (s = new e(this.game)), this.states[t] = s, i && (this.game.isBooted ? this.start(t) : this._pendingState = t), s },
                remove: function(t) { this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t] },
                start: function(t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, 3 < arguments.length && (this._args = Array.prototype.splice.call(arguments, 3))) },
                restart: function(t, e) { void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, 2 < arguments.length && (this._args = Array.prototype.slice.call(arguments, 2)) },
                dummy: function() {},
                preUpdate: function() {
                    if (this._pendingState && this.game.isBooted) {
                        var t = this.current;
                        if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                        this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                    }
                },
                clearCurrentState: function() { this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy())) },
                checkState: function(t) { return !!this.states[t] && !!(this.states[t].preload || this.states[t].create || this.states[t].update || this.states[t].render) },
                link: function(t) { this.states[t].game = this.game, this.states[t].add = this.game.add, this.states[t].make = this.game.make, this.states[t].camera = this.game.camera, this.states[t].cache = this.game.cache, this.states[t].input = this.game.input, this.states[t].load = this.game.load, this.states[t].math = this.game.math, this.states[t].sound = this.game.sound, this.states[t].scale = this.game.scale, (this.states[t].state = this).states[t].stage = this.game.stage, this.states[t].time = this.game.time, this.states[t].tweens = this.game.tweens, this.states[t].world = this.game.world, this.states[t].particles = this.game.particles, this.states[t].rnd = this.game.rnd, this.states[t].physics = this.game.physics, this.states[t].key = t },
                unlink: function(t) { this.states[t] && (this.states[t].game = null, this.states[t].add = null, this.states[t].make = null, this.states[t].camera = null, this.states[t].cache = null, this.states[t].input = null, this.states[t].load = null, this.states[t].math = null, this.states[t].sound = null, this.states[t].scale = null, this.states[t].state = null, this.states[t].stage = null, this.states[t].time = null, this.states[t].tweens = null, this.states[t].world = null, this.states[t].particles = null, this.states[t].rnd = null, this.states[t].physics = null) },
                setCurrentState: function(t) { this.callbackContext = this.states[t], this.link(t), this.onInitCallback = this.states[t].init || this.dummy, this.onPreloadCallback = this.states[t].preload || null, this.onLoadRenderCallback = this.states[t].loadRender || null, this.onLoadUpdateCallback = this.states[t].loadUpdate || null, this.onCreateCallback = this.states[t].create || null, this.onUpdateCallback = this.states[t].update || null, this.onPreRenderCallback = this.states[t].preRender || null, this.onRenderCallback = this.states[t].render || null, this.onResizeCallback = this.states[t].resize || null, this.onPausedCallback = this.states[t].paused || null, this.onResumedCallback = this.states[t].resumed || null, this.onPauseUpdateCallback = this.states[t].pauseUpdate || null, this.onShutDownCallback = this.states[t].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0 },
                getCurrentState: function() { return this.states[this.current] },
                loadComplete: function() {!1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0 },
                pause: function() { this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game) },
                resume: function() { this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game) },
                update: function() { this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game) },
                pauseUpdate: function() { this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game) },
                preRender: function(t) { this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t) },
                resize: function(t, e) { this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e) },
                render: function() { this._created ? this.onRenderCallback && (this.game.renderType === H.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game) },
                destroy: function() { this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = "" }
            }, H.StateManager.prototype.constructor = H.StateManager, Object.defineProperty(H.StateManager.prototype, "created", { get: function() { return this._created } }), H.Signal = function() {}, H.Signal.prototype = {
                _bindings: null,
                _prevParams: null,
                memorize: !1,
                _shouldPropagate: !0,
                active: !0,
                _boundDispatch: !1,
                validateListener: function(t, e) { if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e)) },
                _registerListener: function(t, e, i, s, o) { var n, a = this._indexOfListener(t, i); if (-1 !== a) { if ((n = this._bindings[a]).isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.") } else n = new H.SignalBinding(this, t, e, i, s, o), this._addBinding(n); return this.memorize && this._prevParams && n.execute(this._prevParams), n },
                _addBinding: function(t) {
                    this._bindings || (this._bindings = []);
                    for (var e = this._bindings.length; e--, this._bindings[e] && t._priority <= this._bindings[e]._priority;);
                    this._bindings.splice(e + 1, 0, t)
                },
                _indexOfListener: function(t, e) {
                    if (!this._bindings) return -1;
                    void 0 === e && (e = null);
                    for (var i, s = this._bindings.length; s--;)
                        if ((i = this._bindings[s])._listener === t && i.context === e) return s;
                    return -1
                },
                has: function(t, e) { return -1 !== this._indexOfListener(t, e) },
                add: function(t, e, i) {
                    this.validateListener(t, "add");
                    var s = [];
                    if (3 < arguments.length)
                        for (var o = 3; o < arguments.length; o++) s.push(arguments[o]);
                    return this._registerListener(t, !1, e, i, s)
                },
                addOnce: function(t, e, i) {
                    this.validateListener(t, "addOnce");
                    var s = [];
                    if (3 < arguments.length)
                        for (var o = 3; o < arguments.length; o++) s.push(arguments[o]);
                    return this._registerListener(t, !0, e, i, s)
                },
                remove: function(t, e) { this.validateListener(t, "remove"); var i = this._indexOfListener(t, e); return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t },
                removeAll: function(t) {
                    if (void 0 === t && (t = null), this._bindings) {
                        for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                        t || (this._bindings.length = 0)
                    }
                },
                getNumListeners: function() { return this._bindings ? this._bindings.length : 0 },
                halt: function() { this._shouldPropagate = !1 },
                dispatch: function() {
                    if (this.active && this._bindings) {
                        var t, e = Array.prototype.slice.call(arguments),
                            i = this._bindings.length;
                        if (this.memorize && (this._prevParams = e), i)
                            for (t = this._bindings.slice(), this._shouldPropagate = !0; t[--i] && this._shouldPropagate && !1 !== t[i].execute(e););
                    }
                },
                forget: function() { this._prevParams && (this._prevParams = null) },
                dispose: function() { this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null) },
                toString: function() { return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]" }
            }, Object.defineProperty(H.Signal.prototype, "boundDispatch", { get: function() { var t = this; return this._boundDispatch || (this._boundDispatch = function() { return t.dispatch.apply(t, arguments) }) } }), H.Signal.prototype.constructor = H.Signal, H.SignalBinding = function(t, e, i, s, o, n) { this._listener = e, i && (this._isOnce = !0), null != s && (this.context = s), this._signal = t, o && (this._priority = o), n && n.length && (this._args = n) }, H.SignalBinding.prototype = { context: null, _isOnce: !1, _priority: 0, _args: null, callCount: 0, active: !0, params: null, execute: function(t) { var e, i; return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e }, detach: function() { return this.isBound() ? this._signal.remove(this._listener, this.context) : null }, isBound: function() { return !!this._signal && !!this._listener }, isOnce: function() { return this._isOnce }, getListener: function() { return this._listener }, getSignal: function() { return this._signal }, _destroy: function() { delete this._signal, delete this._listener, delete this.context }, toString: function() { return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]" } }, H.SignalBinding.prototype.constructor = H.SignalBinding, H.Filter = function(t, e, i) {
                this.game = t, this.type = H.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new H.Point;
                var s = new Date;
                if (this.uniforms = { resolution: { type: "2f", value: { x: 256, y: 256 } }, time: { type: "1f", value: 0 }, mouse: { type: "2f", value: { x: 0, y: 0 } }, date: { type: "4fv", value: [s.getFullYear(), s.getMonth(), s.getDate(), 60 * s.getHours() * 60 + 60 * s.getMinutes() + s.getSeconds()] }, sampleRate: { type: "1f", value: 44100 }, iChannel0: { type: "sampler2D", value: null, textureData: { repeat: !0 } }, iChannel1: { type: "sampler2D", value: null, textureData: { repeat: !0 } }, iChannel2: { type: "sampler2D", value: null, textureData: { repeat: !0 } }, iChannel3: { type: "sampler2D", value: null, textureData: { repeat: !0 } } }, e)
                    for (var o in e) this.uniforms[o] = e[o];
                this.fragmentSrc = i || ""
            }, H.Filter.prototype = {
                init: function() {},
                setResolution: function(t, e) { this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e },
                update: function(t) {
                    if (void 0 !== t) {
                        var e = t.x / this.game.width,
                            i = 1 - t.y / this.game.height;
                        e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
                    }
                    this.uniforms.time.value = this.game.time.totalElapsedSeconds()
                },
                addToWorld: function(t, e, i, s, o, n) { void 0 === o && (o = 0), void 0 === n && (n = 0), null != i ? this.width = i : i = this.width, null != s ? this.height = s : s = this.height; var a = this.game.add.image(t, e, "__default"); return a.width = i, a.height = s, a.anchor.set(o, n), a.filters = [this], a },
                destroy: function() { this.game = null }
            }, H.Filter.prototype.constructor = H.Filter, Object.defineProperty(H.Filter.prototype, "width", { get: function() { return this.uniforms.resolution.value.x }, set: function(t) { this.uniforms.resolution.value.x = t } }), Object.defineProperty(H.Filter.prototype, "height", { get: function() { return this.uniforms.resolution.value.y }, set: function(t) { this.uniforms.resolution.value.y = t } }), H.Plugin = function(t, e) { void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1 }, H.Plugin.prototype = { preUpdate: function() {}, update: function() {}, render: function() {}, postRender: function() {}, destroy: function() { this.game = null, this.parent = null, this.active = !1, this.visible = !1 } }, H.Plugin.prototype.constructor = H.Plugin, H.PluginManager = function(t) { this.game = t, this.plugins = [], this._len = 0, this._i = 0 }, H.PluginManager.prototype = {
                add: function(t) {
                    var e = Array.prototype.slice.call(arguments, 1),
                        i = !1;
                    return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (i = t.hasPreUpdate = !0), "function" == typeof t.update && (i = t.hasUpdate = !0), "function" == typeof t.postUpdate && (i = t.hasPostUpdate = !0), "function" == typeof t.render && (i = t.hasRender = !0), "function" == typeof t.postRender && (i = t.hasPostRender = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
                },
                remove: function(t, e) {
                    for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                        if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
                },
                removeAll: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                    this.plugins.length = 0, this._len = 0
                },
                preUpdate: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate() },
                update: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update() },
                postUpdate: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate() },
                render: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render() },
                postRender: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender() },
                destroy: function() { this.removeAll(), this.game = null }
            }, H.PluginManager.prototype.constructor = H.PluginManager, H.Stage = function(t) { this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, (this.stage = this).currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = { r: 0, g: 0, b: 0, a: 0, color: 0, rgba: "#000000" }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config) }, H.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), H.Stage.prototype.constructor = H.Stage, H.Stage.prototype.parseConfig = function(t) { t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor) }, H.Stage.prototype.boot = function() { H.DOM.getOffset(this.game.canvas, this.offset), H.Canvas.setUserSelect(this.game.canvas, "none"), H.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility() }, H.Stage.prototype.preUpdate = function() { for (var t = this.currentRenderOrderID = 0; t < this.children.length; t++) this.children[t].preUpdate() }, H.Stage.prototype.update = function() { for (var t = this.children.length; t--;) this.children[t].update() }, H.Stage.prototype.postUpdate = function() {
                this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
                for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
                this.updateTransform()
            }, H.Stage.prototype.updateTransform = function() { this.worldAlpha = 1; for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform() }, H.Stage.prototype.checkVisibility = function() {
                void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
                var e = this;
                this._onChange = function(t) { return e.visibilityChange(t) }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() { H.Stage.prototype.visibilityChange.call(e, { type: "pause" }) }), CocoonJS.App.onActivated.addEventListener(function() { H.Stage.prototype.visibilityChange.call(e, { type: "resume" }) }))
            }, H.Stage.prototype.visibilityChange = function(t) { "pagehide" !== t.type && "blur" !== t.type && "pageshow" !== t.type && "focus" !== t.type ? this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t)) : "pagehide" === t.type || "blur" === t.type ? this.game.focusLoss(t) : "pageshow" !== t.type && "focus" !== t.type || this.game.focusGain(t) }, H.Stage.prototype.setBackgroundColor = function(t) { this.game.transparent || (H.Color.valueToColor(t, this._bgColor), H.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1) }, H.Stage.prototype.destroy = function() { this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null }, Object.defineProperty(H.Stage.prototype, "backgroundColor", { get: function() { return this._bgColor.color }, set: function(t) { this.setBackgroundColor(t) } }), Object.defineProperty(H.Stage.prototype, "smoothed", { get: function() { return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR }, set: function(t) { PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST } }), H.Group = function(t, e, i, s, o, n) { void 0 === s && (s = !1), void 0 === o && (o = !1), void 0 === n && (n = H.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = i || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), s ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = H.GROUP, this.physicsType = H.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = H.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new H.Signal, this.onChildInputUp = new H.Signal, this.onChildInputOver = new H.Signal, this.onChildInputOut = new H.Signal, this.enableBody = o, this.enableBodyDebug = !1, this.physicsBodyType = n, this.physicsSortDirection = null, this.onDestroy = new H.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new H.Point, this.hash = [], this._sortProperty = "z" }, H.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), H.Group.prototype.constructor = H.Group, H.Group.RETURN_NONE = 0, H.Group.RETURN_TOTAL = 1, H.Group.RETURN_CHILD = 2, H.Group.RETURN_ALL = 3, H.Group.SORT_ASCENDING = -1, H.Group.SORT_DESCENDING = 1, H.Group.prototype.add = function(t, e, i) { return void 0 === e && (e = !1), t.parent === this || (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t)), t }, H.Group.prototype.addAt = function(t, e, i) { this.add(t, i, e) }, H.Group.prototype.addToHash = function(t) { if (t.parent === this && -1 === this.hash.indexOf(t)) return this.hash.push(t), !0; return !1 }, H.Group.prototype.removeFromHash = function(t) { if (t) { var e = this.hash.indexOf(t); if (-1 !== e) return this.hash.splice(e, 1), !0 } return !1 }, H.Group.prototype.addMultiple = function(t, e) {
                if (t instanceof H.Group) t.moveAll(this, e);
                else if (Array.isArray(t))
                    for (var i = 0; i < t.length; i++) this.add(t[i], e);
                return t
            }, H.Group.prototype.getAt = function(t) { return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t) }, H.Group.prototype.create = function(t, e, i, s, o, n) { void 0 === o && (o = !0); var a = new this.classType(this.game, t, e, i, s); return a.exists = o, a.visible = o, a.alive = o, this.add(a, !1, n) }, H.Group.prototype.createMultiple = function(s, t, e, o) {
                void 0 === e && (e = 0), void 0 === o && (o = !1), Array.isArray(t) || (t = [t]), Array.isArray(e) || (e = [e]);
                var n = this,
                    a = [];
                return t.forEach(function(i) { e.forEach(function(t) { for (var e = 0; e < s; e++) a.push(n.create(0, 0, i, t, o)) }) }), a
            }, H.Group.prototype.updateZ = function() { for (var t = this.children.length; t--;) this.children[t].z = t }, H.Group.prototype.align = function(t, e, i, s, o, n) {
                if (void 0 === o && (o = H.TOP_LEFT), void 0 === n && (n = 0), 0 === this.children.length || n > this.children.length || -1 === t && -1 === e) return !1;
                for (var a = new H.Rectangle(0, 0, i, s), r = t * i, h = e * s, l = n; l < this.children.length; l++) {
                    var c = this.children[l];
                    if (c.alignIn)
                        if (c.alignIn(a, o), -1 === t) a.y += s, a.y === h && (a.x += i, a.y = 0);
                        else if (-1 === e) a.x += i, a.x === r && (a.x = 0, a.y += s);
                    else if (a.x += i, a.x === r && (a.x = 0, a.y += s, a.y === h)) return !0
                }
                return !0
            }, H.Group.prototype.resetCursor = function(t) { if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor }, H.Group.prototype.next = function() { if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor }, H.Group.prototype.previous = function() { if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor }, H.Group.prototype.swap = function(t, e) { this.swapChildren(t, e), this.updateZ() }, H.Group.prototype.bringToTop = function(t) { return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t }, H.Group.prototype.sendToBack = function(t) { return t.parent === this && 0 < this.getIndex(t) && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t }, H.Group.prototype.moveUp = function(t) {
                if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                    var e = this.getIndex(t),
                        i = this.getAt(e + 1);
                    i && this.swap(t, i)
                }
                return t
            }, H.Group.prototype.moveDown = function(t) {
                if (t.parent === this && 0 < this.getIndex(t)) {
                    var e = this.getIndex(t),
                        i = this.getAt(e - 1);
                    i && this.swap(t, i)
                }
                return t
            }, H.Group.prototype.xy = function(t, e, i) {
                if (t < 0 || t > this.children.length) return -1;
                this.getChildAt(t).x = e, this.getChildAt(t).y = i
            }, H.Group.prototype.reverse = function() { this.children.reverse(), this.updateZ() }, H.Group.prototype.getIndex = function(t) { return this.children.indexOf(t) }, H.Group.prototype.getByName = function(t) {
                for (var e = 0; e < this.children.length; e++)
                    if (this.children[e].name === t) return this.children[e];
                return null
            }, H.Group.prototype.replace = function(t, e) { var i = this.getIndex(t); if (-1 !== i) return e.parent && (e.parent instanceof H.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, i), t }, H.Group.prototype.hasProperty = function(t, e) { var i = e.length; return 1 === i && e[0] in t || (2 === i && e[0] in t && e[1] in t[e[0]] || (3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]])) }, H.Group.prototype.setProperty = function(t, e, i, s, o) { if (void 0 === o && (o = !1), s = s || 0, !this.hasProperty(t, e) && (!o || 0 < s)) return !1; var n = e.length; return 1 === n ? 0 === s ? t[e[0]] = i : 1 === s ? t[e[0]] += i : 2 === s ? t[e[0]] -= i : 3 === s ? t[e[0]] *= i : 4 === s && (t[e[0]] /= i) : 2 === n ? 0 === s ? t[e[0]][e[1]] = i : 1 === s ? t[e[0]][e[1]] += i : 2 === s ? t[e[0]][e[1]] -= i : 3 === s ? t[e[0]][e[1]] *= i : 4 === s && (t[e[0]][e[1]] /= i) : 3 === n ? 0 === s ? t[e[0]][e[1]][e[2]] = i : 1 === s ? t[e[0]][e[1]][e[2]] += i : 2 === s ? t[e[0]][e[1]][e[2]] -= i : 3 === s ? t[e[0]][e[1]][e[2]] *= i : 4 === s && (t[e[0]][e[1]][e[2]] /= i) : 4 === n && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === s ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === s ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === s ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === s && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0 }, H.Group.prototype.checkProperty = function(t, e, i, s) { return void 0 === s && (s = !1), !(!H.Utils.getProperty(t, e) && s) && H.Utils.getProperty(t, e) === i }, H.Group.prototype.set = function(t, e, i, s, o, n, a) { if (void 0 === a && (a = !1), e = e.split("."), void 0 === s && (s = !1), void 0 === o && (o = !1), (!1 === s || s && t.alive) && (!1 === o || o && t.visible)) return this.setProperty(t, e, i, n, a) }, H.Group.prototype.setAll = function(t, e, i, s, o, n) { void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = !1), t = t.split("."), o = o || 0; for (var a = 0; a < this.children.length; a++)(!i || i && this.children[a].alive) && (!s || s && this.children[a].visible) && this.setProperty(this.children[a], t, e, o, n) }, H.Group.prototype.setAllChildren = function(t, e, i, s, o, n) { void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = !1), o = o || 0; for (var a = 0; a < this.children.length; a++)(!i || i && this.children[a].alive) && (!s || s && this.children[a].visible) && (this.children[a] instanceof H.Group ? this.children[a].setAllChildren(t, e, i, s, o, n) : this.setProperty(this.children[a], t.split("."), e, o, n)) }, H.Group.prototype.checkAll = function(t, e, i, s, o) {
                void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === o && (o = !1);
                for (var n = 0; n < this.children.length; n++)
                    if ((!i || i && this.children[n].alive) && (!s || s && this.children[n].visible) && !this.checkProperty(this.children[n], t, e, o)) return !1;
                return !0
            }, H.Group.prototype.addAll = function(t, e, i, s) { this.setAll(t, e, i, s, 1) }, H.Group.prototype.subAll = function(t, e, i, s) { this.setAll(t, e, i, s, 2) }, H.Group.prototype.multiplyAll = function(t, e, i, s) { this.setAll(t, e, i, s, 3) }, H.Group.prototype.divideAll = function(t, e, i, s) { this.setAll(t, e, i, s, 4) }, H.Group.prototype.callAllExists = function(t, e) { var i; if (2 < arguments.length) { i = []; for (var s = 2; s < arguments.length; s++) i.push(arguments[s]) } for (s = 0; s < this.children.length; s++) this.children[s].exists === e && this.children[s][t] && this.children[s][t].apply(this.children[s], i) }, H.Group.prototype.callbackFromArray = function(t, e, i) { if (1 === i) { if (t[e[0]]) return t[e[0]] } else if (2 === i) { if (t[e[0]][e[1]]) return t[e[0]][e[1]] } else if (3 === i) { if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]] } else if (4 === i) { if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]] } else if (t[e]) return t[e]; return !1 }, H.Group.prototype.callAll = function(t, e) {
                if (void 0 !== t) {
                    var i, s = (t = t.split(".")).length;
                    if (null == e || "" === e) e = null;
                    else if ("string" == typeof e) var o = (e = e.split(".")).length;
                    if (2 < arguments.length) { i = []; for (var n = 2; n < arguments.length; n++) i.push(arguments[n]) }
                    var a = null,
                        r = null;
                    for (n = 0; n < this.children.length; n++) a = this.callbackFromArray(this.children[n], t, s), e && a ? (r = this.callbackFromArray(this.children[n], e, o), a && a.apply(r, i)) : a && a.apply(this.children[n], i)
                }
            }, H.Group.prototype.preUpdate = function() { if (this.pendingDestroy) return this.destroy(), !1; if (!this.exists || !this.parent.exists) return !(this.renderOrderID = -1); for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate(); return !0 }, H.Group.prototype.update = function() { for (var t = this.children.length; t--;) this.children[t].update() }, H.Group.prototype.postUpdate = function() { this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y); for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate() }, H.Group.prototype.filter = function(t, e) {
                for (var i = -1, s = this.children.length, o = []; ++i < s;) {
                    var n = this.children[i];
                    (!e || e && n.exists) && t(n, i, this.children) && o.push(n)
                }
                return new H.ArraySet(o)
            }, H.Group.prototype.forEach = function(t, e, i) {
                if (void 0 === i && (i = !1), arguments.length <= 3)
                    for (var s = 0; s < this.children.length; s++)(!i || i && this.children[s].exists) && t.call(e, this.children[s]);
                else { var o = [null]; for (s = 3; s < arguments.length; s++) o.push(arguments[s]); for (s = 0; s < this.children.length; s++)(!i || i && this.children[s].exists) && (o[0] = this.children[s], t.apply(e, o)) }
            }, H.Group.prototype.forEachExists = function(t, e) { var i; if (2 < arguments.length) { i = [null]; for (var s = 2; s < arguments.length; s++) i.push(arguments[s]) } this.iterate("exists", !0, H.Group.RETURN_TOTAL, t, e, i) }, H.Group.prototype.forEachAlive = function(t, e) { var i; if (2 < arguments.length) { i = [null]; for (var s = 2; s < arguments.length; s++) i.push(arguments[s]) } this.iterate("alive", !0, H.Group.RETURN_TOTAL, t, e, i) }, H.Group.prototype.forEachDead = function(t, e) { var i; if (2 < arguments.length) { i = [null]; for (var s = 2; s < arguments.length; s++) i.push(arguments[s]) } this.iterate("alive", !1, H.Group.RETURN_TOTAL, t, e, i) }, H.Group.prototype.sort = function(t, e) { this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = H.Group.SORT_ASCENDING), this._sortProperty = t, e === H.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ()) }, H.Group.prototype.customSort = function(t, e) { this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ()) }, H.Group.prototype.ascendingSortHandler = function(t, e) { return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1 }, H.Group.prototype.descendingSortHandler = function(t, e) { return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0 }, H.Group.prototype.iterate = function(t, e, i, s, o, n) {
                if (0 === this.children.length) { if (i === H.Group.RETURN_TOTAL) return 0; if (i === H.Group.RETURN_ALL) return [] }
                var a = 0;
                if (i === H.Group.RETURN_ALL) var r = [];
                for (var h = 0; h < this.children.length; h++)
                    if (this.children[h][t] === e) {
                        if (a++, s && (n ? (n[0] = this.children[h], s.apply(o, n)) : s.call(o, this.children[h])), i === H.Group.RETURN_CHILD) return this.children[h];
                        i === H.Group.RETURN_ALL && r.push(this.children[h])
                    }
                return i === H.Group.RETURN_TOTAL ? a : i === H.Group.RETURN_ALL ? r : null
            }, H.Group.prototype.getFirstExists = function(t, e, i, s, o, n) { void 0 === e && (e = !1), "boolean" != typeof t && (t = !0); var a = this.iterate("exists", t, H.Group.RETURN_CHILD); return null === a && e ? this.create(i, s, o, n) : this.resetChild(a, i, s, o, n) }, H.Group.prototype.getFirstAlive = function(t, e, i, s, o) { void 0 === t && (t = !1); var n = this.iterate("alive", !0, H.Group.RETURN_CHILD); return null === n && t ? this.create(e, i, s, o) : this.resetChild(n, e, i, s, o) }, H.Group.prototype.getFirstDead = function(t, e, i, s, o) { void 0 === t && (t = !1); var n = this.iterate("alive", !1, H.Group.RETURN_CHILD); return null === n && t ? this.create(e, i, s, o) : this.resetChild(n, e, i, s, o) }, H.Group.prototype.resetChild = function(t, e, i, s, o) { return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== s && t.loadTexture(s, o), t) }, H.Group.prototype.getTop = function() { if (0 < this.children.length) return this.children[this.children.length - 1] }, H.Group.prototype.getBottom = function() { if (0 < this.children.length) return this.children[0] }, H.Group.prototype.getClosestTo = function(t, e, i) {
                for (var s = Number.MAX_VALUE, o = 0, n = null, a = 0; a < this.children.length; a++) {
                    var r = this.children[a];
                    r.exists && (o = Math.abs(H.Point.distance(t, r))) < s && (!e || e.call(i, r, o)) && (s = o, n = r)
                }
                return n
            }, H.Group.prototype.getFurthestFrom = function(t, e, i) {
                for (var s = 0, o = 0, n = null, a = 0; a < this.children.length; a++) {
                    var r = this.children[a];
                    r.exists && s < (o = Math.abs(H.Point.distance(t, r))) && (!e || e.call(i, r, o)) && (s = o, n = r)
                }
                return n
            }, H.Group.prototype.countLiving = function() { return this.iterate("alive", !0, H.Group.RETURN_TOTAL) }, H.Group.prototype.countDead = function() { return this.iterate("alive", !1, H.Group.RETURN_TOTAL) }, H.Group.prototype.getRandom = function(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : H.ArrayUtils.getRandomItem(this.children, t, e) }, H.Group.prototype.getRandomExists = function(t, e) { var i = this.getAll("exists", !0, t, e); return this.game.rnd.pick(i) }, H.Group.prototype.getAll = function(t, e, i, s) {
                void 0 === i && (i = 0), void 0 === s && (s = this.children.length);
                for (var o = [], n = i; n < s; n++) {
                    var a = this.children[n];
                    t && a[t] === e && o.push(a)
                }
                return o
            }, H.Group.prototype.remove = function(t, e, i) {
                if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
                i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
                var s = this.removeChild(t);
                return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && s && s.destroy(!0), !0
            }, H.Group.prototype.moveAll = function(t, e) {
                if (void 0 === e && (e = !1), 0 < this.children.length && t instanceof H.Group) {
                    for (; t.add(this.children[0], e), 0 < this.children.length;);
                    this.hash = [], this.cursor = null
                }
                return t
            }, H.Group.prototype.removeAll = function(t, e, i) {
                if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                    do {
                        !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                        var s = this.removeChild(this.children[0]);
                        this.removeFromHash(s), t && s && s.destroy(!0, i)
                    } while (0 < this.children.length);
                    this.hash = [], this.cursor = null
                }
            }, H.Group.prototype.removeBetween = function(t, e, i, s) {
                if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === s && (s = !1), 0 !== this.children.length) {
                    if (e < t || t < 0 || e > this.children.length) return !1;
                    for (var o = e; t <= o;) {
                        !s && this.children[o].events && this.children[o].events.onRemovedFromGroup$dispatch(this.children[o], this);
                        var n = this.removeChild(this.children[o]);
                        this.removeFromHash(n), i && n && n.destroy(!0), this.cursor === this.children[o] && (this.cursor = null), o--
                    }
                    this.updateZ()
                }
            }, H.Group.prototype.destroy = function(t, e) { null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1)) }, Object.defineProperty(H.Group.prototype, "total", { get: function() { return this.iterate("exists", !0, H.Group.RETURN_TOTAL) } }), Object.defineProperty(H.Group.prototype, "length", { get: function() { return this.children.length } }), Object.defineProperty(H.Group.prototype, "angle", { get: function() { return H.Math.radToDeg(this.rotation) }, set: function(t) { this.rotation = H.Math.degToRad(t) } }), Object.defineProperty(H.Group.prototype, "centerX", {
                get: function() { return this.getBounds(this.parent).centerX },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i - e.halfWidth
                }
            }), Object.defineProperty(H.Group.prototype, "centerY", {
                get: function() { return this.getBounds(this.parent).centerY },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i - e.halfHeight
                }
            }), Object.defineProperty(H.Group.prototype, "left", {
                get: function() { return this.getBounds(this.parent).left },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i
                }
            }), Object.defineProperty(H.Group.prototype, "right", {
                get: function() { return this.getBounds(this.parent).right },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i - e.width
                }
            }), Object.defineProperty(H.Group.prototype, "top", {
                get: function() { return this.getBounds(this.parent).top },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i
                }
            }), Object.defineProperty(H.Group.prototype, "bottom", {
                get: function() { return this.getBounds(this.parent).bottom },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i - e.height
                }
            }), H.World = function(t) { H.Group.call(this, t, null, "__world", !1), this.bounds = new H.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this) }, H.World.prototype = Object.create(H.Group.prototype), H.World.prototype.constructor = H.World, H.World.prototype.boot = function() { this.camera = new H.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot() }, H.World.prototype.stateChange = function() { this.x = 0, this.y = 0, this.camera.reset() }, H.World.prototype.setBounds = function(t, e, i, s) { this._definedSize = !0, this._width = i, this._height = s, this.bounds.setTo(t, e, i, s), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(s, this.game.height)), this.game.physics.setBoundsToWorld() }, H.World.prototype.resize = function(t, e) { this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld() }, H.World.prototype.shutdown = function() { this.destroy(!0, !0) }, H.World.prototype.wrap = function(t, e, i, s, o) { void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === s && (s = !0), void 0 === o && (o = !0), i ? (t.getBounds(), s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), o && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), o && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : o && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e)) }, Object.defineProperty(H.World.prototype, "width", { get: function() { return this.bounds.width }, set: function(t) { t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0 } }), Object.defineProperty(H.World.prototype, "height", { get: function() { return this.bounds.height }, set: function(t) { t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0 } }), Object.defineProperty(H.World.prototype, "centerX", { get: function() { return this.bounds.halfWidth + this.bounds.x } }), Object.defineProperty(H.World.prototype, "centerY", { get: function() { return this.bounds.halfHeight + this.bounds.y } }), Object.defineProperty(H.World.prototype, "randomX", { get: function() { return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width) } }), Object.defineProperty(H.World.prototype, "randomY", { get: function() { return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height) } }), H.Game = function(t, e, i, s, o, n, a, r) { return this.id = H.GAMES.push(this) - 1, this.config = null, this.physicsConfig = r, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = H.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = H.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new H.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof t ? this.parseConfig(t) : (this.config = { enableDebug: !0 }, void 0 !== t && (this._width = t), void 0 !== e && (this._height = e), void 0 !== i && (this.renderType = i), void 0 !== s && (this.parent = s), void 0 !== n && (this.transparent = n), void 0 !== a && (this.antialias = a), this.rnd = new H.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new H.StateManager(this, o)), this.device.whenReady(this.boot, this), this }, H.Game.prototype = {
                parseConfig: function(t) {
                    void 0 === (this.config = t).enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                    var e = [(Date.now() * Math.random()).toString()];
                    t.seed && (e = t.seed), this.rnd = new H.RandomDataGenerator(e);
                    var i = null;
                    t.state && (i = t.state), this.state = new H.StateManager(this, i)
                },
                boot: function() { this.isBooted || (this.onPause = new H.Signal, this.onResume = new H.Signal, this.onBlur = new H.Signal, this.onFocus = new H.Signal, this.isBooted = !0, (PIXI.game = this).math = H.Math, this.scale = new H.ScaleManager(this, this._width, this._height), this.stage = new H.Stage(this), this.setUpRenderer(), this.world = new H.World(this), this.add = new H.GameObjectFactory(this), this.make = new H.GameObjectCreator(this), this.cache = new H.Cache(this), this.load = new H.Loader(this), this.time = new H.Time(this), this.tweens = new H.TweenManager(this), this.input = new H.Input(this), this.sound = new H.SoundManager(this), this.physics = new H.Physics(this, this.physicsConfig), this.particles = new H.Particles(this), this.create = new H.Create(this), this.plugins = new H.PluginManager(this), this.net = new H.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new H.Utils.Debug(this), this.debug.boot()) : this.debug = { preUpdate: function() {}, update: function() {}, reset: function() {} }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new H.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new H.RequestAnimationFrame(this, !1), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start()) },
                showDebugHeader: function() {
                    if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                        var t = H.VERSION,
                            e = "Canvas",
                            i = "HTML Audio",
                            s = 1;
                        if (this.renderType === H.WEBGL ? (e = "WebGL", s++) : this.renderType === H.HEADLESS && (e = "Headless"), this.device.webAudio && (i = "WebAudio", s++), this.device.chrome)
                            for (var o = ["%c %c %c @orange-games/phaser v" + t + " | Pixi.js | " + e + " | " + i + "  %c %c %c https://github.com/orange-games / https://www.orangegames.com %c%c%c", "background: #F47820", "background: #ED873F", "color: #ffffff; background: #DD6612;", "background: #ED873F", "background: #F47820", "background: #ffffff"], n = 0; n < 3; n++) n < s ? o.push("color: #ff2424; background: #fff") : o.push("color: #959595; background: #fff");
                        else window.console
                    }
                },
                setUpRenderer: function() {
                    if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = H.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === H.HEADLESS || this.renderType === H.CANVAS || this.renderType === H.AUTO && !this.device.webGL) {
                        if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                        this.renderType = H.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context
                    }
                    else this.renderType = H.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
                    this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === H.CANVAS), this.renderType !== H.HEADLESS && (this.stage.smoothed = this.antialias, H.Canvas.addToDOM(this.canvas, this.parent, !1), H.Canvas.setTouchAction(this.canvas))
                },
                contextLost: function(t) { t.preventDefault(), this.renderer.contextLost = !0 },
                contextRestored: function() { this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1 },
                update: function(t) {
                    if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                    if (1 < this._spiraling && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps);
                    else {
                        var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                        this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                        var i = 0;
                        for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                        i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.updateRender(this._deltaTime / e)
                    }
                },
                updateLogic: function(t) { this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform() },
                updateRender: function(t) { this.lockRender || (this.state.preRender(t), this.renderType !== H.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t)), this.plugins.postRender(t)) },
                enableStep: function() { this.stepping = !0, this.pendingStep = !1, this.stepCount = 0 },
                disableStep: function() { this.stepping = !1, this.pendingStep = !1 },
                step: function() { this.pendingStep = !1, this.stepCount++ },
                destroy: function() { this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), H.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, H.GAMES[this.id] = null },
                gamePaused: function(t) { this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0)) },
                gameResumed: function(t) { this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1)) },
                focusLoss: function(t) { this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t) },
                focusGain: function(t) { this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t) }
            }, H.Game.prototype.constructor = H.Game, Object.defineProperty(H.Game.prototype, "paused", { get: function() { return this._paused }, set: function(t) { this._codePaused = !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), !1) } }), H.Input = function(t) { this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = H.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new H.ArraySet, this._localPoint = new H.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0 }, H.Input.MOUSE_OVERRIDES_TOUCH = 0, H.Input.TOUCH_OVERRIDES_MOUSE = 1, H.Input.MOUSE_TOUCH_COMBINE = 2, H.Input.MAX_POINTERS = 10, H.Input.prototype = {
                boot: function() {
                    this.mousePointer = new H.Pointer(this.game, 0, H.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new H.Mouse(this.game), this.touch = new H.Touch(this.game), this.mspointer = new H.MSPointer(this.game), H.Keyboard && (this.keyboard = new H.Keyboard(this.game)), H.Gamepad && (this.gamepad = new H.Gamepad(this.game)), this.onDown = new H.Signal, this.onUp = new H.Signal, this.onTap = new H.Signal, this.onHold = new H.Signal, this.scale = new H.Point(1, 1), this.speed = new H.Point, this.position = new H.Point, this._oldPosition = new H.Point, this.circle = new H.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.game.device.touch ? this.touch.start() : this.game.device.mspointer && this.mspointer.start(), this.mspointer.active || this.mouse.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
                    var e = this;
                    this._onClickTrampoline = function(t) { e.onClickTrampoline(t) }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
                },
                destroy: function() { this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline) },
                setInteractiveCandidateHandler: function(t, e) { this.customCandidateHandler = t, this.customCandidateHandlerContext = e },
                addMoveCallback: function(t, e) { this.moveCallbacks.push({ callback: t, context: e }) },
                deleteMoveCallback: function(t, e) {
                    for (var i = this.moveCallbacks.length; i--;)
                        if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
                },
                addPointer: function() {
                    if (this.pointers.length >= H.Input.MAX_POINTERS) return null;
                    var t = this.pointers.length + 1,
                        e = new H.Pointer(this.game, t, H.PointerMode.TOUCH);
                    return this.pointers.push(e), this["pointer" + t] = e
                },
                update: function() {
                    if (this.keyboard && this.keyboard.update(), 0 < this.pollRate && this._pollCounter < this.pollRate) this._pollCounter++;
                    else {
                        this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                        for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                        this._pollCounter = 0
                    }
                },
                reset: function(t) { if (this.game.isBooted && !this.resetLocked) { void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t), this.gamepad && this.gamepad.reset(); for (var e = 0; e < this.pointers.length; e++) this.pointers[e].reset(); "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new H.Signal, this.onUp = new H.Signal, this.onTap = new H.Signal, this.onHold = new H.Signal, this.moveCallbacks = []), this._pollCounter = 0 } },
                resetSpeed: function(t, e) { this._oldPosition.setTo(t, e), this.speed.setTo(0, 0) },
                startPointer: function(t) { if (0 <= this.maxPointers && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null; if (!this.pointer1.active) return this.pointer1.start(t); if (!this.pointer2.active) return this.pointer2.start(t); for (var e = 2; e < this.pointers.length; e++) { var i = this.pointers[e]; if (!i.active) return i.start(t) } return null },
                updatePointer: function(t) { if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t); if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t); for (var e = 2; e < this.pointers.length; e++) { var i = this.pointers[e]; if (i.active && i.identifier === t.identifier) return i.move(t) } return null },
                stopPointer: function(t) { if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t); if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t); for (var e = 2; e < this.pointers.length; e++) { var i = this.pointers[e]; if (i.active && i.identifier === t.identifier) return i.stop(t) } return null },
                countActivePointers: function(t) { void 0 === t && (t = this.pointers.length); for (var e = t, i = 0; i < this.pointers.length && 0 < e; i++) { this.pointers[i].active && e-- } return t - e },
                getPointer: function(t) { void 0 === t && (t = !1); for (var e = 0; e < this.pointers.length; e++) { var i = this.pointers[e]; if (i.active === t) return i } return null },
                getPointerFromIdentifier: function(t) { for (var e = 0; e < this.pointers.length; e++) { var i = this.pointers[e]; if (i.identifier === t) return i } return null },
                getPointerFromId: function(t) { for (var e = 0; e < this.pointers.length; e++) { var i = this.pointers[e]; if (i.pointerId === t) return i } return null },
                getLocalPosition: function(t, e, i) {
                    void 0 === i && (i = new H.Point);
                    var s = t.worldTransform,
                        o = 1 / (s.a * s.d + s.c * -s.b);
                    return i.setTo(s.d * o * e.x + -s.c * o * e.y + (s.ty * s.c - s.tx * s.d) * o, s.a * o * e.y + -s.b * o * e.x + (-s.ty * s.a + s.tx * s.b) * o)
                },
                hitTest: function(t, e, i) {
                    if (!t.worldVisible) return !1;
                    if (this.getLocalPosition(t, e, this._localPoint), i.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                    if (t instanceof H.TileSprite) {
                        var s = t.width,
                            o = t.height,
                            n = -s * t.anchor.x;
                        if (this._localPoint.x >= n && this._localPoint.x < n + s) { var a = -o * t.anchor.y; if (this._localPoint.y >= a && this._localPoint.y < a + o) return !0 }
                    }
                    else if (t instanceof PIXI.Sprite) { s = t.texture.frame.width, o = t.texture.frame.height, n = -s * t.anchor.x; if (this._localPoint.x >= n && this._localPoint.x < n + s) { a = -o * t.anchor.y; if (this._localPoint.y >= a && this._localPoint.y < a + o) return !0 } }
                    else if (H.Graphics && t instanceof H.Graphics)
                        for (var r = 0; r < t.graphicsData.length; r++) { var h = t.graphicsData[r]; if (h.fill && (h.shape && h.shape.contains(this._localPoint.x, this._localPoint.y))) return !0 }
                    for (r = 0; r < t.children.length; r++)
                        if (this.hitTest(t.children[r], e, i)) return !0;
                    return !1
                },
                onClickTrampoline: function() { this.activePointer.processClickTrampolines() }
            }, H.Input.prototype.constructor = H.Input, Object.defineProperty(H.Input.prototype, "x", { get: function() { return this._x }, set: function(t) { this._x = Math.floor(t) } }), Object.defineProperty(H.Input.prototype, "y", { get: function() { return this._y }, set: function(t) { this._y = Math.floor(t) } }), Object.defineProperty(H.Input.prototype, "pollLocked", { get: function() { return 0 < this.pollRate && this._pollCounter < this.pollRate } }), Object.defineProperty(H.Input.prototype, "totalInactivePointers", { get: function() { return this.pointers.length - this.countActivePointers() } }), Object.defineProperty(H.Input.prototype, "totalActivePointers", { get: function() { return this.countActivePointers() } }), Object.defineProperty(H.Input.prototype, "worldX", { get: function() { return this.game.camera.view.x + this.x } }), Object.defineProperty(H.Input.prototype, "worldY", { get: function() { return this.game.camera.view.y + this.y } }), H.Mouse = function(t) { this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new H.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null }, H.Mouse.NO_BUTTON = -1, H.Mouse.LEFT_BUTTON = 0, H.Mouse.MIDDLE_BUTTON = 1, H.Mouse.RIGHT_BUTTON = 2, H.Mouse.BACK_BUTTON = 3, H.Mouse.FORWARD_BUTTON = 4, H.Mouse.WHEEL_UP = 1, H.Mouse.WHEEL_DOWN = -1, H.Mouse.prototype = {
                start: function() {
                    if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) {
                        var e = this;
                        this._onMouseDown = function(t) { return e.onMouseDown(t) }, this._onMouseMove = function(t) { return e.onMouseMove(t) }, this._onMouseUp = function(t) { return e.onMouseUp(t) }, this._onMouseUpGlobal = function(t) { return e.onMouseUpGlobal(t) }, this._onMouseOutGlobal = function(t) { return e.onMouseOutGlobal(t) }, this._onMouseOut = function(t) { return e.onMouseOut(t) }, this._onMouseOver = function(t) { return e.onMouseOver(t) }, this._onMouseWheel = function(t) { return e.onMouseWheel(t) };
                        var t = this.game.canvas;
                        t.addEventListener("mousedown", this._onMouseDown, !0), t.addEventListener("mousemove", this._onMouseMove, !0), t.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), t.addEventListener("mouseover", this._onMouseOver, !0), t.addEventListener("mouseout", this._onMouseOut, !0));
                        var i = this.game.device.wheelEvent;
                        i && (t.addEventListener(i, this._onMouseWheel, !0), "mousewheel" === i ? this._wheelEvent = new s(-.025, 1) : "DOMMouseScroll" === i && (this._wheelEvent = new s(1, 1)))
                    }
                },
                onMouseDown: function(t) { this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t)) },
                onMouseMove: function(t) { this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t)) },
                onMouseUp: function(t) { this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t)) },
                onMouseUpGlobal: function(t) { this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t)) },
                onMouseOutGlobal: function(t) { this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.leftButton.stop(t), this.input.mousePointer.rightButton.stop(t)) },
                onMouseOut: function(t) { this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t)) },
                onMouseOver: function(t) { this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t) },
                onMouseWheel: function(t) { this._wheelEvent && (t = this._wheelEvent.bindEvent(t)), this.event = t, this.capture && t.preventDefault(), this.wheelDelta = H.Math.clamp(-t.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t) },
                requestPointerLock: function() {
                    if (this.game.device.pointerLock) {
                        var t = this.game.canvas;
                        t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock();
                        var e = this;
                        this._pointerLockChange = function(t) { return e.pointerLockChange(t) }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                    }
                },
                pointerLockChange: function(t) {
                    var e = this.game.canvas;
                    document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t))
                },
                releasePointerLock: function() { document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0) },
                stop: function() {
                    var t = this.game.canvas;
                    t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0);
                    var e = this.game.device.wheelEvent;
                    e && t.removeEventListener(e, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                }
            }, H.Mouse.prototype.constructor = H.Mouse, ((s.prototype = {}).constructor = s).prototype.bindEvent = function(t) {
                if (!s._stubsGenerated && t) {
                    var e = function(e) { return function() { var t = this.originalEvent[e]; return "function" != typeof t ? t : t.bind(this.originalEvent) } };
                    for (var i in t) i in s.prototype || Object.defineProperty(s.prototype, i, { get: e(i) });
                    s._stubsGenerated = !0
                }
                return this.originalEvent = t, this
            }, Object.defineProperties(s.prototype, { type: { value: "wheel" }, deltaMode: { get: function() { return this._deltaMode } }, deltaY: { get: function() { return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0 } }, deltaX: { get: function() { return this._scaleFactor * this.originalEvent.wheelDeltaX || 0 } }, deltaZ: { value: 0 } }), H.MSPointer = function(t) { this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null }, H.MSPointer.prototype = {
                start: function() {
                    if (null === this._onMSPointerDown) {
                        var e = this;
                        if (this.game.device.mspointer) {
                            this._onMSPointerDown = function(t) { return e.onPointerDown(t) }, this._onMSPointerMove = function(t) { return e.onPointerMove(t) }, this._onMSPointerUp = function(t) { return e.onPointerUp(t) }, this._onMSPointerUpGlobal = function(t) { return e.onPointerUpGlobal(t) }, this._onMSPointerOut = function(t) { return e.onPointerOut(t) }, this._onMSPointerOver = function(t) { return e.onPointerOver(t) };
                            var t = this.game.canvas;
                            t.addEventListener("MSPointerDown", this._onMSPointerDown, !1), t.addEventListener("MSPointerMove", this._onMSPointerMove, !1), t.addEventListener("MSPointerUp", this._onMSPointerUp, !1), t.addEventListener("pointerdown", this._onMSPointerDown, !1), t.addEventListener("pointermove", this._onMSPointerMove, !1), t.addEventListener("pointerup", this._onMSPointerUp, !1), t.style["-ms-content-zooming"] = "none", t.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.addEventListener("MSPointerOver", this._onMSPointerOver, !0), t.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.addEventListener("pointerover", this._onMSPointerOver, !0), t.addEventListener("pointerout", this._onMSPointerOut, !0))
                        }
                    }
                },
                onPointerDown: function(t) { this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t)) },
                onPointerMove: function(t) { this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t)) },
                onPointerUp: function(t) { this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t)) },
                onPointerUpGlobal: function(t) {
                    if ("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && e.withinGame && this.onPointerUp(t)
                    }
                    else this.onPointerUp(t)
                },
                onPointerOut: function(t) {
                    if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1;
                    else {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && (e.withinGame = !1)
                    }
                    this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, e ? e.stop(t) : this.input.mousePointer.stop(t))
                },
                onPointerOver: function(t) {
                    if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0;
                    else {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && (e.withinGame = !0)
                    }
                    this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
                },
                stop: function() {
                    var t = this.game.canvas;
                    t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0)
                }
            }, H.MSPointer.prototype.constructor = H.MSPointer, H.DeviceButton = function(t, e) { this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new H.Signal, this.onUp = new H.Signal, this.onFloat = new H.Signal }, H.DeviceButton.prototype = { start: function(t, e) { this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e)) }, stop: function(t, e) { this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e)) }, padFloat: function(t) { this.value = t, this.onFloat.dispatch(this, t) }, justPressed: function(t) { return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time }, justReleased: function(t) { return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time }, reset: function() { this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1 }, destroy: function() { this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null } }, H.DeviceButton.prototype.constructor = H.DeviceButton, Object.defineProperty(H.DeviceButton.prototype, "duration", { get: function() { return this.isUp ? -1 : this.game.time.time - this.timeDown } }), H.Pointer = function(t, e, i) { this.game = t, this.id = e, this.type = H.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = i || H.PointerMode.CURSOR | H.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new H.DeviceButton(this, H.Pointer.LEFT_BUTTON), this.middleButton = new H.DeviceButton(this, H.Pointer.MIDDLE_BUTTON), this.rightButton = new H.DeviceButton(this, H.Pointer.RIGHT_BUTTON), this.backButton = new H.DeviceButton(this, H.Pointer.BACK_BUTTON), this.forwardButton = new H.DeviceButton(this, H.Pointer.FORWARD_BUTTON), this.eraserButton = new H.DeviceButton(this, H.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new H.Point, this.positionDown = new H.Point, this.positionUp = new H.Point, this.circle = new H.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null }, H.Pointer.NO_BUTTON = 0, H.Pointer.LEFT_BUTTON = 1, H.Pointer.RIGHT_BUTTON = 2, H.Pointer.MIDDLE_BUTTON = 4, H.Pointer.BACK_BUTTON = 8, H.Pointer.FORWARD_BUTTON = 16, H.Pointer.ERASER_BUTTON = 32, H.Pointer.prototype = {
                resetButtons: function() { this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset()) },
                processButtonsDown: function(t, e) { H.Pointer.LEFT_BUTTON & t && this.leftButton.start(e), H.Pointer.RIGHT_BUTTON & t && this.rightButton.start(e), H.Pointer.MIDDLE_BUTTON & t && this.middleButton.start(e), H.Pointer.BACK_BUTTON & t && this.backButton.start(e), H.Pointer.FORWARD_BUTTON & t && this.forwardButton.start(e), H.Pointer.ERASER_BUTTON & t && this.eraserButton.start(e) },
                processButtonsUp: function(t, e) { t === H.Mouse.LEFT_BUTTON && this.leftButton.stop(e), t === H.Mouse.RIGHT_BUTTON && this.rightButton.stop(e), t === H.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e), t === H.Mouse.BACK_BUTTON && this.backButton.stop(e), t === H.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e), 5 === t && this.eraserButton.stop(e) },
                updateButtons: function(t) {
                    this.button = t.button;
                    var e = "down" === t.type.toLowerCase().substr(-4);
                    void 0 !== t.buttons ? e ? this.processButtonsDown(t.buttons, t) : this.processButtonsUp(t.button, t) : e ? this.leftButton.start(t) : (this.leftButton.stop(t), this.rightButton.stop(t)), 1 === t.buttons && t.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(t), this.rightButton.start(t)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
                },
                start: function(t) { var e = this.game.input; return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === H.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === H.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === H.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this },
                update: function() {
                    var t = this.game.input;
                    this.active && (this.dirty && (0 < t.interactiveItems.total && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === H.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === H.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === H.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({ x: this.position.x, y: this.position.y }), this._history.length > t.recordLimit && this._history.shift()))
                },
                move: function(t, e) { var i = this.game.input; if (!i.pollLocked) { void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), e && this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && i.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * i.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * i.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (i.multiInputOverride === H.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === H.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === H.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.activePointer = this, i.x = this.x, i.y = this.y, i.position.setTo(i.x, i.y), i.circle.x = i.x, i.circle.y = i.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY); for (var s = i.moveCallbacks.length; s--;) i.moveCallbacks[s].callback.call(i.moveCallbacks[s].context, this, this.x, this.y, e); return null !== this.targetObject && !0 === this.targetObject.isDragged ? !1 === this.targetObject.update(this) && (this.targetObject = null) : 0 < i.interactiveItems.total && this.processInteractiveObjects(e), this } },
                processInteractiveObjects: function(t) {
                    var e = 0,
                        i = -1,
                        s = null,
                        o = this.game.input.interactiveItems.first;
                    for (this.interactiveCandidates = []; o;) o.checked = !1, o.validForInput(i, e, !1) && (o.checked = !0, (t && o.checkPointerDown(this, !0) || !t && o.checkPointerOver(this, !0)) && (e = o.sprite.renderOrderID, i = o.priorityID, s = o, this.interactiveCandidates.push(o))), o = this.game.input.interactiveItems.next;
                    for (o = this.game.input.interactiveItems.first; o;) !o.checked && o.validForInput(i, e, !0) && (t && o.checkPointerDown(this, !1) || !t && o.checkPointerOver(this, !1)) && (e = o.sprite.renderOrderID, i = o.priorityID, s = o, this.interactiveCandidates.push(o)), o = this.game.input.interactiveItems.next;
                    return this.game.input.customCandidateHandler && (s = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, s)), this.swapTarget(s, !1), null !== this.targetObject
                },
                swapTarget: function(t, e) { void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t)._pointerOverHandler(this, e) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e)) },
                leave: function(t) { this.withinGame = !1, this.move(t, !1) },
                stop: function(t) {
                    var e = this.game.input;
                    if (!this._stateReset || !this.withinGame) return this.timeUp = this.game.time.time, (e.multiInputOverride === H.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === H.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === H.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), 0 <= this.duration && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), 0 < this.id && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && e.currentPointers--, e.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this;
                    t.preventDefault()
                },
                justPressed: function(t) { return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time },
                justReleased: function(t) { return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time },
                addClickTrampoline: function(t, e, i, s) {
                    if (this.isDown) {
                        for (var o = this._clickTrampolines = this._clickTrampolines || [], n = 0; n < o.length; n++)
                            if (o[n].name === t) { o.splice(n, 1); break }
                        o.push({ name: t, targetObject: this.targetObject, callback: e, callbackContext: i, callbackArgs: s })
                    }
                },
                processClickTrampolines: function() {
                    var t = this._clickTrampolines;
                    if (t) {
                        for (var e = 0; e < t.length; e++) {
                            var i = t[e];
                            i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                        }
                        this._clickTrampolines = null, this._trampolineTargetObject = null
                    }
                },
                reset: function() {!1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null },
                resetMovement: function() { this.movementX = 0, this.movementY = 0 }
            }, H.Pointer.prototype.constructor = H.Pointer, Object.defineProperty(H.Pointer.prototype, "duration", { get: function() { return this.isUp ? -1 : this.game.time.time - this.timeDown } }), Object.defineProperty(H.Pointer.prototype, "worldX", { get: function() { return this.game.world.camera.x + this.x } }), Object.defineProperty(H.Pointer.prototype, "worldY", { get: function() { return this.game.world.camera.y + this.y } }), H.PointerMode = { CURSOR: 1, CONTACT: 2 }, H.Touch = function(t) { this.game = t, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null }, H.Touch.prototype = {
                start: function() {
                    if (null === this._onTouchStart) {
                        var e = this;
                        this.game.device.touch && (this._onTouchStart = function(t) { return e.onTouchStart(t) }, this._onTouchMove = function(t) { return e.onTouchMove(t) }, this._onTouchEnd = function(t) { return e.onTouchEnd(t) }, this._onTouchEnter = function(t) { return e.onTouchEnter(t) }, this._onTouchLeave = function(t) { return e.onTouchLeave(t) }, this._onTouchCancel = function(t) { return e.onTouchCancel(t) }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                    }
                },
                consumeDocumentTouches: function() { this._documentTouchMove = function(t) { t.preventDefault() }, document.addEventListener("touchmove", this._documentTouchMove, !1) },
                addTouchLockCallback: function(t, e, i) { void 0 === i && (i = !1), this.touchLockCallbacks.push({ callback: t, context: e, onEnd: i }) },
                removeTouchLockCallback: function(t, e) {
                    for (var i = this.touchLockCallbacks.length; i--;)
                        if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
                    return !1
                },
                onTouchStart: function(t) { for (var e = this.touchLockCallbacks.length; e--;) { var i = this.touchLockCallbacks[e];!i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1) } if (this.event = t, this.game.input.enabled && this.enabled) { this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault(); for (e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e]) } },
                onTouchCancel: function(t) { if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) { this.preventDefault && t.preventDefault(); for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e]) } },
                onTouchEnter: function(t) { this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault() },
                onTouchLeave: function(t) { this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault() },
                onTouchMove: function(t) { this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault(); for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e]) },
                onTouchEnd: function(t) {
                    for (var e = this.touchLockCallbacks.length; e--;) {
                        var i = this.touchLockCallbacks[e];
                        i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                    }
                    this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                    for (e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                },
                stop: function() { this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel)) }
            }, H.Touch.prototype.constructor = H.Touch, H.InputHandler = function(t) { this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new H.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new H.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new H.Point, this.snapPoint = new H.Point, this._dragPoint = new H.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new H.Point, this._pointerData = [], this._pointerData.push({ id: 0, x: 0, y: 0, camX: 0, camY: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 }) }, H.InputHandler.prototype = {
                start: function(t, e) {
                    if (t = t || 0, void 0 === e && (e = !1), !1 === this.enabled) {
                        this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                        for (var i = 0; i < 10; i++) this._pointerData[i] = { id: i, x: 0, y: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 };
                        this.snapOffset = new H.Point, this.enabled = !0, this._wasEnabled = !0
                    }
                    return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
                },
                addedToGroup: function() { this._dragPhase || this._wasEnabled && !this.enabled && this.start() },
                removedFromGroup: function() { this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1) },
                reset: function() { this.enabled = !1; for (var t = 0; t < 10; t++) this._pointerData[t] = { id: t, x: 0, y: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 } },
                stop: function() {!1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this)) },
                destroy: function() { this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null) },
                validForInput: function(t, e, i) { return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e)) },
                isPixelPerfect: function() { return this.pixelPerfectClick || this.pixelPerfectOver },
                pointerX: function(t) { return t = t || 0, this._pointerData[t].x },
                pointerY: function(t) { return t = t || 0, this._pointerData[t].y },
                pointerDown: function(t) { return t = t || 0, this._pointerData[t].isDown },
                pointerUp: function(t) { return t = t || 0, this._pointerData[t].isUp },
                pointerTimeDown: function(t) { return t = t || 0, this._pointerData[t].timeDown },
                pointerTimeUp: function(t) { return t = t || 0, this._pointerData[t].timeUp },
                pointerOver: function(t) {
                    if (!this.enabled) return !1;
                    if (void 0 !== t) return this._pointerData[t].isOver;
                    for (var e = 0; e < 10; e++)
                        if (this._pointerData[e].isOver) return !0;
                    return !1
                },
                pointerOut: function(t) {
                    if (!this.enabled) return !1;
                    if (void 0 !== t) return this._pointerData[t].isOut;
                    for (var e = 0; e < 10; e++)
                        if (this._pointerData[e].isOut) return !0
                },
                pointerTimeOver: function(t) { return t = t || 0, this._pointerData[t].timeOver },
                pointerTimeOut: function(t) { return t = t || 0, this._pointerData[t].timeOut },
                pointerDragged: function(t) { return t = t || 0, this._pointerData[t].isDragged },
                checkPointerDown: function(t, e) { return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))) },
                checkPointerOver: function(t, e) { return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))) },
                checkPixel: function(t, e, i) {
                    if (this.sprite.texture.baseTexture.source) {
                        if (null === t && null === e) {
                            this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                            t = this._tempPoint.x, e = this._tempPoint.y
                        }
                        if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                        if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0
                    }
                    return !1
                },
                update: function(t) { if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = H.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1) },
                _pointerOverHandler: function(t, e) {
                    if (null !== this.sprite) {
                        var i = this._pointerData[t.id];
                        if (!1 === i.isOver || t.dirty) {
                            var s = !1 === i.isOver;
                            i.isOver = !0, i.isOut = !1, i.timeOver = this.game.time.time, i.x = t.x - this.sprite.x, i.y = t.y - this.sprite.y, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.type === H.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                        }
                    }
                },
                _pointerOutHandler: function(t, e) {
                    if (null !== this.sprite) {
                        var i = this._pointerData[t.id];
                        i.isOver = !1, i.isOut = !0, i.timeOut = this.game.time.time, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === H.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                    }
                },
                _touchedHandler: function(t) {
                    if (null !== this.sprite) {
                        var e = this._pointerData[t.id];
                        if (!e.isDown && e.isOver) {
                            if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                            if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === H.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                            this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, 0 < this.dragTimeThreshold ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                        }
                    }
                },
                dragTimeElapsed: function(t) { this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t) },
                _releasedHandler: function(t) {
                    if (null !== this.sprite) {
                        var e = this._pointerData[t.id];
                        if (e.isDown && t.isUp) {
                            e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                            var i = this.checkPointerOver(t);
                            this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, i), this.sprite && this.sprite.parent && this.sprite.parent.type === H.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, i), i && (i = this.checkPointerOver(t))), !(e.isOver = i) && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                        }
                    }
                },
                updateDrag: function(t, e) {
                    if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
                    var i = this.globalToLocalX(t.x) + this._dragPoint.x + this.dragOffset.x,
                        s = this.globalToLocalY(t.y) + this._dragPoint.y + this.dragOffset.y;
                    if (this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = i), this.allowVerticalDrag && (this.sprite.cameraOffset.y = s), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
                    else {
                        var o = this.game.camera.x - this._pointerData[t.id].camX,
                            n = this.game.camera.y - this._pointerData[t.id].camY;
                        this.allowHorizontalDrag && (this.sprite.x = i + o), this.allowVerticalDrag && (this.sprite.y = s + n), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y))
                    }
                    return this.sprite.events.onDragUpdate.dispatch(this.sprite, t, i, s, this.snapPoint, e), !0
                },
                justOver: function(t, e) { return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e },
                justOut: function(t, e) { return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e },
                justPressed: function(t, e) { return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e },
                justReleased: function(t, e) { return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e },
                overDuration: function(t) { return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1 },
                downDuration: function(t) { return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1 },
                enableDrag: function(t, e, i, s, o, n) { void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === s && (s = 255), void 0 === o && (o = null), void 0 === n && (n = null), this._dragPoint = new H.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new H.Point, this.dragFromCenter = t, this.pixelPerfectClick = i, this.pixelPerfectAlpha = s, o && (this.boundsRect = o), n && (this.boundsSprite = n) },
                disableDrag: function() {
                    if (this._pointerData)
                        for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                    this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
                },
                startDrag: function(t) {
                    var e = this.sprite.x,
                        i = this.sprite.y;
                    if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) {
                        if (this.dragFromCenter) {
                            var s = this.sprite.getBounds();
                            this.sprite.cameraOffset.x = this.globalToLocalX(t.x) + (this.sprite.cameraOffset.x - s.centerX), this.sprite.cameraOffset.y = this.globalToLocalY(t.y) + (this.sprite.cameraOffset.y - s.centerY)
                        }
                        this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)
                    }
                    else {
                        if (this.dragFromCenter) {
                            s = this.sprite.getBounds();
                            this.sprite.x = this.globalToLocalX(t.x) + (this.sprite.x - s.centerX), this.sprite.y = this.globalToLocalY(t.y) + (this.sprite.y - s.centerY)
                        }
                        this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(t.x), this.sprite.y - this.globalToLocalY(t.y))
                    }
                    this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(e, i), this.sprite.events.onDragStart$dispatch(this.sprite, t, e, i), this._pendingDrag = !1
                },
                globalToLocalX: function(t) { return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t },
                globalToLocalY: function(t) { return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t },
                stopDrag: function(t) { this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t) },
                setDragLock: function(t, e) { void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e },
                enableSnap: function(t, e, i, s, o, n) { void 0 === i && (i = !0), void 0 === s && (s = !1), void 0 === o && (o = 0), void 0 === n && (n = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = o, this.snapOffsetY = n, this.snapOnDrag = i, this.snapOnRelease = s },
                disableSnap: function() { this.snapOnDrag = !1, this.snapOnRelease = !1 },
                checkBoundsRect: function() { this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY))) },
                checkBoundsSprite: function() { this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY))) }
            }, H.InputHandler.prototype.constructor = H.InputHandler, H.Gamepad = function(t) { this.game = t, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], (this.callbackContext = this).onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new H.SinglePad(t, this), new H.SinglePad(t, this), new H.SinglePad(t, this), new H.SinglePad(t, this)] }, H.Gamepad.prototype = {
                addCallbacks: function(t, e) { void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t) },
                start: function() {
                    if (!this._active) {
                        this._active = !0;
                        var e = this;
                        this._onGamepadConnected = function(t) { return e.onGamepadConnected(t) }, this._onGamepadDisconnected = function(t) { return e.onGamepadDisconnected(t) }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
                    }
                },
                onGamepadConnected: function(t) {
                    var e = t.gamepad;
                    this._rawPads.push(e), this._gamepads[e.index].connect(e)
                },
                onGamepadDisconnected: function(t) {
                    var e = t.gamepad;
                    for (var i in this._rawPads) this._rawPads[i].index === e.index && this._rawPads.splice(i, 1);
                    this._gamepads[e.index].disconnect()
                },
                update: function() { this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus() },
                _pollGamepads: function() {
                    if (this._active) {
                        if (navigator.getGamepads) var t = navigator.getGamepads();
                        else if (navigator.webkitGetGamepads) t = navigator.webkitGetGamepads();
                        else if (navigator.webkitGamepads) t = navigator.webkitGamepads();
                        if (t) {
                            for (var e = !(this._rawPads = []), i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++);
                            for (var s = 0; s < this._gamepads.length; s++) this._gamepads[s]._rawPad = this._rawPads[s];
                            if (e) {
                                for (var o, n = { rawIndices: {}, padIndices: {} }, a = 0; a < this._gamepads.length; a++)
                                    if ((o = this._gamepads[a]).connected)
                                        for (var r = 0; r < this._rawPads.length; r++) this._rawPads[r].index === o.index && (n.rawIndices[o.index] = !0, n.padIndices[a] = !0);
                                for (var h = 0; h < this._gamepads.length; h++)
                                    if (o = this._gamepads[h], !n.padIndices[h]) { this._rawPads.length < 1 && o.disconnect(); for (var l = 0; l < this._rawPads.length && !n.padIndices[h]; l++) { var c = this._rawPads[l]; if (c) { if (n.rawIndices[c.index]) { o.disconnect(); continue } o.connect(c), n.rawIndices[c.index] = !0, n.padIndices[h] = !0 } else o.disconnect() } }
                            }
                        }
                    }
                },
                setDeadZones: function(t) { for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t },
                stop: function() { this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected) },
                reset: function() { this.update(); for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset() },
                justPressed: function(t, e) {
                    for (var i = 0; i < this._gamepads.length; i++)
                        if (!0 === this._gamepads[i].justPressed(t, e)) return !0;
                    return !1
                },
                justReleased: function(t, e) {
                    for (var i = 0; i < this._gamepads.length; i++)
                        if (!0 === this._gamepads[i].justReleased(t, e)) return !0;
                    return !1
                },
                isDown: function(t) {
                    for (var e = 0; e < this._gamepads.length; e++)
                        if (!0 === this._gamepads[e].isDown(t)) return !0;
                    return !1
                },
                destroy: function() { this.stop(); for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].destroy() }
            }, H.Gamepad.prototype.constructor = H.Gamepad, Object.defineProperty(H.Gamepad.prototype, "active", { get: function() { return this._active } }), Object.defineProperty(H.Gamepad.prototype, "supported", { get: function() { return this._gamepadSupportAvailable } }), Object.defineProperty(H.Gamepad.prototype, "padsConnected", { get: function() { return this._rawPads.length } }), Object.defineProperty(H.Gamepad.prototype, "pad1", { get: function() { return this._gamepads[0] } }), Object.defineProperty(H.Gamepad.prototype, "pad2", { get: function() { return this._gamepads[1] } }), Object.defineProperty(H.Gamepad.prototype, "pad3", { get: function() { return this._gamepads[2] } }), Object.defineProperty(H.Gamepad.prototype, "pad4", { get: function() { return this._gamepads[3] } }), H.Gamepad.BUTTON_0 = 0, H.Gamepad.BUTTON_1 = 1, H.Gamepad.BUTTON_2 = 2, H.Gamepad.BUTTON_3 = 3, H.Gamepad.BUTTON_4 = 4, H.Gamepad.BUTTON_5 = 5, H.Gamepad.BUTTON_6 = 6, H.Gamepad.BUTTON_7 = 7, H.Gamepad.BUTTON_8 = 8, H.Gamepad.BUTTON_9 = 9, H.Gamepad.BUTTON_10 = 10, H.Gamepad.BUTTON_11 = 11, H.Gamepad.BUTTON_12 = 12, H.Gamepad.BUTTON_13 = 13, H.Gamepad.BUTTON_14 = 14, H.Gamepad.BUTTON_15 = 15, H.Gamepad.AXIS_0 = 0, H.Gamepad.AXIS_1 = 1, H.Gamepad.AXIS_2 = 2, H.Gamepad.AXIS_3 = 3, H.Gamepad.AXIS_4 = 4, H.Gamepad.AXIS_5 = 5, H.Gamepad.AXIS_6 = 6, H.Gamepad.AXIS_7 = 7, H.Gamepad.AXIS_8 = 8, H.Gamepad.AXIS_9 = 9, H.Gamepad.XBOX360_A = 0, H.Gamepad.XBOX360_B = 1, H.Gamepad.XBOX360_X = 2, H.Gamepad.XBOX360_Y = 3, H.Gamepad.XBOX360_LEFT_BUMPER = 4, H.Gamepad.XBOX360_RIGHT_BUMPER = 5, H.Gamepad.XBOX360_LEFT_TRIGGER = 6, H.Gamepad.XBOX360_RIGHT_TRIGGER = 7, H.Gamepad.XBOX360_BACK = 8, H.Gamepad.XBOX360_START = 9, H.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, H.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, H.Gamepad.XBOX360_DPAD_LEFT = 14, H.Gamepad.XBOX360_DPAD_RIGHT = 15, H.Gamepad.XBOX360_DPAD_UP = 12, H.Gamepad.XBOX360_DPAD_DOWN = 13, H.Gamepad.XBOX360_STICK_LEFT_X = 0, H.Gamepad.XBOX360_STICK_LEFT_Y = 1, H.Gamepad.XBOX360_STICK_RIGHT_X = 2, H.Gamepad.XBOX360_STICK_RIGHT_Y = 3, H.Gamepad.PS3XC_X = 0, H.Gamepad.PS3XC_CIRCLE = 1, H.Gamepad.PS3XC_SQUARE = 2, H.Gamepad.PS3XC_TRIANGLE = 3, H.Gamepad.PS3XC_L1 = 4, H.Gamepad.PS3XC_R1 = 5, H.Gamepad.PS3XC_L2 = 6, H.Gamepad.PS3XC_R2 = 7, H.Gamepad.PS3XC_SELECT = 8, H.Gamepad.PS3XC_START = 9, H.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, H.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, H.Gamepad.PS3XC_DPAD_UP = 12, H.Gamepad.PS3XC_DPAD_DOWN = 13, H.Gamepad.PS3XC_DPAD_LEFT = 14, H.Gamepad.PS3XC_DPAD_RIGHT = 15, H.Gamepad.PS3XC_STICK_LEFT_X = 0, H.Gamepad.PS3XC_STICK_LEFT_Y = 1, H.Gamepad.PS3XC_STICK_RIGHT_X = 2, H.Gamepad.PS3XC_STICK_RIGHT_Y = 3, H.SinglePad = function(t, e) { this.game = t, this.index = null, this.connected = !1, (this.callbackContext = this).onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = e, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0 }, H.SinglePad.prototype = {
                addCallbacks: function(t, e) { void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t) },
                getButton: function(t) { return this._buttons[t] ? this._buttons[t] : null },
                pollStatus: function() {
                    if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                        for (var t = 0; t < this._buttonsLen; t++) {
                            var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                            e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                        }
                        for (var i = 0; i < this._axesLen; i++) {
                            var s = this._rawPad.axes[i];
                            0 < s && s > this.deadZone || s < 0 && s < -this.deadZone ? this.processAxisChange(i, s) : this.processAxisChange(i, 0)
                        }
                        this._prevTimestamp = this._rawPad.timestamp
                    }
                },
                connect: function(t) {
                    var e = !this.connected;
                    this.connected = !0, this.index = t.index, this._rawPad = t, this._buttons = [], this._buttonsLen = t.buttons.length, this._axes = [], this._axesLen = t.axes.length;
                    for (var i = 0; i < this._axesLen; i++) this._axes[i] = t.axes[i];
                    for (var s in t.buttons) s = parseInt(s, 10), this._buttons[s] = new H.DeviceButton(this, s);
                    e && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), e && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
                },
                disconnect: function() {
                    var t = this.connected,
                        e = this.index;
                    this.connected = !1, this.index = null, this._rawPad = void 0;
                    for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                    this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e), t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
                },
                destroy: function() {
                    this._rawPad = void 0;
                    for (var t = 0; t < this._buttonsLen; t++) this._buttons[t].destroy();
                    this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null
                },
                processAxisChange: function(t, e) { this._axes[t] !== e && (this._axes[t] = e, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e)) },
                processButtonDown: function(t, e) { this._buttons[t] && this._buttons[t].start(null, e), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e) },
                processButtonUp: function(t, e) { this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].stop(null, e) },
                processButtonFloat: function(t, e) { this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].padFloat(e) },
                axis: function(t) { return !!this._axes[t] && this._axes[t] },
                isDown: function(t) { return !!this._buttons[t] && this._buttons[t].isDown },
                isUp: function(t) { return !!this._buttons[t] && this._buttons[t].isUp },
                justReleased: function(t, e) { if (this._buttons[t]) return this._buttons[t].justReleased(e) },
                justPressed: function(t, e) { if (this._buttons[t]) return this._buttons[t].justPressed(e) },
                buttonValue: function(t) { return this._buttons[t] ? this._buttons[t].value : null },
                reset: function() { for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0 }
            }, H.SinglePad.prototype.constructor = H.SinglePad, H.Key = function(t, e) { this.game = t, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.repeats = 0, this.keyCode = e, this.onDown = new H.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new H.Signal, this._justDown = !1, this._justUp = !1 }, H.Key.prototype = { update: function() { this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this)) }, processKeyDown: function(t) { this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this))) }, processKeyUp: function(t) { this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this._justUp = !0, this.onUp.dispatch(this))) }, reset: function(t) { void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null) }, downDuration: function(t) { return void 0 === t && (t = 50), this.isDown && this.duration < t }, upDuration: function(t) { return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t } }, Object.defineProperty(H.Key.prototype, "justDown", { get: function() { var t = this._justDown; return this._justDown = !1, t } }), Object.defineProperty(H.Key.prototype, "justUp", { get: function() { var t = this._justUp; return this._justUp = !1, t } }), Object.defineProperty(H.Key.prototype, "enabled", {
                get: function() { return this._enabled },
                set: function(t) {
                    (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
                }
            }), H.Key.prototype.constructor = H.Key, H.Keyboard = function(t) { this.game = t, this.enabled = !0, this.event = null, this.pressEvent = null, (this.callbackContext = this).onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0 }, H.Keyboard.prototype = {
                addCallbacks: function(t, e, i, s) { this.callbackContext = t, null != e && (this.onDownCallback = e), null != i && (this.onUpCallback = i), null != s && (this.onPressCallback = s) },
                addKey: function(t) { return this._keys[t] || (this._keys[t] = new H.Key(this.game, t), this.addKeyCapture(t)), this._keys[t] },
                addKeys: function(t) { var e = {}; for (var i in t) e[i] = this.addKey(t[i]); return e },
                removeKey: function(t) { this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t)) },
                createCursorKeys: function() { return this.addKeys({ up: H.KeyCode.UP, down: H.KeyCode.DOWN, left: H.KeyCode.LEFT, right: H.KeyCode.RIGHT }) },
                start: function() {
                    if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                        var e = this;
                        this._onKeyDown = function(t) { return e.processKeyDown(t) }, this._onKeyUp = function(t) { return e.processKeyUp(t) }, this._onKeyPress = function(t) { return e.processKeyPress(t) }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1)
                    }
                },
                stop: function() { window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null },
                destroy: function() { this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0 },
                addKeyCapture: function(t) {
                    if ("object" == typeof t)
                        for (var e in t) this._capture[t[e]] = !0;
                    else this._capture[t] = !0
                },
                removeKeyCapture: function(t) { delete this._capture[t] },
                clearCaptures: function() { this._capture = {} },
                update: function() { for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update() },
                processKeyDown: function(t) {
                    if (this.event = t, this.game.input.enabled && this.enabled) {
                        var e = t.keyCode;
                        this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new H.Key(this.game, e)), this._keys[e].processKeyDown(t), this._k = e, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t)
                    }
                },
                processKeyPress: function(t) { this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t) },
                processKeyUp: function(t) {
                    if (this.event = t, this.game.input.enabled && this.enabled) {
                        var e = t.keyCode;
                        this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new H.Key(this.game, e)), this._keys[e].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t)
                    }
                },
                reset: function(t) { void 0 === t && (t = !0), this.event = null; for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t) },
                downDuration: function(t, e) { return this._keys[t] ? this._keys[t].downDuration(e) : null },
                upDuration: function(t, e) { return this._keys[t] ? this._keys[t].upDuration(e) : null },
                isDown: function(t) { return this._keys[t] ? this._keys[t].isDown : null }
            }, Object.defineProperty(H.Keyboard.prototype, "lastChar", { get: function() { return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode) } }), Object.defineProperty(H.Keyboard.prototype, "lastKey", { get: function() { return this._keys[this._k] } }), H.Keyboard.prototype.constructor = H.Keyboard, H.KeyCode = { A: "A".charCodeAt(0), B: "B".charCodeAt(0), C: "C".charCodeAt(0), D: "D".charCodeAt(0), E: "E".charCodeAt(0), F: "F".charCodeAt(0), G: "G".charCodeAt(0), H: "H".charCodeAt(0), I: "I".charCodeAt(0), J: "J".charCodeAt(0), K: "K".charCodeAt(0), L: "L".charCodeAt(0), M: "M".charCodeAt(0), N: "N".charCodeAt(0), O: "O".charCodeAt(0), P: "P".charCodeAt(0), Q: "Q".charCodeAt(0), R: "R".charCodeAt(0), S: "S".charCodeAt(0), T: "T".charCodeAt(0), U: "U".charCodeAt(0), V: "V".charCodeAt(0), W: "W".charCodeAt(0), X: "X".charCodeAt(0), Y: "Y".charCodeAt(0), Z: "Z".charCodeAt(0), ZERO: "0".charCodeAt(0), ONE: "1".charCodeAt(0), TWO: "2".charCodeAt(0), THREE: "3".charCodeAt(0), FOUR: "4".charCodeAt(0), FIVE: "5".charCodeAt(0), SIX: "6".charCodeAt(0), SEVEN: "7".charCodeAt(0), EIGHT: "8".charCodeAt(0), NINE: "9".charCodeAt(0), NUMPAD_0: 96, NUMPAD_1: 97, NUMPAD_2: 98, NUMPAD_3: 99, NUMPAD_4: 100, NUMPAD_5: 101, NUMPAD_6: 102, NUMPAD_7: 103, NUMPAD_8: 104, NUMPAD_9: 105, NUMPAD_MULTIPLY: 106, NUMPAD_ADD: 107, NUMPAD_ENTER: 108, NUMPAD_SUBTRACT: 109, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, F13: 124, F14: 125, F15: 126, COLON: 186, EQUALS: 187, COMMA: 188, UNDERSCORE: 189, PERIOD: 190, QUESTION_MARK: 191, TILDE: 192, OPEN_BRACKET: 219, BACKWARD_SLASH: 220, CLOSED_BRACKET: 221, QUOTES: 222, BACKSPACE: 8, TAB: 9, CLEAR: 12, ENTER: 13, SHIFT: 16, CONTROL: 17, ALT: 18, CAPS_LOCK: 20, ESC: 27, SPACEBAR: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PLUS: 43, MINUS: 44, INSERT: 45, DELETE: 46, HELP: 47, NUM_LOCK: 144 }, H.KeyCode) H.KeyCode.hasOwnProperty(i) && !i.match(/[a-z]/) && (H.Keyboard[i] = H.KeyCode[i]);
        for (var o in H.Component = function() {}, H.Component.Angle = function() {}, H.Component.Angle.prototype = { angle: { get: function() { return H.Math.wrapAngle(H.Math.radToDeg(this.rotation)) }, set: function(t) { this.rotation = H.Math.degToRad(H.Math.wrapAngle(t)) } } }, H.Component.Animation = function() {}, H.Component.Animation.prototype = { play: function(t, e, i, s) { if (this.animations) return this.animations.play(t, e, i, s) } }, H.Component.AutoCull = function() {}, H.Component.AutoCull.prototype = { autoCull: !1, inCamera: { get: function() { return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds) } } }, H.Component.Bounds = function() {}, H.Component.Bounds.prototype = {
                offsetX: { get: function() { return this.anchor.x * this.width } },
                offsetY: { get: function() { return this.anchor.y * this.height } },
                centerX: { get: function() { return this.x - this.offsetX + .5 * this.width }, set: function(t) { this.x = t + this.offsetX - .5 * this.width } },
                centerY: { get: function() { return this.y - this.offsetY + .5 * this.height }, set: function(t) { this.y = t + this.offsetY - .5 * this.height } },
                left: { get: function() { return this.x - this.offsetX }, set: function(t) { this.x = t + this.offsetX } },
                right: { get: function() { return this.x + this.width - this.offsetX }, set: function(t) { this.x = t - this.width + this.offsetX } },
                top: { get: function() { return this.y - this.offsetY }, set: function(t) { this.y = t + this.offsetY } },
                bottom: { get: function() { return this.y + this.height - this.offsetY }, set: function(t) { this.y = t - this.height + this.offsetY } },
                alignIn: function(t, e, i, s) {
                    switch (void 0 === i && (i = 0), void 0 === s && (s = 0), e) {
                        default:
                            case H.TOP_LEFT:
                            this.left = t.left - i,
                        this.top = t.top - s;
                        break;
                        case H.TOP_CENTER:
                                this.centerX = t.centerX + i,
                            this.top = t.top - s;
                            break;
                        case H.TOP_RIGHT:
                                this.right = t.right + i,
                            this.top = t.top - s;
                            break;
                        case H.LEFT_CENTER:
                                this.left = t.left - i,
                            this.centerY = t.centerY + s;
                            break;
                        case H.CENTER:
                                this.centerX = t.centerX + i,
                            this.centerY = t.centerY + s;
                            break;
                        case H.RIGHT_CENTER:
                                this.right = t.right + i,
                            this.centerY = t.centerY + s;
                            break;
                        case H.BOTTOM_LEFT:
                                this.left = t.left - i,
                            this.bottom = t.bottom + s;
                            break;
                        case H.BOTTOM_CENTER:
                                this.centerX = t.centerX + i,
                            this.bottom = t.bottom + s;
                            break;
                        case H.BOTTOM_RIGHT:
                                this.right = t.right + i,
                            this.bottom = t.bottom + s
                    }
                    return this
                },
                alignTo: function(t, e, i, s) {
                    switch (void 0 === i && (i = 0), void 0 === s && (s = 0), e) {
                        default:
                            case H.TOP_LEFT:
                            this.left = t.left - i,
                        this.bottom = t.top - s;
                        break;
                        case H.TOP_CENTER:
                                this.centerX = t.centerX + i,
                            this.bottom = t.top - s;
                            break;
                        case H.TOP_RIGHT:
                                this.right = t.right + i,
                            this.bottom = t.top - s;
                            break;
                        case H.LEFT_TOP:
                                this.right = t.left - i,
                            this.top = t.top - s;
                            break;
                        case H.LEFT_CENTER:
                                this.right = t.left - i,
                            this.centerY = t.centerY + s;
                            break;
                        case H.LEFT_BOTTOM:
                                this.right = t.left - i,
                            this.bottom = t.bottom + s;
                            break;
                        case H.RIGHT_TOP:
                                this.left = t.right + i,
                            this.top = t.top - s;
                            break;
                        case H.RIGHT_CENTER:
                                this.left = t.right + i,
                            this.centerY = t.centerY + s;
                            break;
                        case H.RIGHT_BOTTOM:
                                this.left = t.right + i,
                            this.bottom = t.bottom + s;
                            break;
                        case H.BOTTOM_LEFT:
                                this.left = t.left - i,
                            this.top = t.bottom + s;
                            break;
                        case H.BOTTOM_CENTER:
                                this.centerX = t.centerX + i,
                            this.top = t.bottom + s;
                            break;
                        case H.BOTTOM_RIGHT:
                                this.right = t.right + i,
                            this.top = t.bottom + s
                    }
                    return this
                }
            }, H.Group.prototype.alignIn = H.Component.Bounds.prototype.alignIn, H.Group.prototype.alignTo = H.Component.Bounds.prototype.alignTo, H.Component.BringToTop = function() {}, H.Component.BringToTop.prototype.bringToTop = function() { return this.parent && this.parent.bringToTop(this), this }, H.Component.BringToTop.prototype.sendToBack = function() { return this.parent && this.parent.sendToBack(this), this }, H.Component.BringToTop.prototype.moveUp = function() { return this.parent && this.parent.moveUp(this), this }, H.Component.BringToTop.prototype.moveDown = function() { return this.parent && this.parent.moveDown(this), this }, H.Component.Core = function() {}, H.Component.Core.install = function(t) {
                H.Utils.mixinPrototype(this, H.Component.Core.prototype), this.components = {};
                for (var e = 0; e < t.length; e++) {
                    var i = t[e],
                        s = !1;
                    "Destroy" === i && (s = !0), H.Utils.mixinPrototype(this, H.Component[i].prototype, s), this.components[i] = !0
                }
            }, H.Component.Core.init = function(t, e, i, s, o) { this.game = t, this.key = s, this.data = {}, this.position.set(e, i), this.world = new H.Point(e, i), this.previousPosition = new H.Point(e, i), this.events = new H.Events(this), this._bounds = new H.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new H.AnimationManager(this)), this.components.LoadTexture && null !== s && this.loadTexture(s, o), this.components.FixedToCamera && (this.cameraOffset = new H.Point(e, i)) }, H.Component.Core.preUpdate = function() {
                if (!this.pendingDestroy) {
                    if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return !(this.renderOrderID = -1);
                    this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
                    for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
                    return !0
                }
                this.destroy()
            }, H.Component.Core.prototype = { game: null, name: "", data: {}, components: {}, z: 0, events: void 0, animations: void 0, key: "", world: null, debug: !1, previousPosition: null, previousRotation: 0, renderOrderID: 0, fresh: !0, pendingDestroy: !1, _bounds: null, _exists: !0, exists: { get: function() { return this._exists }, set: function(t) { this.visible = t ? (this._exists = !0, this.body && this.body.type === H.Physics.P2JS && this.body.addToWorld(), !0) : (this._exists = !1, this.body && this.body.type === H.Physics.P2JS && this.body.removeFromWorld(), !1) } }, update: function() {}, postUpdate: function() { this.customRender && this.key.render(), this.components.PhysicsBody && H.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && H.Component.FixedToCamera.postUpdate.call(this); for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate() } }, H.Component.Crop = function() {}, H.Component.Crop.prototype = {
                cropRect: null,
                _crop: null,
                crop: function(t, e) { void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new H.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame()) },
                updateCrop: function() {
                    if (this.cropRect) {
                        var t = this.texture.crop.x,
                            e = this.texture.crop.y,
                            i = this.texture.crop.width,
                            s = this.texture.crop.height;
                        this._crop = H.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                        var o = Math.max(this._frame.x, this._crop.x),
                            n = Math.max(this._frame.y, this._crop.y),
                            a = Math.min(this._frame.right, this._crop.right) - o,
                            r = Math.min(this._frame.bottom, this._crop.bottom) - n;
                        this.texture.crop.x = o, this.texture.crop.y = n, this.texture.crop.width = a, this.texture.crop.height = r, this.texture.frame.width = Math.min(a, this.cropRect.width), this.texture.frame.height = Math.min(r, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === o && e === n && i === a && s === r || (this.texture.requiresReTint = !0)
                    }
                }
            }, H.Component.Delta = function() {}, H.Component.Delta.prototype = { deltaX: { get: function() { return this.world.x - this.previousPosition.x } }, deltaY: { get: function() { return this.world.y - this.previousPosition.y } }, deltaZ: { get: function() { return this.rotation - this.previousRotation } } }, H.Component.Destroy = function() {}, H.Component.Destroy.prototype = {
                destroyPhase: !1,
                destroy: function(t, e) {
                    if (null !== this.game && !this.destroyPhase) {
                        void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof H.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                        var i = this.children.length;
                        if (t)
                            for (; i--;) this.children[i].destroy(t);
                        else
                            for (; i--;) this.removeChild(this.children[i]);
                        this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), H.Video && this.key instanceof H.Video && this.key.onChangeSource.remove(this.resizeFrame, this), H.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                    }
                }
            }, H.Events = function(t) { this.parent = t }, H.Events.prototype = { destroy: function() { this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose() }, onAddedToGroup: null, onRemovedFromGroup: null, onRemovedFromWorld: null, onDestroy: null, onKilled: null, onRevived: null, onOutOfBounds: null, onEnterBounds: null, onInputOver: null, onInputOut: null, onInputDown: null, onInputUp: null, onDragStart: null, onDragUpdate: null, onDragStop: null, onAnimationStart: null, onAnimationComplete: null, onAnimationLoop: null }, H.Events.prototype.constructor = H.Events, H.Events.prototype) H.Events.prototype.hasOwnProperty(o) && 0 === o.indexOf("on") && null === H.Events.prototype[o] && function(t, e) {
            "use strict";
            Object.defineProperty(H.Events.prototype, t, { get: function() { return this[e] || (this[e] = new H.Signal) } }), H.Events.prototype[t + "$dispatch"] = function() { return this[e] ? this[e].dispatch.apply(this[e], arguments) : null }
        }(o, "_" + o);
        H.Component.FixedToCamera = function() {}, H.Component.FixedToCamera.postUpdate = function() { this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y) }, H.Component.FixedToCamera.prototype = { _fixedToCamera: !1, fixedToCamera: { get: function() { return this._fixedToCamera }, set: function(t) { t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1 } }, cameraOffset: new H.Point }, H.Component.Health = function() {}, H.Component.Health.prototype = { health: 1, maxHealth: 100, damage: function(t) { return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this }, setHealth: function(t) { return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this }, heal: function(t) { return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this } }, H.Component.InCamera = function() {}, H.Component.InCamera.prototype = { inCamera: { get: function() { return this.game.world.camera.view.intersects(this._bounds) } } }, H.Component.InputEnabled = function() {}, H.Component.InputEnabled.prototype = { input: null, inputEnabled: { get: function() { return this.input && this.input.enabled }, set: function(t) { t ? null === this.input ? (this.input = new H.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop() } } }, H.Component.InWorld = function() {}, H.Component.InWorld.preUpdate = function() {
            if (this.autoCull || this.checkWorldBounds) {
                if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                    if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                    else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                if (this.checkWorldBounds)
                    if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                    else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
            }
            return !0
        }, H.Component.InWorld.prototype = { checkWorldBounds: !1, outOfBoundsKill: !1, outOfCameraBoundsKill: !1, _outOfBoundsFired: !1, inWorld: { get: function() { return this.game.world.bounds.intersects(this.getBounds()) } } }, H.Component.LifeSpan = function() {}, H.Component.LifeSpan.preUpdate = function() { return !(0 < this.lifespan && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1) }, H.Component.LifeSpan.prototype = { alive: !0, lifespan: 0, revive: function(t) { return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this }, kill: function() { return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this } }, H.Component.LoadTexture = function() {}, H.Component.LoadTexture.prototype = {
            customRender: !1,
            _frame: null,
            loadTexture: function(t, e, i) {
                e = t === H.PENDING_ATLAS ? (t = e, 0) : e || 0, (i || void 0 === i) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
                var s = this.game.cache,
                    o = !0,
                    n = !this.texture.baseTexture.scaleMode;
                if (H.RenderTexture && t instanceof H.RenderTexture) this.key = t.key, this.setTexture(t);
                else if (H.BitmapData && t instanceof H.BitmapData) this.customRender = !0, this.setTexture(t.texture), o = s.hasFrameData(t.key, H.Cache.BITMAPDATA) ? !this.animations.loadFrameData(s.getFrameData(t.key, H.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0);
                else if (H.Video && t instanceof H.Video) {
                    this.customRender = !0;
                    var a = t.texture.valid;
                    this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = a
                }
                else if (H.Tilemap && t instanceof H.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas));
                else if (t instanceof PIXI.Texture) this.setTexture(t);
                else {
                    var r